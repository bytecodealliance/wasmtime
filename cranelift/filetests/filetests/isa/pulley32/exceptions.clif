test compile precise-output
target pulley32

function %f0(i32) -> i32, f32, f64 {
    sig0 = (i32) -> f32 tail
    fn0 = colocated %g(i32) -> f32 tail

    block0(v1: i32):
        v2 = f64const 0x1.0
        try_call fn0(v1), sig0, block1(ret0, v2), [ default: block2(exn0) ]

    block1(v3: f32, v4: f64):
        v5 = iconst.i32 1
        return v5, v3, v4

    block2(v6: i32):
        v8 = iadd_imm.i32 v6, 1
        v9 = f32const 0x0.0
        return v8, v9, v2
}

; VCode:
;   push_frame_save 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
; block0:
;   fconst64 f1, 4607182418800017408
;   fstore64 Slot(0), f1 // flags =  notrap aligned
;   call CallInfo { dest: PulleyCall { name: TestCase(%g), args: [XReg(p0i)] }, uses: [], defs: [CallRetPair { vreg: Writable { reg: p0f }, location: Reg(p0f, types::F32) }, CallRetPair { vreg: Writable { reg: p0i }, location: Reg(p0i, types::I32) }, CallRetPair { vreg: Writable { reg: p1i }, location: Reg(p1i, types::I32) }], clobbers: PRegSet { bits: [4294967292, 4294967294, 4294967295, 0] }, callee_conv: Tail, caller_conv: Fast, callee_pop_size: 0, try_call_info: Some(TryCallInfo { continuation: MachLabel(1), exception_handlers: [Default(MachLabel(2))] }) }; jump MachLabel(1); catch [default: MachLabel(2)]
; block1:
;   xone x0
;   f1 = fload64 Slot(0) // flags = notrap aligned
;   pop_frame_restore 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
; block2:
;   f1 = fload64 Slot(0) // flags = notrap aligned
;   xadd32_u8 x0, x0, 1
;   fconst32 f0, 0
;   pop_frame_restore 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
;
; Disassembled:
; push_frame_save 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; fconst64 f1, 4607182418800017408
; fstore64le_o32 sp, 0, f1
; call 0x1    // target = 0x1b
; xone x0
; fload64le_o32 f1, sp, 0
; pop_frame_restore 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret
; fload64le_o32 f1, sp, 0
; xadd32_u8 x0, x0, 1
; fconst32 f0, 0
; pop_frame_restore 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret

function %f2(i32, i32) -> i32, f32, f64 {
    sig0 = (i32) -> f32 tail
    fn0 = %g(i32) -> f32 tail

    block0(v1: i32, v10: i32):
        v2 = f64const 0x1.0
        try_call_indirect v10(v1), sig0, block1(ret0, v2), [ default: block2(exn0) ]

    block1(v3: f32, v4: f64):
        v5 = iconst.i32 1
        return v5, v3, v4

    block2(v7: i32):
        v8 = iadd_imm.i32 v7, 1
        v9 = f32const 0x0.0
        return v8, v9, v2
}

; VCode:
;   push_frame_save 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
; block0:
;   fconst64 f1, 4607182418800017408
;   fstore64 Slot(0), f1 // flags =  notrap aligned
;   indirect_call x1, CallInfo { dest: XReg(p1i), uses: [CallArgPair { vreg: p0i, preg: p0i }], defs: [CallRetPair { vreg: Writable { reg: p0f }, location: Reg(p0f, types::F32) }, CallRetPair { vreg: Writable { reg: p0i }, location: Reg(p0i, types::I32) }, CallRetPair { vreg: Writable { reg: p1i }, location: Reg(p1i, types::I32) }], clobbers: PRegSet { bits: [4294967292, 4294967294, 4294967295, 0] }, callee_conv: Tail, caller_conv: Fast, callee_pop_size: 0, try_call_info: Some(TryCallInfo { continuation: MachLabel(1), exception_handlers: [Default(MachLabel(2))] }) }; jump MachLabel(1); catch [default: MachLabel(2)]
; block1:
;   xone x0
;   f1 = fload64 Slot(0) // flags = notrap aligned
;   pop_frame_restore 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
; block2:
;   f1 = fload64 Slot(0) // flags = notrap aligned
;   xadd32_u8 x0, x0, 1
;   fconst32 f0, 0
;   pop_frame_restore 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
;
; Disassembled:
; push_frame_save 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; fconst64 f1, 4607182418800017408
; fstore64le_o32 sp, 0, f1
; call_indirect x1
; xone x0
; fload64le_o32 f1, sp, 0
; pop_frame_restore 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret
; fload64le_o32 f1, sp, 0
; xadd32_u8 x0, x0, 1
; fconst32 f0, 0
; pop_frame_restore 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret

function %f4(i32, i32) -> i32, f32, f64 {
    sig0 = (i32) -> f32 tail
    fn0 = colocated %g(i32) -> f32 tail

    block0(v0: i32, v1: i32):
        v2 = f64const 0x1.0
        try_call fn0(v1), sig0, block1(ret0, v2), [ context v0, tag0: block2(exn0), tag1: block2(exn0), context v1, tag0: block3 ]

    block1(v3: f32, v4: f64):
        v5 = iconst.i32 1
        return v5, v3, v4

    block2(v6: i32):
        v8 = iadd_imm.i32 v6, 1
        v9 = f32const 0x0.0
        return v8, v9, v2

    block3:
        jump block2(v0)
}

; VCode:
;   push_frame_save 160, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
; block0:
;   xstore64 Slot(0), x1 // flags =  notrap aligned
;   xstore64 Slot(8), x0 // flags =  notrap aligned
;   fconst64 f1, 4607182418800017408
;   x2 = xload64 Slot(0) // flags = notrap aligned
;   fstore64 Slot(16), f1 // flags =  notrap aligned
;   call CallInfo { dest: PulleyCall { name: TestCase(%g), args: [XReg(p2i)] }, uses: [], defs: [CallRetPair { vreg: Writable { reg: p0f }, location: Reg(p0f, types::F32) }, CallRetPair { vreg: Writable { reg: p0i }, location: Reg(p0i, types::I32) }, CallRetPair { vreg: Writable { reg: p1i }, location: Reg(p1i, types::I32) }], clobbers: PRegSet { bits: [4294967292, 4294967294, 4294967295, 0] }, callee_conv: Tail, caller_conv: Fast, callee_pop_size: 0, try_call_info: Some(TryCallInfo { continuation: MachLabel(3), exception_handlers: [Context(stack2), Tag(tag0, MachLabel(1)), Tag(tag1, MachLabel(2)), Context(stack0), Tag(tag0, MachLabel(4))] }) }; jump MachLabel(3); catch [context stack2, tag0: MachLabel(1), tag1: MachLabel(2), context stack0, tag0: MachLabel(4)]
; block1:
;   xmov x3, x0
;   f1 = fload64 Slot(16) // flags = notrap aligned
;   jump label5
; block2:
;   xmov x3, x0
;   f1 = fload64 Slot(16) // flags = notrap aligned
;   jump label5
; block3:
;   xone x0
;   f1 = fload64 Slot(16) // flags = notrap aligned
;   pop_frame_restore 160, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
; block4:
;   f1 = fload64 Slot(16) // flags = notrap aligned
;   x3 = xload64 Slot(8) // flags = notrap aligned
;   jump label5
; block5:
;   xadd32_u8 x0, x3, 1
;   fconst32 f0, 0
;   pop_frame_restore 160, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
;
; Disassembled:
; push_frame_save 160, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; xstore64le_o32 sp, 0, x1
; xstore64le_o32 sp, 8, x0
; fconst64 f1, 4607182418800017408
; xload64le_o32 x2, sp, 0
; fstore64le_o32 sp, 16, f1
; call1 x2, 0x2    // target = 0x31
; jump 0x27    // target = 0x5c
; xmov x3, x0
; fload64le_o32 f1, sp, 16
; jump 0x37    // target = 0x7d
; xmov x3, x0
; fload64le_o32 f1, sp, 16
; jump 0x26    // target = 0x7d
; xone x0
; fload64le_o32 f1, sp, 16
; pop_frame_restore 160, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret
; fload64le_o32 f1, sp, 16
; xload64le_o32 x3, sp, 8
; xadd32_u8 x0, x3, 1
; fconst32 f0, 0
; pop_frame_restore 160, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret

function %f5() -> i32 {
    sig0 = () tail
    fn0 = %g() tail

    block0:
        v1 = get_exception_handler_address.i32 block1, 0
        jump block1

    block1:
        try_call fn0(), sig0, block2(), [ default: block3() ]

    block2:
        return v1

    block3:
        return v1
}

; VCode:
;   push_frame_save 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
; block0:
;   exception_handler_address x0, MachLabel(3)
;   xstore64 Slot(0), x0 // flags =  notrap aligned
;   jump label1
; block1:
;   indirect_call_host CallInfo { dest: TestCase(%g), uses: [], defs: [CallRetPair { vreg: Writable { reg: p0i }, location: Reg(p0i, types::I32) }, CallRetPair { vreg: Writable { reg: p1i }, location: Reg(p1i, types::I32) }], clobbers: PRegSet { bits: [4294967292, 4294967295, 4294967295, 0] }, callee_conv: Tail, caller_conv: Fast, callee_pop_size: 0, try_call_info: Some(TryCallInfo { continuation: MachLabel(2), exception_handlers: [Default(MachLabel(3))] }) }; jump MachLabel(2); catch [default: MachLabel(3)]
; block2:
;   x0 = xload64 Slot(0) // flags = notrap aligned
;   pop_frame_restore 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
; block3:
;   x0 = xload64 Slot(0) // flags = notrap aligned
;   pop_frame_restore 144, {x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0}
;   ret
;
; Disassembled:
; push_frame_save 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; xpcadd x0, 0x20    // target = 0x25
; xstore64le_o32 sp, 0, x0
; call_indirect_host 0
; xload64le_o32 x0, sp, 0
; pop_frame_restore 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret
; xload64le_o32 x0, sp, 0
; pop_frame_restore 144, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, sp, spilltmp0
; ret

