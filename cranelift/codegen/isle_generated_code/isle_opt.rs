// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_opt.isle
// - src/opts/arithmetic.isle
// - src/opts/bitops.isle
// - src/opts/cprop.isle
// - src/opts/extends.isle
// - src/opts/icmp.isle
// - src/opts/remat.isle
// - src/opts/selects.isle
// - src/opts/shifts.isle
// - src/opts/vector.isle
// - /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn i64_neg(&mut self, arg0: i64) -> i64;
    fn u128_as_u64(&mut self, arg0: u128) -> Option<u64>;
    fn u64_as_u32(&mut self, arg0: u64) -> Option<u32>;
    fn u64_as_i32(&mut self, arg0: u64) -> i32;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shl(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_shr(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_sub(&mut self, arg0: u32, arg1: u32) -> u32;
    fn u32_and(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_shl(&mut self, arg0: u64, arg1: u64) -> u64;
    fn imm64_shl(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_ushr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn imm64_sshr(&mut self, arg0: Type, arg1: Imm64, arg2: Imm64) -> Imm64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_eq(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_le(&mut self, arg0: u64, arg1: u64) -> bool;
    fn u64_lt(&mut self, arg0: u64, arg1: u64) -> bool;
    fn i64_sextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> i64;
    fn u64_uextend_imm64(&mut self, arg0: Type, arg1: Imm64) -> u64;
    fn imm64_icmp(&mut self, arg0: Type, arg1: &IntCC, arg2: Imm64, arg3: Imm64) -> Imm64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_umin(&mut self, arg0: Type) -> u64;
    fn ty_umax(&mut self, arg0: Type) -> u64;
    fn ty_smin(&mut self, arg0: Type) -> u64;
    fn ty_smax(&mut self, arg0: Type) -> u64;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_mask(&mut self, arg0: Type) -> u64;
    fn ty_lane_count(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn ty_half_lanes(&mut self, arg0: Type) -> Option<Type>;
    fn ty_half_width(&mut self, arg0: Type) -> Option<Type>;
    fn ty_equal(&mut self, arg0: Type, arg1: Type) -> bool;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_unordered(&mut self, arg0: &FloatCC) -> bool;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64_extract(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_16_to_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_addr64(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64_power_of_two(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u32_from_ieee32(&mut self, arg0: Ieee32) -> u32;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn u32_to_offset32(&mut self, arg0: u32) -> Offset32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    type inst_data_etor_iter: ContextIter<Context = Self, Output = (Type, InstructionData)>;
    fn inst_data_etor(&mut self, arg0: Value) -> Self::inst_data_etor_iter;
    fn make_inst_ctor(&mut self, arg0: Type, arg1: &InstructionData) -> Value;
    fn value_array_2_ctor(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn value_array_3_ctor(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn remat(&mut self, arg0: Value) -> Value;
    fn subsume(&mut self, arg0: Value) -> Value;
    fn splat64(&mut self, arg0: u64) -> Constant;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
    fn unpack_block_array_2(&mut self, arg0: &BlockArray2) -> (BlockCall, BlockCall);
    fn pack_block_array_2(&mut self, arg0: BlockCall, arg1: BlockCall) -> BlockArray2;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

// Generated as internal constructor for term eq.
pub fn constructor_eq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg1, arg2);
    // Rule at src/prelude_opt.isle line 20.
    return v4;
}

// Generated as internal constructor for term ne.
pub fn constructor_ne<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 21.
    return v4;
}

// Generated as internal constructor for term ult.
pub fn constructor_ult<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 22.
    return v4;
}

// Generated as internal constructor for term ule.
pub fn constructor_ule<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 23.
    return v4;
}

// Generated as internal constructor for term ugt.
pub fn constructor_ugt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 24.
    return v4;
}

// Generated as internal constructor for term uge.
pub fn constructor_uge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 25.
    return v4;
}

// Generated as internal constructor for term slt.
pub fn constructor_slt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 26.
    return v4;
}

// Generated as internal constructor for term sle.
pub fn constructor_sle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 27.
    return v4;
}

// Generated as internal constructor for term sgt.
pub fn constructor_sgt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg1, arg2);
    // Rule at src/prelude_opt.isle line 28.
    return v4;
}

// Generated as internal constructor for term sge.
pub fn constructor_sge<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg1, arg2);
    // Rule at src/prelude_opt.isle line 29.
    return v4;
}

// Generated as internal constructor for term simplify.
pub fn constructor_simplify<C: Context>(
    ctx: &mut C,
    arg0: Value,
) -> impl ContextIter<Context = C, Output = Value> {
    let mut returns = ConstructorVec::new();
    let v1 = C::inst_data_etor(ctx, arg0);
    let mut v1 = v1;
    while let Some(v2) = v1.next(ctx) {
        match &v2.1 {
            &InstructionData::Binary {
                opcode: ref v5,
                args: ref v6,
            } => {
                match v5 {
                    &Opcode::Iadd => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v257 = constructor_iadd(ctx, v2.0, v125.1, v7.1);
                                                                                let v258 = constructor_iadd(ctx, v2.0, v125.0, v257);
                                                                                // Rule at src/opts/cprop.isle line 125.
                                                                                returns.push(v258);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v270 = C::u64_sub(ctx, v16, v141);
                                                                                let v271 = C::imm64_masked(ctx, v2.0, v270);
                                                                                let v272 = constructor_iconst(ctx, v2.0, v271);
                                                                                let v274 = constructor_iadd(ctx, v2.0, v125.0, v272);
                                                                                // Rule at src/opts/cprop.isle line 147.
                                                                                returns.push(v274);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v156 =
                                                                    C::inst_data_etor(ctx, v125.0);
                                                                let mut v156 = v156;
                                                                while let Some(v157) =
                                                                    v156.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v263,
                                                                        imm: v264,
                                                                    } = &v157.1 {
                                                                        if let &Opcode::Iconst = v263 {
                                                                            if v2.0 == v157.0 {
                                                                                let v265 = C::u64_from_imm64(ctx, v264);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v275 = C::u64_add(ctx, v265, v16);
                                                                                let v276 = C::imm64_masked(ctx, v2.0, v275);
                                                                                let v277 = constructor_iconst(ctx, v2.0, v276);
                                                                                let v278 = constructor_isub(ctx, v2.0, v277, v125.1);
                                                                                // Rule at src/opts/cprop.isle line 151.
                                                                                returns.push(v278);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            if v2.0 == v11.0 {
                                                                let v55 = constructor_ineg(
                                                                    ctx, v2.0, v37,
                                                                );
                                                                // Rule at src/opts/arithmetic.isle line 71.
                                                                returns.push(v55);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 9.
                                                    returns.push(v25);
                                                }
                                                0x1 => {
                                                    let v10 = C::inst_data_etor(ctx, v7.1);
                                                    let mut v10 = v10;
                                                    while let Some(v11) = v10.next(ctx) {
                                                        if let &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } = &v11.1
                                                        {
                                                            if let &Opcode::Bnot = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v56 = constructor_ineg(
                                                                        ctx, v2.0, v39,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 73.
                                                                    returns.push(v56);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                            let v248 = constructor_iadd(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 94.
                                            returns.push(v248);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v163 =
                                                                    C::u64_add(ctx, v24, v16);
                                                                let v164 =
                                                                    C::imm64_masked(ctx, v45, v163);
                                                                let v165 = constructor_iconst(
                                                                    ctx, v45, v164,
                                                                );
                                                                let v166 = C::subsume(ctx, v165);
                                                                // Rule at src/opts/cprop.isle line 3.
                                                                returns.push(v166);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 4.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 5.
                                            returns.push(v17);
                                        }
                                    }
                                    let v406 = C::remat(ctx, arg0);
                                    // Rule at src/opts/remat.isle line 6.
                                    returns.push(v406);
                                }
                            }
                        }
                    }
                    &Opcode::Isub => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v270 = C::u64_sub(ctx, v16, v141);
                                                                                let v271 = C::imm64_masked(ctx, v2.0, v270);
                                                                                let v272 = constructor_iconst(ctx, v2.0, v271);
                                                                                let v273 = constructor_isub(ctx, v2.0, v125.0, v272);
                                                                                // Rule at src/opts/cprop.isle line 143.
                                                                                returns.push(v273);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v259 = C::u64_add(ctx, v141, v16);
                                                                                let v260 = C::imm64_masked(ctx, v2.0, v259);
                                                                                let v261 = constructor_iconst(ctx, v2.0, v260);
                                                                                let v262 = constructor_isub(ctx, v2.0, v125.0, v261);
                                                                                // Rule at src/opts/cprop.isle line 135.
                                                                                returns.push(v262);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                let v156 =
                                                                    C::inst_data_etor(ctx, v125.0);
                                                                let mut v156 = v156;
                                                                while let Some(v157) =
                                                                    v156.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v263,
                                                                        imm: v264,
                                                                    } = &v157.1 {
                                                                        if let &Opcode::Iconst = v263 {
                                                                            if v2.0 == v157.0 {
                                                                                let v265 = C::u64_from_imm64(ctx, v264);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v266 = C::u64_sub(ctx, v265, v16);
                                                                                let v267 = C::imm64_masked(ctx, v2.0, v266);
                                                                                let v268 = constructor_iconst(ctx, v2.0, v267);
                                                                                let v269 = constructor_isub(ctx, v2.0, v268, v125.1);
                                                                                // Rule at src/opts/cprop.isle line 139.
                                                                                returns.push(v269);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v52 =
                                                            C::i64_sextend_imm64(ctx, v2.0, v15);
                                                        if v52 == -0x1 {
                                                            if v2.0 == v11.0 {
                                                                let v55 = constructor_ineg(
                                                                    ctx, v2.0, v37,
                                                                );
                                                                // Rule at src/opts/arithmetic.isle line 75.
                                                                returns.push(v55);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 19.
                                                returns.push(v26);
                                            }
                                            let v249 = constructor_isub(ctx, v2.0, v7.1, v7.0);
                                            let v250 = constructor_ineg(ctx, v2.0, v249);
                                            // Rule at src/opts/cprop.isle line 99.
                                            returns.push(v250);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v167 =
                                                                    C::u64_sub(ctx, v24, v16);
                                                                let v168 =
                                                                    C::imm64_masked(ctx, v45, v167);
                                                                let v169 = constructor_iconst(
                                                                    ctx, v45, v168,
                                                                );
                                                                let v170 = C::subsume(ctx, v169);
                                                                // Rule at src/opts/cprop.isle line 9.
                                                                returns.push(v170);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 8.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 14.
                                            returns.push(v17);
                                        }
                                    }
                                    let v406 = C::remat(ctx, arg0);
                                    // Rule at src/opts/remat.isle line 10.
                                    returns.push(v406);
                                }
                            }
                        }
                        if v7.0 == v7.1 {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v49 = C::imm64(ctx, 0x0);
                                    let v50 = constructor_iconst(ctx, v47, v49);
                                    let v51 = C::subsume(ctx, v50);
                                    // Rule at src/opts/arithmetic.isle line 40.
                                    returns.push(v51);
                                }
                            }
                        }
                    }
                    &Opcode::Imul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    if let &Opcode::Imul = v123 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v279 = constructor_imul(ctx, v2.0, v125.1, v7.1);
                                                                            let v280 = constructor_imul(ctx, v2.0, v125.0, v279);
                                                                            // Rule at src/opts/cprop.isle line 156.
                                                                            returns.push(v280);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Ineg = v36 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::Unary {
                                                    opcode: ref v38,
                                                    arg: v39,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Ineg = v38 {
                                                        if v2.0 == v11.0 {
                                                            let v40 = constructor_imul(
                                                                ctx, v2.0, v37, v39,
                                                            );
                                                            let v41 = C::subsume(ctx, v40);
                                                            // Rule at src/opts/arithmetic.isle line 28.
                                                            returns.push(v41);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            match v24 {
                                                0x0 => {
                                                    let v17 = C::subsume(ctx, v7.0);
                                                    // Rule at src/opts/arithmetic.isle line 57.
                                                    returns.push(v17);
                                                }
                                                0x1 => {
                                                    let v25 = C::subsume(ctx, v7.1);
                                                    // Rule at src/opts/arithmetic.isle line 47.
                                                    returns.push(v25);
                                                }
                                                _ => {}
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v23);
                                            if v54 == -0x1 {
                                                let v26 = constructor_ineg(ctx, v2.0, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 66.
                                                returns.push(v26);
                                            }
                                            let v251 = constructor_imul(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 102.
                                            returns.push(v251);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v171 =
                                                                    C::u64_mul(ctx, v24, v16);
                                                                let v172 =
                                                                    C::imm64_masked(ctx, v45, v171);
                                                                let v173 = constructor_iconst(
                                                                    ctx, v45, v172,
                                                                );
                                                                let v174 = C::subsume(ctx, v173);
                                                                // Rule at src/opts/cprop.isle line 15.
                                                                returns.push(v174);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v82 = C::simm32(ctx, v23);
                                        if let Some(v83) = v82 {
                                            if v83 == 0x2 {
                                                let v84 = constructor_iadd(ctx, v2.0, v7.1, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 105.
                                                returns.push(v84);
                                            }
                                        }
                                        let v90 = C::imm64_power_of_two(ctx, v23);
                                        if let Some(v91) = v90 {
                                            let v92 = C::imm64(ctx, v91);
                                            let v93 = constructor_iconst(ctx, v2.0, v92);
                                            let v94 = constructor_ishl(ctx, v2.0, v7.1, v93);
                                            // Rule at src/opts/arithmetic.isle line 114.
                                            returns.push(v94);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    if v2.0 == v11.0 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        match v16 {
                                            0x0 => {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/arithmetic.isle line 53.
                                                returns.push(v25);
                                            }
                                            0x1 => {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/arithmetic.isle line 43.
                                                returns.push(v17);
                                            }
                                            _ => {}
                                        }
                                        let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                        if v52 == -0x1 {
                                            let v53 = constructor_ineg(ctx, v2.0, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 63.
                                            returns.push(v53);
                                        }
                                    }
                                    let v79 = C::simm32(ctx, v15);
                                    if let Some(v80) = v79 {
                                        if v80 == 0x2 {
                                            let v81 = constructor_iadd(ctx, v2.0, v7.0, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 103.
                                            returns.push(v81);
                                        }
                                    }
                                    let v85 = C::imm64_power_of_two(ctx, v15);
                                    if let Some(v86) = v85 {
                                        let v87 = C::imm64(ctx, v86);
                                        let v88 = constructor_iconst(ctx, v2.0, v87);
                                        let v89 = constructor_ishl(ctx, v2.0, v7.0, v88);
                                        // Rule at src/opts/arithmetic.isle line 112.
                                        returns.push(v89);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Udiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 94.
                                            returns.push(v17);
                                        }
                                    }
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        if v11.0 == v45 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v180 = C::u64_udiv(ctx, v24, v16);
                                                        if let Some(v181) = v180 {
                                                            if v11.0 == v19.0 {
                                                                let v182 =
                                                                    C::imm64_masked(ctx, v45, v181);
                                                                let v183 = constructor_iconst(
                                                                    ctx, v45, v182,
                                                                );
                                                                let v184 = C::subsume(ctx, v183);
                                                                // Rule at src/opts/cprop.isle line 28.
                                                                returns.push(v184);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sdiv => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x1 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/arithmetic.isle line 90.
                                            returns.push(v17);
                                        }
                                    }
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        if v11.0 == v45 {
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Iconst = v22 {
                                                        let v24 = C::u64_from_imm64(ctx, v23);
                                                        let v175 = C::u64_sdiv(ctx, v24, v16);
                                                        if let Some(v176) = v175 {
                                                            if v11.0 == v19.0 {
                                                                let v177 =
                                                                    C::imm64_masked(ctx, v45, v176);
                                                                let v178 = constructor_iconst(
                                                                    ctx, v45, v177,
                                                                );
                                                                let v179 = C::subsume(ctx, v178);
                                                                // Rule at src/opts/cprop.isle line 21.
                                                                returns.push(v179);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    if let &Opcode::Band = v123 {
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        if v2.0 == v11.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v283 = constructor_band(ctx, v2.0, v125.1, v7.1);
                                                                            let v284 = constructor_band(ctx, v2.0, v125.0, v283);
                                                                            // Rule at src/opts/cprop.isle line 162.
                                                                            returns.push(v284);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v367,
                                    args: ref v368,
                                    cond: ref v369,
                                } => {
                                    if let &Opcode::Icmp = v367 {
                                        let v10 = C::inst_data_etor(ctx, v7.1);
                                        let mut v10 = v10;
                                        while let Some(v11) = v10.next(ctx) {
                                            match &v11.1 {
                                                &InstructionData::IntCompare {
                                                    opcode: ref v392,
                                                    args: ref v393,
                                                    cond: ref v394,
                                                } => {
                                                    if let &Opcode::Icmp = v392 {
                                                        let v44 = C::fits_in_64(ctx, v2.0);
                                                        if let Some(v45) = v44 {
                                                            let v398 = constructor_intcc_comparable(
                                                                ctx, v369, v394,
                                                            );
                                                            if let Some(v399) = v398 {
                                                                if v11.0 == v19.0 {
                                                                    if v11.0 == v45 {
                                                                        let v370 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v368,
                                                                            );
                                                                        let v395 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v393,
                                                                            );
                                                                        if v370.0 == v395.0 {
                                                                            if v370.1 == v395.1 {
                                                                                let v400 = constructor_decompose_intcc(ctx, v369);
                                                                                let v401 = constructor_decompose_intcc(ctx, v394);
                                                                                let v402 =
                                                                                    C::u64_and(
                                                                                        ctx, v400,
                                                                                        v401,
                                                                                    );
                                                                                let v403 = constructor_compose_icmp(ctx, v45, v402, v399, v370.0, v370.1);
                                                                                // Rule at src/opts/icmp.isle line 128.
                                                                                returns.push(v403);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } => {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            let v365 = C::ty_int(ctx, v2.0);
                                                            if let Some(v366) = v365 {
                                                                // Rule at src/opts/icmp.isle line 39.
                                                                returns.push(v7.0);
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    match v36 {
                                        &Opcode::Bnot => {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v7.1 == v37 {
                                                        if v19.0 == v47 {
                                                            let v49 = C::imm64(ctx, 0x0);
                                                            let v50 =
                                                                constructor_iconst(ctx, v47, v49);
                                                            let v51 = C::subsume(ctx, v50);
                                                            // Rule at src/opts/bitops.isle line 50.
                                                            returns.push(v51);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Uextend => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        if v16 == 0x1 {
                                                            let v365 = C::ty_int(ctx, v2.0);
                                                            if let Some(v366) = v365 {
                                                                let v373 =
                                                                    C::inst_data_etor(ctx, v37);
                                                                let mut v373 = v373;
                                                                while let Some(v374) =
                                                                    v373.next(ctx)
                                                                {
                                                                    if let &InstructionData::IntCompare {
                                                                        opcode: ref v377,
                                                                        args: ref v378,
                                                                        cond: ref v379,
                                                                    } = &v374.1 {
                                                                        if let &Opcode::Icmp = v377 {
                                                                            // Rule at src/opts/icmp.isle line 44.
                                                                            returns.push(v7.0);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        let v320 = C::value_type(ctx, v37);
                                                        let v321 = C::ty_mask(ctx, v320);
                                                        let v322 = C::u64_and(ctx, v16, v321);
                                                        let v323 = C::u64_eq(ctx, v321, v322);
                                                        if v323 == true {
                                                            // Rule at src/opts/extends.isle line 9.
                                                            returns.push(v7.0);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v14,
                                                    imm: v15,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Iconst = v14 {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        let v320 = C::value_type(ctx, v37);
                                                        let v321 = C::ty_mask(ctx, v320);
                                                        let v324 = C::u64_eq(ctx, v16, v321);
                                                        if v324 == true {
                                                            let v325 =
                                                                constructor_uextend(ctx, v2.0, v37);
                                                            // Rule at src/opts/extends.isle line 15.
                                                            returns.push(v325);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 48.
                                                returns.push(v17);
                                            }
                                            let v54 = C::i64_sextend_imm64(ctx, v2.0, v23);
                                            if v54 == -0x1 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 42.
                                                returns.push(v25);
                                            }
                                            let v253 = constructor_band(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 109.
                                            returns.push(v253);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v189 =
                                                                    C::u64_and(ctx, v24, v16);
                                                                let v190 =
                                                                    C::imm64_masked(ctx, v45, v189);
                                                                let v191 = constructor_iconst(
                                                                    ctx, v45, v190,
                                                                );
                                                                let v192 = C::subsume(ctx, v191);
                                                                // Rule at src/opts/cprop.isle line 41.
                                                                returns.push(v192);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 12.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v7.0 == v39 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v11.0 == v47 {
                                                        let v49 = C::imm64(ctx, 0x0);
                                                        let v50 = constructor_iconst(ctx, v47, v49);
                                                        let v51 = C::subsume(ctx, v50);
                                                        // Rule at src/opts/bitops.isle line 49.
                                                        returns.push(v51);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 47.
                                                returns.push(v25);
                                            }
                                            let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                            if v52 == -0x1 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 39.
                                                returns.push(v17);
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 14.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 38.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Binary {
                                    opcode: ref v123,
                                    args: ref v124,
                                } => {
                                    match v123 {
                                        &Opcode::Band => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    match &v11.1 {
                                                        &InstructionData::Unary {
                                                            opcode: ref v38,
                                                            arg: v39,
                                                        } => {
                                                            if let &Opcode::Bnot = v38 {
                                                                if v2.0 == v11.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    if v39 == v125.1 {
                                                                        let v128 = constructor_bor(
                                                                            ctx, v2.0, v125.0, v7.1,
                                                                        );
                                                                        // Rule at src/opts/bitops.isle line 64.
                                                                        returns.push(v128);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &InstructionData::UnaryImm {
                                                            opcode: ref v14,
                                                            imm: v15,
                                                        } => {
                                                            if let &Opcode::Iconst = v14 {
                                                                if v2.0 == v11.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    let v135 = C::inst_data_etor(
                                                                        ctx, v125.1,
                                                                    );
                                                                    let mut v135 = v135;
                                                                    while let Some(v136) =
                                                                        v135.next(ctx)
                                                                    {
                                                                        if let &InstructionData::UnaryImm {
                                                                            opcode: ref v139,
                                                                            imm: v140,
                                                                        } = &v136.1 {
                                                                            if let &Opcode::Iconst = v139 {
                                                                                let v142 = C::ty_mask(ctx, v2.0);
                                                                                let v16 = C::u64_from_imm64(ctx, v15);
                                                                                let v143 = C::u64_and(ctx, v142, v16);
                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                let v144 = C::u64_not(ctx, v141);
                                                                                let v145 = C::u64_and(ctx, v142, v144);
                                                                                let v146 = C::u64_eq(ctx, v143, v145);
                                                                                if v146 == true {
                                                                                    if v2.0 == v136.0 {
                                                                                        let v128 = constructor_bor(ctx, v2.0, v125.0, v7.1);
                                                                                        // Rule at src/opts/bitops.isle line 84.
                                                                                        returns.push(v128);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v19.0 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v2.0 == v11.0 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v2.0 == v136.0 {
                                                                                let v281 = constructor_bor(ctx, v2.0, v125.1, v7.1);
                                                                                let v282 = constructor_bor(ctx, v2.0, v125.0, v281);
                                                                                // Rule at src/opts/cprop.isle line 159.
                                                                                returns.push(v282);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v367,
                                    args: ref v368,
                                    cond: ref v369,
                                } => {
                                    if let &Opcode::Icmp = v367 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::IntCompare {
                                                        opcode: ref v392,
                                                        args: ref v393,
                                                        cond: ref v394,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Icmp = v392 {
                                                            let v398 = constructor_intcc_comparable(
                                                                ctx, v369, v394,
                                                            );
                                                            if let Some(v399) = v398 {
                                                                if v11.0 == v19.0 {
                                                                    let v370 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v368,
                                                                        );
                                                                    let v395 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v393,
                                                                        );
                                                                    if v370.0 == v395.0 {
                                                                        if v370.1 == v395.1 {
                                                                            let v400 = constructor_decompose_intcc(ctx, v369);
                                                                            let v401 = constructor_decompose_intcc(ctx, v394);
                                                                            let v404 = C::u64_or(
                                                                                ctx, v400, v401,
                                                                            );
                                                                            let v405 = constructor_compose_icmp(ctx, v45, v404, v399, v370.0, v370.1);
                                                                            // Rule at src/opts/icmp.isle line 132.
                                                                            returns.push(v405);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v46 = C::ty_int(ctx, v45);
                                            if let Some(v47) = v46 {
                                                if v7.1 == v37 {
                                                    if v19.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 35.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                        if v2.0 == v19.0 {
                                            let v10 = C::inst_data_etor(ctx, v7.1);
                                            let mut v10 = v10;
                                            while let Some(v11) = v10.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v129,
                                                    args: ref v130,
                                                } = &v11.1
                                                {
                                                    if let &Opcode::Band = v129 {
                                                        if v2.0 == v11.0 {
                                                            let v131 =
                                                                C::unpack_value_array_2(ctx, v130);
                                                            if v37 == v131.1 {
                                                                let v134 = constructor_bor(
                                                                    ctx, v2.0, v131.0, v7.0,
                                                                );
                                                                // Rule at src/opts/bitops.isle line 73.
                                                                returns.push(v134);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 8.
                                                returns.push(v25);
                                            }
                                            let v252 = constructor_bor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 106.
                                            returns.push(v252);
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v19.0 == v45 {
                                                let v10 = C::inst_data_etor(ctx, v7.1);
                                                let mut v10 = v10;
                                                while let Some(v11) = v10.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v14,
                                                        imm: v15,
                                                    } = &v11.1
                                                    {
                                                        if let &Opcode::Iconst = v14 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v185 = C::u64_or(ctx, v24, v16);
                                                                let v186 =
                                                                    C::imm64_masked(ctx, v45, v185);
                                                                let v187 = constructor_iconst(
                                                                    ctx, v45, v186,
                                                                );
                                                                let v188 = C::subsume(ctx, v187);
                                                                // Rule at src/opts/cprop.isle line 35.
                                                                returns.push(v188);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 16.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        if v7.0 == v39 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v11.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 34.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        let v16 = C::u64_from_imm64(ctx, v15);
                                        if v16 == 0x0 {
                                            if v2.0 == v11.0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 4.
                                                returns.push(v17);
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 18.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v17 = C::subsume(ctx, v7.0);
                            // Rule at src/opts/bitops.isle line 12.
                            returns.push(v17);
                        }
                    }
                    &Opcode::Bxor => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            match &v11.1 {
                                &InstructionData::Unary {
                                    opcode: ref v38,
                                    arg: v39,
                                } => {
                                    if let &Opcode::Bnot = v38 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v46 = C::ty_int(ctx, v45);
                                            if let Some(v47) = v46 {
                                                if v7.0 == v39 {
                                                    if v11.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 32.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v14,
                                    imm: v15,
                                } => {
                                    if let &Opcode::Iconst = v14 {
                                        if v2.0 == v11.0 {
                                            let v16 = C::u64_from_imm64(ctx, v15);
                                            if v16 == 0x0 {
                                                let v17 = C::subsume(ctx, v7.0);
                                                // Rule at src/opts/bitops.isle line 16.
                                                returns.push(v17);
                                            }
                                            let v52 = C::i64_sextend_imm64(ctx, v2.0, v15);
                                            if v52 == -0x1 {
                                                let v147 = constructor_bnot(ctx, v2.0, v7.0);
                                                // Rule at src/opts/bitops.isle line 92.
                                                returns.push(v147);
                                            }
                                            let v18 = C::inst_data_etor(ctx, v7.0);
                                            let mut v18 = v18;
                                            while let Some(v19) = v18.next(ctx) {
                                                if let &InstructionData::Binary {
                                                    opcode: ref v123,
                                                    args: ref v124,
                                                } = &v19.1
                                                {
                                                    if let &Opcode::Bxor = v123 {
                                                        if v2.0 == v19.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v2.0 == v136.0 {
                                                                            let v285 = constructor_bxor(ctx, v2.0, v125.1, v7.1);
                                                                            let v286 = constructor_bxor(ctx, v2.0, v125.0, v285);
                                                                            // Rule at src/opts/cprop.isle line 165.
                                                                            returns.push(v286);
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v11.0 == v45 {
                                                let v18 = C::inst_data_etor(ctx, v7.0);
                                                let mut v18 = v18;
                                                while let Some(v19) = v18.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v22,
                                                        imm: v23,
                                                    } = &v19.1
                                                    {
                                                        if let &Opcode::Iconst = v22 {
                                                            if v11.0 == v19.0 {
                                                                let v24 =
                                                                    C::u64_from_imm64(ctx, v23);
                                                                let v16 =
                                                                    C::u64_from_imm64(ctx, v15);
                                                                let v193 =
                                                                    C::u64_xor(ctx, v24, v16);
                                                                let v194 =
                                                                    C::imm64_masked(ctx, v45, v193);
                                                                let v195 = constructor_iconst(
                                                                    ctx, v45, v194,
                                                                );
                                                                let v196 = C::subsume(ctx, v195);
                                                                // Rule at src/opts/cprop.isle line 47.
                                                                returns.push(v196);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 22.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v18 = C::inst_data_etor(ctx, v7.0);
                        let mut v18 = v18;
                        while let Some(v19) = v18.next(ctx) {
                            match &v19.1 {
                                &InstructionData::Unary {
                                    opcode: ref v36,
                                    arg: v37,
                                } => {
                                    if let &Opcode::Bnot = v36 {
                                        if v7.1 == v37 {
                                            let v44 = C::fits_in_64(ctx, v2.0);
                                            if let Some(v45) = v44 {
                                                let v46 = C::ty_int(ctx, v45);
                                                if let Some(v47) = v46 {
                                                    if v19.0 == v47 {
                                                        let v115 = C::ty_mask(ctx, v47);
                                                        let v116 = C::imm64(ctx, v115);
                                                        let v117 =
                                                            constructor_iconst(ctx, v47, v116);
                                                        let v118 = C::subsume(ctx, v117);
                                                        // Rule at src/opts/bitops.isle line 33.
                                                        returns.push(v118);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v22,
                                    imm: v23,
                                } => {
                                    if let &Opcode::Iconst = v22 {
                                        if v2.0 == v19.0 {
                                            let v24 = C::u64_from_imm64(ctx, v23);
                                            if v24 == 0x0 {
                                                let v25 = C::subsume(ctx, v7.1);
                                                // Rule at src/opts/bitops.isle line 20.
                                                returns.push(v25);
                                            }
                                            let v254 = constructor_bxor(ctx, v2.0, v7.1, v7.0);
                                            // Rule at src/opts/cprop.isle line 112.
                                            returns.push(v254);
                                        }
                                        let v406 = C::remat(ctx, arg0);
                                        // Rule at src/opts/remat.isle line 20.
                                        returns.push(v406);
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v7.0 == v7.1 {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v49 = C::imm64(ctx, 0x0);
                                    let v50 = constructor_iconst(ctx, v47, v49);
                                    let v51 = C::subsume(ctx, v50);
                                    // Rule at src/opts/bitops.isle line 26.
                                    returns.push(v51);
                                }
                            }
                        }
                    }
                    &Opcode::Rotl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 20.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Rotr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 16.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ishl => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v44 = C::fits_in_64(ctx, v2.0);
                                    if let Some(v45) = v44 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            match &v19.1 {
                                                &InstructionData::Binary {
                                                    opcode: ref v123,
                                                    args: ref v124,
                                                } => {
                                                    match v123 {
                                                        &Opcode::Ushr => {
                                                            if v19.0 == v45 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v15 == v140 {
                                                                                let v436 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v437 = C::imm64_shl(ctx, v45, v436, v140);
                                                                                let v438 = constructor_iconst(ctx, v45, v437);
                                                                                let v439 = constructor_band(ctx, v45, v125.0, v438);
                                                                                // Rule at src/opts/shifts.isle line 27.
                                                                                returns.push(v439);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        &Opcode::Sshr => {
                                                            if v19.0 == v45 {
                                                                let v125 = C::unpack_value_array_2(
                                                                    ctx, v124,
                                                                );
                                                                let v135 =
                                                                    C::inst_data_etor(ctx, v125.1);
                                                                let mut v135 = v135;
                                                                while let Some(v136) =
                                                                    v135.next(ctx)
                                                                {
                                                                    if let &InstructionData::UnaryImm {
                                                                        opcode: ref v139,
                                                                        imm: v140,
                                                                    } = &v136.1 {
                                                                        if let &Opcode::Iconst = v139 {
                                                                            if v15 == v140 {
                                                                                let v436 = C::imm64(ctx, 0xFFFFFFFFFFFFFFFF);
                                                                                let v437 = C::imm64_shl(ctx, v45, v436, v140);
                                                                                let v438 = constructor_iconst(ctx, v45, v437);
                                                                                let v439 = constructor_band(ctx, v45, v125.0, v438);
                                                                                // Rule at src/opts/shifts.isle line 32.
                                                                                returns.push(v439);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        _ => {}
                                                    }
                                                }
                                                &InstructionData::UnaryImm {
                                                    opcode: ref v22,
                                                    imm: v23,
                                                } => {
                                                    if let &Opcode::Iconst = v22 {
                                                        if v19.0 == v45 {
                                                            let v204 =
                                                                C::imm64_shl(ctx, v45, v23, v15);
                                                            let v205 =
                                                                constructor_iconst(ctx, v45, v204);
                                                            let v206 = C::subsume(ctx, v205);
                                                            // Rule at src/opts/cprop.isle line 58.
                                                            returns.push(v206);
                                                        }
                                                    }
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 4.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v123,
                                                args: ref v124,
                                            } => {
                                                if let &Opcode::Ishl = v123 {
                                                    let v125 = C::unpack_value_array_2(ctx, v124);
                                                    let v135 = C::inst_data_etor(ctx, v125.1);
                                                    let mut v135 = v135;
                                                    while let Some(v136) = v135.next(ctx) {
                                                        if let &InstructionData::UnaryImm {
                                                            opcode: ref v139,
                                                            imm: v140,
                                                        } = &v136.1
                                                        {
                                                            if let &Opcode::Iconst = v139 {
                                                                if v15 == v140 {
                                                                    let v44 =
                                                                        C::fits_in_64(ctx, v2.0);
                                                                    if let Some(v45) = v44 {
                                                                        let v46 =
                                                                            C::ty_int(ctx, v45);
                                                                        if let Some(v47) = v46 {
                                                                            if v19.0 == v47 {
                                                                                let v115 =
                                                                                    C::ty_mask(
                                                                                        ctx, v47,
                                                                                    );
                                                                                let v116 = C::imm64(
                                                                                    ctx, v115,
                                                                                );
                                                                                let v440 =
                                                                                    C::imm64_ushr(
                                                                                        ctx, v47,
                                                                                        v116, v140,
                                                                                    );
                                                                                let v441 = constructor_iconst(ctx, v47, v440);
                                                                                let v442 = constructor_band(ctx, v47, v125.0, v441);
                                                                                // Rule at src/opts/shifts.isle line 41.
                                                                                returns.push(v442);
                                                                            }
                                                                        }
                                                                    }
                                                                    let v141 = C::u64_from_imm64(
                                                                        ctx, v140,
                                                                    );
                                                                    let v451 =
                                                                        C::u64_is_zero(ctx, v141);
                                                                    if v451 == false {
                                                                        let v150 =
                                                                            C::ty_bits(ctx, v2.0);
                                                                        let v151 =
                                                                            C::u8_as_u64(ctx, v150);
                                                                        let v452 = C::u64_sub(
                                                                            ctx, v151, v141,
                                                                        );
                                                                        let v453 = constructor_shift_amt_to_type(ctx, v452);
                                                                        if let Some(v454) = v453 {
                                                                            if v2.0 == v19.0 {
                                                                                let v455 = constructor_ireduce(ctx, v454, v125.0);
                                                                                let v457 = constructor_uextend(ctx, v2.0, v455);
                                                                                // Rule at src/opts/shifts.isle line 91.
                                                                                returns.push(v457);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v44 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v45) = v44 {
                                                        if v19.0 == v45 {
                                                            let v207 =
                                                                C::imm64_ushr(ctx, v45, v23, v15);
                                                            let v208 =
                                                                constructor_iconst(ctx, v45, v207);
                                                            let v209 = C::subsume(ctx, v208);
                                                            // Rule at src/opts/cprop.isle line 63.
                                                            returns.push(v209);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 8.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::UnaryImm {
                                opcode: ref v14,
                                imm: v15,
                            } = &v11.1
                            {
                                if let &Opcode::Iconst = v14 {
                                    let v18 = C::inst_data_etor(ctx, v7.0);
                                    let mut v18 = v18;
                                    while let Some(v19) = v18.next(ctx) {
                                        match &v19.1 {
                                            &InstructionData::Binary {
                                                opcode: ref v123,
                                                args: ref v124,
                                            } => {
                                                match v123 {
                                                    &Opcode::Bor => {
                                                        let v16 = C::u64_from_imm64(ctx, v15);
                                                        let v150 = C::ty_bits(ctx, v2.0);
                                                        let v151 = C::u8_as_u64(ctx, v150);
                                                        let v153 = C::u64_sub(ctx, v151, 0x1);
                                                        let v154 = C::u64_eq(ctx, v16, v153);
                                                        if v154 == true {
                                                            if v2.0 == v11.0 {
                                                                if v2.0 == v19.0 {
                                                                    let v125 =
                                                                        C::unpack_value_array_2(
                                                                            ctx, v124,
                                                                        );
                                                                    let v135 = C::inst_data_etor(
                                                                        ctx, v125.1,
                                                                    );
                                                                    let mut v135 = v135;
                                                                    while let Some(v136) =
                                                                        v135.next(ctx)
                                                                    {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v148,
                                                                            arg: v149,
                                                                        } = &v136.1 {
                                                                            if let &Opcode::Ineg = v148 {
                                                                                if v2.0 == v136.0 {
                                                                                    if v125.0 == v149 {
                                                                                        let v155 = constructor_bmask(ctx, v2.0, v125.0);
                                                                                        // Rule at src/opts/bitops.isle line 100.
                                                                                        returns.push(v155);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    let v156 = C::inst_data_etor(
                                                                        ctx, v125.0,
                                                                    );
                                                                    let mut v156 = v156;
                                                                    while let Some(v157) =
                                                                        v156.next(ctx)
                                                                    {
                                                                        if let &InstructionData::Unary {
                                                                            opcode: ref v160,
                                                                            arg: v161,
                                                                        } = &v157.1 {
                                                                            if let &Opcode::Ineg = v160 {
                                                                                if v125.1 == v161 {
                                                                                    if v2.0 == v157.0 {
                                                                                        let v162 = constructor_bmask(ctx, v2.0, v161);
                                                                                        // Rule at src/opts/bitops.isle line 104.
                                                                                        returns.push(v162);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    &Opcode::Ishl => {
                                                        if v2.0 == v19.0 {
                                                            let v125 =
                                                                C::unpack_value_array_2(ctx, v124);
                                                            let v135 =
                                                                C::inst_data_etor(ctx, v125.1);
                                                            let mut v135 = v135;
                                                            while let Some(v136) = v135.next(ctx) {
                                                                if let &InstructionData::UnaryImm {
                                                                    opcode: ref v139,
                                                                    imm: v140,
                                                                } = &v136.1 {
                                                                    if let &Opcode::Iconst = v139 {
                                                                        if v15 == v140 {
                                                                            let v156 = C::inst_data_etor(ctx, v125.0);
                                                                            let mut v156 = v156;
                                                                            while let Some(v157) = v156.next(ctx) {
                                                                                if let &InstructionData::Unary {
                                                                                    opcode: ref v160,
                                                                                    arg: v161,
                                                                                } = &v157.1 {
                                                                                    match v160 {
                                                                                        &Opcode::Uextend => {
                                                                                            if v2.0 == v157.0 {
                                                                                                let v141 = C::u64_from_imm64(ctx, v140);
                                                                                                let v444 = C::ty_bits_u64(ctx, v2.0);
                                                                                                let v443 = C::value_type(ctx, v161);
                                                                                                let v445 = C::ty_bits_u64(ctx, v443);
                                                                                                let v446 = C::u64_sub(ctx, v444, v445);
                                                                                                let v447 = C::u64_eq(ctx, v141, v446);
                                                                                                if v447 == true {
                                                                                                    let v448 = constructor_sextend(ctx, v2.0, v161);
                                                                                                    // Rule at src/opts/shifts.isle line 50.
                                                                                                    returns.push(v448);
                                                                                                }
                                                                                                let v449 = C::u64_lt(ctx, v141, v446);
                                                                                                if v449 == true {
                                                                                                    // Rule at src/opts/shifts.isle line 62.
                                                                                                    returns.push(v125.0);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        &Opcode::Sextend => {
                                                                                            let v141 = C::u64_from_imm64(ctx, v140);
                                                                                            let v444 = C::ty_bits_u64(ctx, v2.0);
                                                                                            let v443 = C::value_type(ctx, v161);
                                                                                            let v445 = C::ty_bits_u64(ctx, v443);
                                                                                            let v446 = C::u64_sub(ctx, v444, v445);
                                                                                            let v450 = C::u64_le(ctx, v141, v446);
                                                                                            if v450 == true {
                                                                                                if v2.0 == v157.0 {
                                                                                                    // Rule at src/opts/shifts.isle line 73.
                                                                                                    returns.push(v125.0);
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                        _ => {}
                                                                                    }
                                                                                }
                                                                            }
                                                                            let v141 = C::u64_from_imm64(ctx, v140);
                                                                            let v451 = C::u64_is_zero(ctx, v141);
                                                                            if v451 == false {
                                                                                let v150 = C::ty_bits(ctx, v2.0);
                                                                                let v151 = C::u8_as_u64(ctx, v150);
                                                                                let v452 = C::u64_sub(ctx, v151, v141);
                                                                                let v453 = constructor_shift_amt_to_type(ctx, v452);
                                                                                if let Some(v454) = v453 {
                                                                                    let v455 = constructor_ireduce(ctx, v454, v125.0);
                                                                                    let v456 = constructor_sextend(ctx, v2.0, v455);
                                                                                    // Rule at src/opts/shifts.isle line 87.
                                                                                    returns.push(v456);
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    _ => {}
                                                }
                                            }
                                            &InstructionData::UnaryImm {
                                                opcode: ref v22,
                                                imm: v23,
                                            } => {
                                                if let &Opcode::Iconst = v22 {
                                                    let v44 = C::fits_in_64(ctx, v2.0);
                                                    if let Some(v45) = v44 {
                                                        if v19.0 == v45 {
                                                            let v210 =
                                                                C::imm64_sshr(ctx, v45, v23, v15);
                                                            let v211 =
                                                                constructor_iconst(ctx, v45, v210);
                                                            let v212 = C::subsume(ctx, v211);
                                                            // Rule at src/opts/cprop.isle line 68.
                                                            returns.push(v212);
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                    let v16 = C::u64_from_imm64(ctx, v15);
                                    if v16 == 0x0 {
                                        if v2.0 == v11.0 {
                                            let v17 = C::subsume(ctx, v7.0);
                                            // Rule at src/opts/shifts.isle line 12.
                                            returns.push(v17);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Fmul => {
                        let v7 = C::unpack_value_array_2(ctx, v6);
                        let v10 = C::inst_data_etor(ctx, v7.1);
                        let mut v10 = v10;
                        while let Some(v11) = v10.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v38,
                                arg: v39,
                            } = &v11.1
                            {
                                if let &Opcode::Fneg = v38 {
                                    if v2.0 == v11.0 {
                                        let v18 = C::inst_data_etor(ctx, v7.0);
                                        let mut v18 = v18;
                                        while let Some(v19) = v18.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v36,
                                                arg: v37,
                                            } = &v19.1
                                            {
                                                if let &Opcode::Fneg = v36 {
                                                    if v2.0 == v19.0 {
                                                        let v114 =
                                                            constructor_fmul(ctx, v2.0, v37, v39);
                                                        // Rule at src/opts/arithmetic.isle line 127.
                                                        returns.push(v114);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::IntCompare {
                opcode: ref v227,
                args: ref v228,
                cond: ref v229,
            } => {
                if let &Opcode::Icmp = v227 {
                    match v229 {
                        &IntCC::Equal => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    if v230.0 == v230.1 {
                                        let v331 = C::imm64(ctx, 0x1);
                                        let v339 = constructor_iconst(ctx, v47, v331);
                                        // Rule at src/opts/icmp.isle line 5.
                                        returns.push(v339);
                                    }
                                }
                            }
                            let v230 = C::unpack_value_array_2(ctx, v228);
                            let v233 = C::inst_data_etor(ctx, v230.0);
                            let mut v233 = v233;
                            while let Some(v234) = v233.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v326,
                                    arg: v327,
                                } = &v234.1
                                {
                                    if let &Opcode::Uextend = v326 {
                                        let v239 = C::inst_data_etor(ctx, v230.1);
                                        let mut v239 = v239;
                                        while let Some(v240) = v239.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v243,
                                                imm: v244,
                                            } = &v240.1
                                            {
                                                if let &Opcode::Iconst = v243 {
                                                    let v329 = C::u64_from_imm64(ctx, v244);
                                                    if v329 == 0x0 {
                                                        let v340 = C::inst_data_etor(ctx, v327);
                                                        let mut v340 = v340;
                                                        while let Some(v341) = v340.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v344,
                                                                args: ref v345,
                                                                cond: ref v346,
                                                            } = &v341.1
                                                            {
                                                                if let &Opcode::Icmp = v344 {
                                                                    if v2.0 == v341.0 {
                                                                        let v351 =
                                                                            &C::intcc_inverse(
                                                                                ctx, v346,
                                                                            );
                                                                        let v347 =
                                                                            C::unpack_value_array_2(
                                                                                ctx, v345,
                                                                            );
                                                                        let v352 = constructor_icmp(
                                                                            ctx, v2.0, v351,
                                                                            v347.0, v347.1,
                                                                        );
                                                                        let v353 =
                                                                            C::subsume(ctx, v352);
                                                                        // Rule at src/opts/icmp.isle line 22.
                                                                        returns.push(v353);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::NotEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    if v230.0 == v230.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 6.
                                        returns.push(v50);
                                    }
                                }
                            }
                            let v230 = C::unpack_value_array_2(ctx, v228);
                            let v233 = C::inst_data_etor(ctx, v230.0);
                            let mut v233 = v233;
                            while let Some(v234) = v233.next(ctx) {
                                if let &InstructionData::Unary {
                                    opcode: ref v326,
                                    arg: v327,
                                } = &v234.1
                                {
                                    if let &Opcode::Uextend = v326 {
                                        let v239 = C::inst_data_etor(ctx, v230.1);
                                        let mut v239 = v239;
                                        while let Some(v240) = v239.next(ctx) {
                                            if let &InstructionData::UnaryImm {
                                                opcode: ref v243,
                                                imm: v244,
                                            } = &v240.1
                                            {
                                                if let &Opcode::Iconst = v243 {
                                                    let v329 = C::u64_from_imm64(ctx, v244);
                                                    if v329 == 0x0 {
                                                        let v340 = C::inst_data_etor(ctx, v327);
                                                        let mut v340 = v340;
                                                        while let Some(v341) = v340.next(ctx) {
                                                            if let &InstructionData::IntCompare {
                                                                opcode: ref v344,
                                                                args: ref v345,
                                                                cond: ref v346,
                                                            } = &v341.1
                                                            {
                                                                if let &Opcode::Icmp = v344 {
                                                                    if v2.0 == v341.0 {
                                                                        let v350 =
                                                                            C::subsume(ctx, v327);
                                                                        // Rule at src/opts/icmp.isle line 17.
                                                                        returns.push(v350);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                let v388 = C::ty_smin(ctx, v240.0);
                                                let v389 = C::u64_eq(ctx, v329, v388);
                                                if v389 == true {
                                                    let v384 =
                                                        constructor_ne(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 98.
                                                    returns.push(v384);
                                                }
                                                let v390 = C::ty_smax(ctx, v240.0);
                                                let v391 = C::u64_eq(ctx, v329, v390);
                                                if v391 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 118.
                                                    returns.push(v51);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 9.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::SignedGreaterThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                let v388 = C::ty_smin(ctx, v240.0);
                                                let v389 = C::u64_eq(ctx, v329, v388);
                                                if v389 == true {
                                                    let v331 = C::imm64(ctx, 0x1);
                                                    let v339 = constructor_iconst(ctx, v47, v331);
                                                    let v385 = C::subsume(ctx, v339);
                                                    // Rule at src/opts/icmp.isle line 103.
                                                    returns.push(v385);
                                                }
                                                let v390 = C::ty_smax(ctx, v240.0);
                                                let v391 = C::u64_eq(ctx, v329, v390);
                                                if v391 == true {
                                                    let v383 =
                                                        constructor_eq(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 123.
                                                    returns.push(v383);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v331 = C::imm64(ctx, 0x1);
                                        let v339 = constructor_iconst(ctx, v47, v331);
                                        // Rule at src/opts/icmp.isle line 10.
                                        returns.push(v339);
                                    }
                                }
                            }
                            let v230 = C::unpack_value_array_2(ctx, v228);
                            let v233 = C::inst_data_etor(ctx, v230.0);
                            let mut v233 = v233;
                            while let Some(v234) = v233.next(ctx) {
                                if v234.0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref v326,
                                        arg: v327,
                                    } = &v234.1
                                    {
                                        if let &Opcode::Uextend = v326 {
                                            let v328 = C::value_type(ctx, v327);
                                            if v328 == I32 {
                                                let v239 = C::inst_data_etor(ctx, v230.1);
                                                let mut v239 = v239;
                                                while let Some(v240) = v239.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v243,
                                                        imm: v244,
                                                    } = &v240.1
                                                    {
                                                        if let &Opcode::Iconst = v243 {
                                                            let v329 = C::u64_from_imm64(ctx, v244);
                                                            if v329 == 0x0 {
                                                                let v331 = C::imm64(ctx, 0x1);
                                                                let v332 = constructor_iconst(
                                                                    ctx, v2.0, v331,
                                                                );
                                                                // Rule at src/opts/extends.isle line 25.
                                                                returns.push(v332);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                let v388 = C::ty_smin(ctx, v240.0);
                                                let v389 = C::u64_eq(ctx, v329, v388);
                                                if v389 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 88.
                                                    returns.push(v51);
                                                }
                                                let v390 = C::ty_smax(ctx, v240.0);
                                                let v391 = C::u64_eq(ctx, v329, v390);
                                                if v391 == true {
                                                    let v384 =
                                                        constructor_ne(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 108.
                                                    returns.push(v384);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 13.
                                        returns.push(v50);
                                    }
                                }
                            }
                            let v230 = C::unpack_value_array_2(ctx, v228);
                            let v233 = C::inst_data_etor(ctx, v230.0);
                            let mut v233 = v233;
                            while let Some(v234) = v233.next(ctx) {
                                if v234.0 == I64 {
                                    if let &InstructionData::Unary {
                                        opcode: ref v326,
                                        arg: v327,
                                    } = &v234.1
                                    {
                                        if let &Opcode::Uextend = v326 {
                                            let v328 = C::value_type(ctx, v327);
                                            if v328 == I32 {
                                                let v239 = C::inst_data_etor(ctx, v230.1);
                                                let mut v239 = v239;
                                                while let Some(v240) = v239.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v243,
                                                        imm: v244,
                                                    } = &v240.1
                                                    {
                                                        if let &Opcode::Iconst = v243 {
                                                            let v329 = C::u64_from_imm64(ctx, v244);
                                                            if v329 == 0x0 {
                                                                let v49 = C::imm64(ctx, 0x0);
                                                                let v330 = constructor_iconst(
                                                                    ctx, v2.0, v49,
                                                                );
                                                                // Rule at src/opts/extends.isle line 20.
                                                                returns.push(v330);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        &IntCC::SignedLessThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                let v388 = C::ty_smin(ctx, v240.0);
                                                let v389 = C::u64_eq(ctx, v329, v388);
                                                if v389 == true {
                                                    let v383 =
                                                        constructor_eq(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 93.
                                                    returns.push(v383);
                                                }
                                                let v390 = C::ty_smax(ctx, v240.0);
                                                let v391 = C::u64_eq(ctx, v329, v390);
                                                if v391 == true {
                                                    let v331 = C::imm64(ctx, 0x1);
                                                    let v339 = constructor_iconst(ctx, v47, v331);
                                                    let v385 = C::subsume(ctx, v339);
                                                    // Rule at src/opts/icmp.isle line 113.
                                                    returns.push(v385);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v331 = C::imm64(ctx, 0x1);
                                        let v339 = constructor_iconst(ctx, v47, v331);
                                        // Rule at src/opts/icmp.isle line 14.
                                        returns.push(v339);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                if v329 == 0x0 {
                                                    let v384 =
                                                        constructor_ne(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 60.
                                                    returns.push(v384);
                                                }
                                                let v386 = C::ty_umax(ctx, v240.0);
                                                let v387 = C::u64_eq(ctx, v329, v386);
                                                if v387 == true {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 78.
                                                    returns.push(v51);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 7.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedGreaterThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                if v329 == 0x0 {
                                                    let v331 = C::imm64(ctx, 0x1);
                                                    let v339 = constructor_iconst(ctx, v47, v331);
                                                    let v385 = C::subsume(ctx, v339);
                                                    // Rule at src/opts/icmp.isle line 64.
                                                    returns.push(v385);
                                                }
                                                let v386 = C::ty_umax(ctx, v240.0);
                                                let v387 = C::u64_eq(ctx, v329, v386);
                                                if v387 == true {
                                                    let v383 =
                                                        constructor_eq(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 83.
                                                    returns.push(v383);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v331 = C::imm64(ctx, 0x1);
                                        let v339 = constructor_iconst(ctx, v47, v331);
                                        // Rule at src/opts/icmp.isle line 8.
                                        returns.push(v339);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThan => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                if v329 == 0x0 {
                                                    let v49 = C::imm64(ctx, 0x0);
                                                    let v50 = constructor_iconst(ctx, v47, v49);
                                                    let v51 = C::subsume(ctx, v50);
                                                    // Rule at src/opts/icmp.isle line 52.
                                                    returns.push(v51);
                                                }
                                                let v386 = C::ty_umax(ctx, v240.0);
                                                let v387 = C::u64_eq(ctx, v329, v386);
                                                if v387 == true {
                                                    let v384 =
                                                        constructor_ne(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 68.
                                                    returns.push(v384);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v49 = C::imm64(ctx, 0x0);
                                        let v50 = constructor_iconst(ctx, v47, v49);
                                        // Rule at src/opts/icmp.isle line 11.
                                        returns.push(v50);
                                    }
                                }
                            }
                        }
                        &IntCC::UnsignedLessThanOrEqual => {
                            let v44 = C::fits_in_64(ctx, v2.0);
                            if let Some(v45) = v44 {
                                let v46 = C::ty_int(ctx, v45);
                                if let Some(v47) = v46 {
                                    let v230 = C::unpack_value_array_2(ctx, v228);
                                    let v239 = C::inst_data_etor(ctx, v230.1);
                                    let mut v239 = v239;
                                    while let Some(v240) = v239.next(ctx) {
                                        if let &InstructionData::UnaryImm {
                                            opcode: ref v243,
                                            imm: v244,
                                        } = &v240.1
                                        {
                                            if let &Opcode::Iconst = v243 {
                                                let v329 = C::u64_from_imm64(ctx, v244);
                                                if v329 == 0x0 {
                                                    let v383 =
                                                        constructor_eq(ctx, v47, v230.0, v230.1);
                                                    // Rule at src/opts/icmp.isle line 56.
                                                    returns.push(v383);
                                                }
                                                let v386 = C::ty_umax(ctx, v240.0);
                                                let v387 = C::u64_eq(ctx, v329, v386);
                                                if v387 == true {
                                                    let v331 = C::imm64(ctx, 0x1);
                                                    let v339 = constructor_iconst(ctx, v47, v331);
                                                    let v385 = C::subsume(ctx, v339);
                                                    // Rule at src/opts/icmp.isle line 73.
                                                    returns.push(v385);
                                                }
                                            }
                                        }
                                    }
                                    if v230.0 == v230.1 {
                                        let v331 = C::imm64(ctx, 0x1);
                                        let v339 = constructor_iconst(ctx, v47, v331);
                                        // Rule at src/opts/icmp.isle line 12.
                                        returns.push(v339);
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                    let v230 = C::unpack_value_array_2(ctx, v228);
                    let v233 = C::inst_data_etor(ctx, v230.0);
                    let mut v233 = v233;
                    while let Some(v234) = v233.next(ctx) {
                        if let &InstructionData::UnaryImm {
                            opcode: ref v237,
                            imm: v238,
                        } = &v234.1
                        {
                            if let &Opcode::Iconst = v237 {
                                let v239 = C::inst_data_etor(ctx, v230.1);
                                let mut v239 = v239;
                                while let Some(v240) = v239.next(ctx) {
                                    if let &InstructionData::UnaryImm {
                                        opcode: ref v243,
                                        imm: v244,
                                    } = &v240.1
                                    {
                                        if let &Opcode::Iconst = v243 {
                                            if v234.0 == v240.0 {
                                                let v245 =
                                                    C::imm64_icmp(ctx, v234.0, v229, v238, v244);
                                                let v246 = constructor_iconst(ctx, v2.0, v245);
                                                let v247 = C::subsume(ctx, v246);
                                                // Rule at src/opts/cprop.isle line 82.
                                                returns.push(v247);
                                            }
                                        }
                                    }
                                }
                                let v255 = &C::intcc_reverse(ctx, v229);
                                let v256 = constructor_icmp(ctx, v2.0, v255, v230.1, v230.0);
                                // Rule at src/opts/cprop.isle line 116.
                                returns.push(v256);
                            }
                        }
                    }
                }
            }
            &InstructionData::Ternary {
                opcode: ref v95,
                args: ref v96,
            } => {
                match v95 {
                    &Opcode::Select => {
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        let v101 = C::inst_data_etor(ctx, v97.0);
                        let mut v101 = v101;
                        while let Some(v102) = v101.next(ctx) {
                            match &v102.1 {
                                &InstructionData::FloatCompare {
                                    opcode: ref v427,
                                    args: ref v428,
                                    cond: ref v429,
                                } => {
                                    if let &Opcode::Fcmp = v427 {
                                        match v429 {
                                            &FloatCC::GreaterThan => {
                                                let v430 = C::unpack_value_array_2(ctx, v428);
                                                if v97.1 == v430.0 {
                                                    if v97.2 == v430.1 {
                                                        let v434 = constructor_fmax_pseudo(
                                                            ctx, v2.0, v430.0, v430.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 57.
                                                        returns.push(v434);
                                                    }
                                                }
                                            }
                                            &FloatCC::LessThan => {
                                                let v430 = C::unpack_value_array_2(ctx, v428);
                                                if v97.1 == v430.0 {
                                                    if v97.2 == v430.1 {
                                                        let v433 = constructor_fmin_pseudo(
                                                            ctx, v2.0, v430.0, v430.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 54.
                                                        returns.push(v433);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::IntCompare {
                                    opcode: ref v413,
                                    args: ref v414,
                                    cond: ref v415,
                                } => {
                                    if let &Opcode::Icmp = v413 {
                                        match v415 {
                                            &IntCC::SignedGreaterThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 8.
                                                        returns.push(v419);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 22.
                                                        returns.push(v421);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 9.
                                                        returns.push(v419);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 23.
                                                        returns.push(v421);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 12.
                                                        returns.push(v421);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 18.
                                                        returns.push(v419);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 13.
                                                        returns.push(v421);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 19.
                                                        returns.push(v419);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 10.
                                                        returns.push(v420);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 24.
                                                        returns.push(v422);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 11.
                                                        returns.push(v420);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 25.
                                                        returns.push(v422);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 14.
                                                        returns.push(v422);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 20.
                                                        returns.push(v420);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 15.
                                                        returns.push(v422);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 21.
                                                        returns.push(v420);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v105,
                                    arg: v106,
                                } => {
                                    if let &Opcode::Uextend = v105 {
                                        let v354 = C::inst_data_etor(ctx, v106);
                                        let mut v354 = v354;
                                        while let Some(v355) = v354.next(ctx) {
                                            if let &InstructionData::IntCompare {
                                                opcode: ref v358,
                                                args: ref v359,
                                                cond: ref v360,
                                            } = &v355.1
                                            {
                                                if let &Opcode::Icmp = v358 {
                                                    let v364 = constructor_select(
                                                        ctx, v2.0, v106, v97.1, v97.2,
                                                    );
                                                    // Rule at src/opts/icmp.isle line 29.
                                                    returns.push(v364);
                                                    // Rule at src/opts/icmp.isle line 32.
                                                    returns.push(v364);
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v287,
                                    imm: v288,
                                } => {
                                    if let &Opcode::Iconst = v287 {
                                        let v289 = C::u64_from_imm64(ctx, v288);
                                        if v289 == 0x0 {
                                            // Rule at src/opts/cprop.isle line 172.
                                            returns.push(v97.2);
                                        }
                                        let v290 = C::u64_is_zero(ctx, v289);
                                        if v290 == false {
                                            // Rule at src/opts/cprop.isle line 169.
                                            returns.push(v97.1);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if v97.1 == v97.2 {
                            // Rule at src/opts/selects.isle line 4.
                            returns.push(v97.1);
                        }
                    }
                    &Opcode::Bitselect => {
                        let v423 = C::multi_lane(ctx, v2.0);
                        if let Some(v424) = v423 {
                            let v97 = C::unpack_value_array_3(ctx, v96);
                            let v101 = C::inst_data_etor(ctx, v97.0);
                            let mut v101 = v101;
                            while let Some(v102) = v101.next(ctx) {
                                if let &InstructionData::IntCompare {
                                    opcode: ref v413,
                                    args: ref v414,
                                    cond: ref v415,
                                } = &v102.1
                                {
                                    if let &Opcode::Icmp = v413 {
                                        match v415 {
                                            &IntCC::SignedGreaterThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 28.
                                                        returns.push(v419);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 42.
                                                        returns.push(v421);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedGreaterThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 29.
                                                        returns.push(v419);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 43.
                                                        returns.push(v421);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 32.
                                                        returns.push(v421);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 38.
                                                        returns.push(v419);
                                                    }
                                                }
                                            }
                                            &IntCC::SignedLessThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v421 = constructor_smin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 33.
                                                        returns.push(v421);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v419 = constructor_smax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 39.
                                                        returns.push(v419);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 30.
                                                        returns.push(v420);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 44.
                                                        returns.push(v422);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedGreaterThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 31.
                                                        returns.push(v420);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 45.
                                                        returns.push(v422);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThan => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 34.
                                                        returns.push(v422);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 40.
                                                        returns.push(v420);
                                                    }
                                                }
                                            }
                                            &IntCC::UnsignedLessThanOrEqual => {
                                                let v416 = C::unpack_value_array_2(ctx, v414);
                                                if v97.1 == v416.0 {
                                                    if v97.2 == v416.1 {
                                                        let v422 = constructor_umin(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 35.
                                                        returns.push(v422);
                                                    }
                                                }
                                                if v97.1 == v416.1 {
                                                    if v97.2 == v416.0 {
                                                        let v420 = constructor_umax(
                                                            ctx, v2.0, v416.0, v416.1,
                                                        );
                                                        // Rule at src/opts/selects.isle line 41.
                                                        returns.push(v420);
                                                    }
                                                }
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                            }
                        }
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        if v97.1 == v97.2 {
                            // Rule at src/opts/selects.isle line 5.
                            returns.push(v97.1);
                        }
                    }
                    &Opcode::Fma => {
                        let v97 = C::unpack_value_array_3(ctx, v96);
                        let v101 = C::inst_data_etor(ctx, v97.0);
                        let mut v101 = v101;
                        while let Some(v102) = v101.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v105,
                                arg: v106,
                            } = &v102.1
                            {
                                if let &Opcode::Fneg = v105 {
                                    if v2.0 == v102.0 {
                                        let v107 = C::inst_data_etor(ctx, v97.1);
                                        let mut v107 = v107;
                                        while let Some(v108) = v107.next(ctx) {
                                            if let &InstructionData::Unary {
                                                opcode: ref v111,
                                                arg: v112,
                                            } = &v108.1
                                            {
                                                if let &Opcode::Fneg = v111 {
                                                    if v2.0 == v108.0 {
                                                        let v113 = constructor_fma(
                                                            ctx, v2.0, v106, v112, v97.2,
                                                        );
                                                        // Rule at src/opts/arithmetic.isle line 122.
                                                        returns.push(v113);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::Unary {
                opcode: ref v27,
                arg: v28,
            } => {
                match v27 {
                    &Opcode::Splat => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::UnaryIeee32 {
                                    opcode: ref v307,
                                    imm: v308,
                                } => {
                                    if let &Opcode::F32const = v307 {
                                        let v309 = C::u32_from_ieee32(ctx, v308);
                                        let v310 = C::u32_as_u64(ctx, v309);
                                        let v311 = constructor_splat32(ctx, v310);
                                        let v312 = constructor_vconst(ctx, v2.0, v311);
                                        // Rule at src/opts/cprop.isle line 188.
                                        returns.push(v312);
                                    }
                                }
                                &InstructionData::UnaryIeee64 {
                                    opcode: ref v313,
                                    imm: v314,
                                } => {
                                    if let &Opcode::F64const = v313 {
                                        let v315 = C::u64_from_ieee64(ctx, v314);
                                        let v316 = C::splat64(ctx, v315);
                                        let v317 = constructor_vconst(ctx, v2.0, v316);
                                        // Rule at src/opts/cprop.isle line 190.
                                        returns.push(v317);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        match v30.0 {
                                            I8 => {
                                                let v292 = C::u64_uextend_imm64(ctx, I8, v198);
                                                let v293 = constructor_splat8(ctx, v292);
                                                let v294 = constructor_vconst(ctx, v2.0, v293);
                                                // Rule at src/opts/cprop.isle line 180.
                                                returns.push(v294);
                                            }
                                            I16 => {
                                                let v296 = C::u64_uextend_imm64(ctx, I16, v198);
                                                let v297 = constructor_splat16(ctx, v296);
                                                let v298 = constructor_vconst(ctx, v2.0, v297);
                                                // Rule at src/opts/cprop.isle line 182.
                                                returns.push(v298);
                                            }
                                            I32 => {
                                                let v300 = C::u64_uextend_imm64(ctx, I32, v198);
                                                let v301 = constructor_splat32(ctx, v300);
                                                let v302 = constructor_vconst(ctx, v2.0, v301);
                                                // Rule at src/opts/cprop.isle line 184.
                                                returns.push(v302);
                                            }
                                            I64 => {
                                                let v304 = C::u64_uextend_imm64(ctx, I64, v198);
                                                let v305 = C::splat64(ctx, v304);
                                                let v306 = constructor_vconst(ctx, v2.0, v305);
                                                // Rule at src/opts/cprop.isle line 186.
                                                returns.push(v306);
                                            }
                                            _ => {}
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Ineg => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Binary {
                                    opcode: ref v57,
                                    args: ref v58,
                                } => {
                                    if let &Opcode::Ushr = v57 {
                                        if v2.0 == v30.0 {
                                            let v59 = C::unpack_value_array_2(ctx, v58);
                                            let v62 = C::inst_data_etor(ctx, v59.1);
                                            let mut v62 = v62;
                                            while let Some(v63) = v62.next(ctx) {
                                                if let &InstructionData::UnaryImm {
                                                    opcode: ref v66,
                                                    imm: v67,
                                                } = &v63.1
                                                {
                                                    if let &Opcode::Iconst = v66 {
                                                        let v68 = C::u64_from_imm64(ctx, v67);
                                                        let v150 = C::ty_bits(ctx, v2.0);
                                                        let v151 = C::u8_as_u64(ctx, v150);
                                                        let v153 = C::u64_sub(ctx, v151, 0x1);
                                                        let v458 = C::u64_eq(ctx, v68, v153);
                                                        if v458 == true {
                                                            if v2.0 == v63.0 {
                                                                let v459 = constructor_sshr(
                                                                    ctx, v2.0, v59.0, v59.1,
                                                                );
                                                                // Rule at src/opts/shifts.isle line 102.
                                                                returns.push(v459);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Ineg = v33 {
                                        if v2.0 == v30.0 {
                                            let v35 = C::subsume(ctx, v34);
                                            // Rule at src/opts/arithmetic.isle line 25.
                                            returns.push(v35);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Iabs => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                match v33 {
                                    &Opcode::Ineg => {
                                        if v2.0 == v30.0 {
                                            let v42 = constructor_iabs(ctx, v2.0, v34);
                                            // Rule at src/opts/arithmetic.isle line 32.
                                            returns.push(v42);
                                        }
                                    }
                                    &Opcode::Iabs => {
                                        if v2.0 == v30.0 {
                                            let v43 = C::subsume(ctx, v28);
                                            // Rule at src/opts/arithmetic.isle line 36.
                                            returns.push(v43);
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }
                    &Opcode::Bnot => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Binary {
                                    opcode: ref v57,
                                    args: ref v58,
                                } => {
                                    match v57 {
                                        &Opcode::Iadd => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v62 = C::inst_data_etor(ctx, v59.1);
                                                let mut v62 = v62;
                                                while let Some(v63) = v62.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v66,
                                                        imm: v67,
                                                    } = &v63.1
                                                    {
                                                        if let &Opcode::Iconst = v66 {
                                                            let v70 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v67,
                                                            );
                                                            if v70 == -0x1 {
                                                                if v2.0 == v63.0 {
                                                                    let v69 = constructor_ineg(
                                                                        ctx, v2.0, v59.0,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 82.
                                                                    returns.push(v69);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                let v71 = C::inst_data_etor(ctx, v59.0);
                                                let mut v71 = v71;
                                                while let Some(v72) = v71.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v75,
                                                        imm: v76,
                                                    } = &v72.1
                                                    {
                                                        if let &Opcode::Iconst = v75 {
                                                            let v77 = C::i64_sextend_imm64(
                                                                ctx, v2.0, v76,
                                                            );
                                                            if v77 == -0x1 {
                                                                if v2.0 == v72.0 {
                                                                    let v78 = constructor_ineg(
                                                                        ctx, v2.0, v59.1,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 85.
                                                                    returns.push(v78);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Isub => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v62 = C::inst_data_etor(ctx, v59.1);
                                                let mut v62 = v62;
                                                while let Some(v63) = v62.next(ctx) {
                                                    if let &InstructionData::UnaryImm {
                                                        opcode: ref v66,
                                                        imm: v67,
                                                    } = &v63.1
                                                    {
                                                        if let &Opcode::Iconst = v66 {
                                                            let v68 = C::u64_from_imm64(ctx, v67);
                                                            if v68 == 0x1 {
                                                                if v2.0 == v63.0 {
                                                                    let v69 = constructor_ineg(
                                                                        ctx, v2.0, v59.0,
                                                                    );
                                                                    // Rule at src/opts/arithmetic.isle line 80.
                                                                    returns.push(v69);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        &Opcode::Band => {
                                            let v59 = C::unpack_value_array_2(ctx, v58);
                                            let v119 = constructor_bnot(ctx, v2.0, v59.0);
                                            let v120 = constructor_bnot(ctx, v2.0, v59.1);
                                            let v122 = constructor_bor(ctx, v2.0, v119, v120);
                                            // Rule at src/opts/bitops.isle line 60.
                                            returns.push(v122);
                                        }
                                        &Opcode::Bor => {
                                            if v2.0 == v30.0 {
                                                let v59 = C::unpack_value_array_2(ctx, v58);
                                                let v119 = constructor_bnot(ctx, v2.0, v59.0);
                                                let v120 = constructor_bnot(ctx, v2.0, v59.1);
                                                let v121 = constructor_band(ctx, v2.0, v119, v120);
                                                // Rule at src/opts/bitops.isle line 57.
                                                returns.push(v121);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Bnot = v33 {
                                        if v2.0 == v30.0 {
                                            let v35 = C::subsume(ctx, v34);
                                            // Rule at src/opts/bitops.isle line 53.
                                            returns.push(v35);
                                        }
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            if v30.0 == v45 {
                                                let v199 = C::u64_from_imm64(ctx, v198);
                                                let v200 = C::u64_not(ctx, v199);
                                                let v201 = C::imm64_masked(ctx, v45, v200);
                                                let v202 = constructor_iconst(ctx, v45, v201);
                                                let v203 = C::subsume(ctx, v202);
                                                // Rule at src/opts/cprop.isle line 53.
                                                returns.push(v203);
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        let v406 = C::remat(ctx, arg0);
                        // Rule at src/opts/remat.isle line 24.
                        returns.push(v406);
                    }
                    &Opcode::Fneg => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Fneg = v33 {
                                    if v2.0 == v30.0 {
                                        let v35 = C::subsume(ctx, v34);
                                        // Rule at src/opts/arithmetic.isle line 118.
                                        returns.push(v35);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ireduce => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    match v33 {
                                        &Opcode::Uextend => {
                                            let v333 = C::value_type(ctx, v34);
                                            if v2.0 == v333 {
                                                // Rule at src/opts/extends.isle line 34.
                                                returns.push(v34);
                                            }
                                        }
                                        &Opcode::Sextend => {
                                            let v333 = C::value_type(ctx, v34);
                                            if v2.0 == v333 {
                                                // Rule at src/opts/extends.isle line 33.
                                                returns.push(v34);
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v213 = C::fits_in_64(ctx, v30.0);
                                        if let Some(v214) = v213 {
                                            let v199 = C::u64_from_imm64(ctx, v198);
                                            let v215 = C::imm64_masked(ctx, v2.0, v199);
                                            let v216 = constructor_iconst(ctx, v2.0, v215);
                                            let v217 = C::subsume(ctx, v216);
                                            // Rule at src/opts/cprop.isle line 73.
                                            returns.push(v217);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::SwidenLow => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v334 = C::lane_type(ctx, v2.0);
                                    let v335 = constructor_sextend(ctx, v334, v34);
                                    let v336 = constructor_splat(ctx, v2.0, v335);
                                    // Rule at src/opts/extends.isle line 38.
                                    returns.push(v336);
                                }
                            }
                        }
                    }
                    &Opcode::SwidenHigh => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v334 = C::lane_type(ctx, v2.0);
                                    let v335 = constructor_sextend(ctx, v334, v34);
                                    let v336 = constructor_splat(ctx, v2.0, v335);
                                    // Rule at src/opts/extends.isle line 37.
                                    returns.push(v336);
                                }
                            }
                        }
                    }
                    &Opcode::UwidenLow => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v334 = C::lane_type(ctx, v2.0);
                                    let v337 = constructor_uextend(ctx, v334, v34);
                                    let v338 = constructor_splat(ctx, v2.0, v337);
                                    // Rule at src/opts/extends.isle line 41.
                                    returns.push(v338);
                                }
                            }
                        }
                    }
                    &Opcode::UwidenHigh => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v334 = C::lane_type(ctx, v2.0);
                                    let v337 = constructor_uextend(ctx, v334, v34);
                                    let v338 = constructor_splat(ctx, v2.0, v337);
                                    // Rule at src/opts/extends.isle line 40.
                                    returns.push(v338);
                                }
                            }
                        }
                    }
                    &Opcode::Uextend => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Uextend = v33 {
                                        let v318 = constructor_uextend(ctx, v2.0, v34);
                                        // Rule at src/opts/extends.isle line 2.
                                        returns.push(v318);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v218 = C::u64_uextend_imm64(ctx, v30.0, v198);
                                            let v219 = C::imm64(ctx, v218);
                                            let v220 = constructor_iconst(ctx, v45, v219);
                                            let v221 = C::subsume(ctx, v220);
                                            // Rule at src/opts/cprop.isle line 76.
                                            returns.push(v221);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::Sextend => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            match &v30.1 {
                                &InstructionData::Unary {
                                    opcode: ref v33,
                                    arg: v34,
                                } => {
                                    if let &Opcode::Sextend = v33 {
                                        let v319 = constructor_sextend(ctx, v2.0, v34);
                                        // Rule at src/opts/extends.isle line 4.
                                        returns.push(v319);
                                    }
                                }
                                &InstructionData::UnaryImm {
                                    opcode: ref v197,
                                    imm: v198,
                                } => {
                                    if let &Opcode::Iconst = v197 {
                                        let v44 = C::fits_in_64(ctx, v2.0);
                                        if let Some(v45) = v44 {
                                            let v222 = C::i64_sextend_imm64(ctx, v30.0, v198);
                                            let v223 = C::i64_as_u64(ctx, v222);
                                            let v224 = C::imm64_masked(ctx, v45, v223);
                                            let v225 = constructor_iconst(ctx, v45, v224);
                                            let v226 = C::subsume(ctx, v225);
                                            // Rule at src/opts/cprop.isle line 79.
                                            returns.push(v226);
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    &Opcode::FcvtFromUint => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v334 = C::lane_type(ctx, v2.0);
                                    let v460 = constructor_fcvt_from_uint(ctx, v334, v34);
                                    let v461 = constructor_splat(ctx, v2.0, v460);
                                    // Rule at src/opts/vector.isle line 5.
                                    returns.push(v461);
                                }
                            }
                        }
                    }
                    &Opcode::FcvtFromSint => {
                        let v29 = C::inst_data_etor(ctx, v28);
                        let mut v29 = v29;
                        while let Some(v30) = v29.next(ctx) {
                            if let &InstructionData::Unary {
                                opcode: ref v33,
                                arg: v34,
                            } = &v30.1
                            {
                                if let &Opcode::Splat = v33 {
                                    let v334 = C::lane_type(ctx, v2.0);
                                    let v462 = constructor_fcvt_from_sint(ctx, v334, v34);
                                    let v463 = constructor_splat(ctx, v2.0, v462);
                                    // Rule at src/opts/vector.isle line 7.
                                    returns.push(v463);
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
            &InstructionData::UnaryIeee32 {
                opcode: ref v409,
                imm: v410,
            } => {
                if let &Opcode::F32const = v409 {
                    let v406 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 28.
                    returns.push(v406);
                }
            }
            &InstructionData::UnaryIeee64 {
                opcode: ref v411,
                imm: v412,
            } => {
                if let &Opcode::F64const = v411 {
                    let v406 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 30.
                    returns.push(v406);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref v407,
                imm: v408,
            } => {
                if let &Opcode::Iconst = v407 {
                    let v406 = C::remat(ctx, arg0);
                    // Rule at src/opts/remat.isle line 26.
                    returns.push(v406);
                }
            }
            _ => {}
        }
    }
    return ContextIterWrapper::from(returns.into_iter());
}

// Generated as internal constructor for term splat8.
pub fn constructor_splat8<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x8);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat16(ctx, v3);
    // Rule at src/opts/cprop.isle line 194.
    return v4;
}

// Generated as internal constructor for term splat16.
pub fn constructor_splat16<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x10);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = constructor_splat32(ctx, v3);
    // Rule at src/opts/cprop.isle line 196.
    return v4;
}

// Generated as internal constructor for term splat32.
pub fn constructor_splat32<C: Context>(ctx: &mut C, arg0: u64) -> Constant {
    let v2 = C::u64_shl(ctx, arg0, 0x20);
    let v3 = C::u64_or(ctx, arg0, v2);
    let v4 = C::splat64(ctx, v3);
    // Rule at src/opts/cprop.isle line 198.
    return v4;
}

// Generated as internal constructor for term intcc_comparable.
pub fn constructor_intcc_comparable<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: &IntCC,
) -> Option<bool> {
    let v2 = constructor_intcc_class(ctx, arg0);
    let v3 = constructor_intcc_class(ctx, arg1);
    let v4 = C::u64_and(ctx, v2, v3);
    let v5 = C::u64_is_zero(ctx, v4);
    if v5 == false {
        let v7 = C::u64_eq(ctx, 0x2, v4);
        // Rule at src/opts/icmp.isle line 137.
        return Some(v7);
    }
    None
}

// Generated as internal constructor for term decompose_intcc.
pub fn constructor_decompose_intcc<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 142.
            return 0x1;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 151.
            return 0x6;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 148.
            return 0x4;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 150.
            return 0x5;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 144.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 146.
            return 0x3;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 147.
            return 0x4;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 149.
            return 0x5;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 143.
            return 0x2;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 145.
            return 0x3;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "decompose_intcc", "src/opts/icmp.isle line 141"
    )
}

// Generated as internal constructor for term compose_icmp.
pub fn constructor_compose_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: u64,
    arg2: bool,
    arg3: Value,
    arg4: Value,
) -> Value {
    match arg1 {
        0x0 => {
            let v6 = C::imm64(ctx, 0x0);
            let v7 = constructor_iconst(ctx, arg0, v6);
            let v8 = C::subsume(ctx, v7);
            // Rule at src/opts/icmp.isle line 154.
            return v8;
        }
        0x1 => {
            let v10 = constructor_icmp(ctx, arg0, &IntCC::Equal, arg3, arg4);
            // Rule at src/opts/icmp.isle line 155.
            return v10;
        }
        0x2 => {
            match arg2 {
                true => {
                    let v14 = constructor_icmp(ctx, arg0, &IntCC::SignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 157.
                    return v14;
                }
                false => {
                    let v12 = constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 156.
                    return v12;
                }
                _ => {}
            }
        }
        0x3 => {
            match arg2 {
                true => {
                    let v18 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 159.
                    return v18;
                }
                false => {
                    let v16 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedLessThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 158.
                    return v16;
                }
                _ => {}
            }
        }
        0x4 => {
            match arg2 {
                true => {
                    let v22 = constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 161.
                    return v22;
                }
                false => {
                    let v20 = constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThan, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 160.
                    return v20;
                }
                _ => {}
            }
        }
        0x5 => {
            match arg2 {
                true => {
                    let v26 =
                        constructor_icmp(ctx, arg0, &IntCC::SignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 163.
                    return v26;
                }
                false => {
                    let v24 =
                        constructor_icmp(ctx, arg0, &IntCC::UnsignedGreaterThanOrEqual, arg3, arg4);
                    // Rule at src/opts/icmp.isle line 162.
                    return v24;
                }
                _ => {}
            }
        }
        0x6 => {
            let v28 = constructor_icmp(ctx, arg0, &IntCC::NotEqual, arg3, arg4);
            // Rule at src/opts/icmp.isle line 164.
            return v28;
        }
        0x7 => {
            let v30 = C::imm64(ctx, 0x1);
            let v31 = constructor_iconst(ctx, arg0, v30);
            let v32 = C::subsume(ctx, v31);
            // Rule at src/opts/icmp.isle line 165.
            return v32;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "compose_icmp", "src/opts/icmp.isle line 153"
    )
}

// Generated as internal constructor for term intcc_class.
pub fn constructor_intcc_class<C: Context>(ctx: &mut C, arg0: &IntCC) -> u64 {
    match arg0 {
        &IntCC::Equal => {
            // Rule at src/opts/icmp.isle line 176.
            return 0x3;
        }
        &IntCC::NotEqual => {
            // Rule at src/opts/icmp.isle line 177.
            return 0x3;
        }
        &IntCC::SignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 174.
            return 0x2;
        }
        &IntCC::SignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 175.
            return 0x2;
        }
        &IntCC::SignedLessThan => {
            // Rule at src/opts/icmp.isle line 172.
            return 0x2;
        }
        &IntCC::SignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 173.
            return 0x2;
        }
        &IntCC::UnsignedGreaterThan => {
            // Rule at src/opts/icmp.isle line 170.
            return 0x1;
        }
        &IntCC::UnsignedGreaterThanOrEqual => {
            // Rule at src/opts/icmp.isle line 171.
            return 0x1;
        }
        &IntCC::UnsignedLessThan => {
            // Rule at src/opts/icmp.isle line 168.
            return 0x1;
        }
        &IntCC::UnsignedLessThanOrEqual => {
            // Rule at src/opts/icmp.isle line 169.
            return 0x1;
        }
        _ => {}
    }
    unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "intcc_class", "src/opts/icmp.isle line 167"
    )
}

// Generated as internal constructor for term shift_amt_to_type.
pub fn constructor_shift_amt_to_type<C: Context>(ctx: &mut C, arg0: u64) -> Option<Type> {
    match arg0 {
        0x8 => {
            // Rule at src/opts/shifts.isle line 97.
            return Some(I8);
        }
        0x10 => {
            // Rule at src/opts/shifts.isle line 98.
            return Some(I16);
        }
        0x20 => {
            // Rule at src/opts/shifts.isle line 99.
            return Some(I32);
        }
        _ => {}
    }
    None
}

// Generated as internal constructor for term func_addr.
pub fn constructor_func_addr<C: Context>(ctx: &mut C, arg0: Type, arg1: FuncRef) -> Value {
    let v3 = InstructionData::FuncAddr {
        opcode: Opcode::FuncAddr,
        func_ref: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 363.
    return v4;
}

// Generated as internal constructor for term splat.
pub fn constructor_splat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Splat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 372.
    return v4;
}

// Generated as internal constructor for term swizzle.
pub fn constructor_swizzle<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Swizzle,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 381.
    return v6;
}

// Generated as internal constructor for term x86_pshufb.
pub fn constructor_x86_pshufb<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pshufb,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 390.
    return v6;
}

// Generated as internal constructor for term insertlane.
pub fn constructor_insertlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Uimm8,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::TernaryImm8 {
        opcode: Opcode::Insertlane,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 399.
    return v7;
}

// Generated as internal constructor for term extractlane.
pub fn constructor_extractlane<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::Extractlane,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 408.
    return v5;
}

// Generated as internal constructor for term smin.
pub fn constructor_smin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 417.
    return v6;
}

// Generated as internal constructor for term umin.
pub fn constructor_umin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 426.
    return v6;
}

// Generated as internal constructor for term smax.
pub fn constructor_smax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 435.
    return v6;
}

// Generated as internal constructor for term umax.
pub fn constructor_umax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 444.
    return v6;
}

// Generated as internal constructor for term avg_round.
pub fn constructor_avg_round<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::AvgRound,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 453.
    return v6;
}

// Generated as internal constructor for term uadd_sat.
pub fn constructor_uadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 462.
    return v6;
}

// Generated as internal constructor for term sadd_sat.
pub fn constructor_sadd_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SaddSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 471.
    return v6;
}

// Generated as internal constructor for term usub_sat.
pub fn constructor_usub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::UsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 480.
    return v6;
}

// Generated as internal constructor for term ssub_sat.
pub fn constructor_ssub_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SsubSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 489.
    return v6;
}

// Generated as internal constructor for term load.
pub fn constructor_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Load,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 498.
    return v6;
}

// Generated as internal constructor for term uload8.
pub fn constructor_uload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 507.
    return v6;
}

// Generated as internal constructor for term sload8.
pub fn constructor_sload8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 516.
    return v6;
}

// Generated as internal constructor for term uload16.
pub fn constructor_uload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 525.
    return v6;
}

// Generated as internal constructor for term sload16.
pub fn constructor_sload16<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 534.
    return v6;
}

// Generated as internal constructor for term uload32.
pub fn constructor_uload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 543.
    return v6;
}

// Generated as internal constructor for term sload32.
pub fn constructor_sload32<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 552.
    return v6;
}

// Generated as internal constructor for term uload8x8.
pub fn constructor_uload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 561.
    return v6;
}

// Generated as internal constructor for term sload8x8.
pub fn constructor_sload8x8<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload8x8,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 570.
    return v6;
}

// Generated as internal constructor for term uload16x4.
pub fn constructor_uload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 579.
    return v6;
}

// Generated as internal constructor for term sload16x4.
pub fn constructor_sload16x4<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload16x4,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 588.
    return v6;
}

// Generated as internal constructor for term uload32x2.
pub fn constructor_uload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Uload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 597.
    return v6;
}

// Generated as internal constructor for term sload32x2.
pub fn constructor_sload32x2<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::Load {
        opcode: Opcode::Sload32x2,
        arg: arg2,
        flags: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 606.
    return v6;
}

// Generated as internal constructor for term stack_load.
pub fn constructor_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackLoad,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 615.
    return v5;
}

// Generated as internal constructor for term stack_addr.
pub fn constructor_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: StackSlot,
    arg2: Offset32,
) -> Value {
    let v4 = InstructionData::StackLoad {
        opcode: Opcode::StackAddr,
        stack_slot: arg1,
        offset: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 624.
    return v5;
}

// Generated as internal constructor for term dynamic_stack_load.
pub fn constructor_dynamic_stack_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackLoad,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 633.
    return v4;
}

// Generated as internal constructor for term dynamic_stack_addr.
pub fn constructor_dynamic_stack_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: DynamicStackSlot,
) -> Value {
    let v3 = InstructionData::DynamicStackLoad {
        opcode: Opcode::DynamicStackAddr,
        dynamic_stack_slot: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 642.
    return v4;
}

// Generated as internal constructor for term global_value.
pub fn constructor_global_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::GlobalValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 651.
    return v4;
}

// Generated as internal constructor for term symbol_value.
pub fn constructor_symbol_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::SymbolValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 660.
    return v4;
}

// Generated as internal constructor for term tls_value.
pub fn constructor_tls_value<C: Context>(ctx: &mut C, arg0: Type, arg1: GlobalValue) -> Value {
    let v3 = InstructionData::UnaryGlobalValue {
        opcode: Opcode::TlsValue,
        global_value: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 669.
    return v4;
}

// Generated as internal constructor for term get_pinned_reg.
pub fn constructor_get_pinned_reg<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetPinnedReg,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 678.
    return v3;
}

// Generated as internal constructor for term get_frame_pointer.
pub fn constructor_get_frame_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetFramePointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 687.
    return v3;
}

// Generated as internal constructor for term get_stack_pointer.
pub fn constructor_get_stack_pointer<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetStackPointer,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 696.
    return v3;
}

// Generated as internal constructor for term get_return_address.
pub fn constructor_get_return_address<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::GetReturnAddress,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 705.
    return v3;
}

// Generated as internal constructor for term table_addr.
pub fn constructor_table_addr<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Table,
    arg2: Value,
    arg3: Offset32,
) -> Value {
    let v5 = InstructionData::TableAddr {
        opcode: Opcode::TableAddr,
        arg: arg2,
        table: arg1,
        offset: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 714.
    return v6;
}

// Generated as internal constructor for term iconst.
pub fn constructor_iconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Imm64) -> Value {
    let v3 = InstructionData::UnaryImm {
        opcode: Opcode::Iconst,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 723.
    return v4;
}

// Generated as internal constructor for term f32const.
pub fn constructor_f32const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee32) -> Value {
    let v3 = InstructionData::UnaryIeee32 {
        opcode: Opcode::F32const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 732.
    return v4;
}

// Generated as internal constructor for term f64const.
pub fn constructor_f64const<C: Context>(ctx: &mut C, arg0: Type, arg1: Ieee64) -> Value {
    let v3 = InstructionData::UnaryIeee64 {
        opcode: Opcode::F64const,
        imm: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 741.
    return v4;
}

// Generated as internal constructor for term vconst.
pub fn constructor_vconst<C: Context>(ctx: &mut C, arg0: Type, arg1: Constant) -> Value {
    let v3 = InstructionData::UnaryConst {
        opcode: Opcode::Vconst,
        constant_handle: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 750.
    return v4;
}

// Generated as internal constructor for term shuffle.
pub fn constructor_shuffle<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Immediate,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::Shuffle {
        opcode: Opcode::Shuffle,
        args: v5.clone(),
        imm: arg3,
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 759.
    return v7;
}

// Generated as internal constructor for term null.
pub fn constructor_null<C: Context>(ctx: &mut C, arg0: Type) -> Value {
    let v2 = InstructionData::NullAry {
        opcode: Opcode::Null,
    };
    let v3 = C::make_inst_ctor(ctx, arg0, &v2);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 768.
    return v3;
}

// Generated as internal constructor for term select.
pub fn constructor_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Select,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 777.
    return v7;
}

// Generated as internal constructor for term select_spectre_guard.
pub fn constructor_select_spectre_guard<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::SelectSpectreGuard,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 786.
    return v7;
}

// Generated as internal constructor for term bitselect.
pub fn constructor_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Bitselect,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 795.
    return v7;
}

// Generated as internal constructor for term x86_blendv.
pub fn constructor_x86_blendv<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::X86Blendv,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 804.
    return v7;
}

// Generated as internal constructor for term vany_true.
pub fn constructor_vany_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VanyTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 813.
    return v4;
}

// Generated as internal constructor for term vall_true.
pub fn constructor_vall_true<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VallTrue,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 822.
    return v4;
}

// Generated as internal constructor for term vhigh_bits.
pub fn constructor_vhigh_bits<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::VhighBits,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 831.
    return v4;
}

// Generated as internal constructor for term icmp.
pub fn constructor_icmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::IntCompare {
        opcode: Opcode::Icmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 840.
    return v7;
}

// Generated as internal constructor for term icmp_imm.
pub fn constructor_icmp_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntCC,
    arg2: Value,
    arg3: Imm64,
) -> Value {
    let v5 = InstructionData::IntCompareImm {
        opcode: Opcode::IcmpImm,
        arg: arg2,
        cond: arg1.clone(),
        imm: arg3,
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 849.
    return v6;
}

// Generated as internal constructor for term iadd.
pub fn constructor_iadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 858.
    return v6;
}

// Generated as internal constructor for term isub.
pub fn constructor_isub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Isub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 867.
    return v6;
}

// Generated as internal constructor for term ineg.
pub fn constructor_ineg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ineg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 876.
    return v4;
}

// Generated as internal constructor for term iabs.
pub fn constructor_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Iabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 885.
    return v4;
}

// Generated as internal constructor for term imul.
pub fn constructor_imul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Imul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 894.
    return v6;
}

// Generated as internal constructor for term umulhi.
pub fn constructor_umulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Umulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 903.
    return v6;
}

// Generated as internal constructor for term smulhi.
pub fn constructor_smulhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Smulhi,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 912.
    return v6;
}

// Generated as internal constructor for term sqmul_round_sat.
pub fn constructor_sqmul_round_sat<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::SqmulRoundSat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 921.
    return v6;
}

// Generated as internal constructor for term x86_pmulhrsw.
pub fn constructor_x86_pmulhrsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmulhrsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 930.
    return v6;
}

// Generated as internal constructor for term udiv.
pub fn constructor_udiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Udiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 939.
    return v6;
}

// Generated as internal constructor for term sdiv.
pub fn constructor_sdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 948.
    return v6;
}

// Generated as internal constructor for term urem.
pub fn constructor_urem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Urem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 957.
    return v6;
}

// Generated as internal constructor for term srem.
pub fn constructor_srem<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Srem,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 966.
    return v6;
}

// Generated as internal constructor for term iadd_imm.
pub fn constructor_iadd_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IaddImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 975.
    return v5;
}

// Generated as internal constructor for term imul_imm.
pub fn constructor_imul_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::ImulImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 984.
    return v5;
}

// Generated as internal constructor for term udiv_imm.
pub fn constructor_udiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 993.
    return v5;
}

// Generated as internal constructor for term sdiv_imm.
pub fn constructor_sdiv_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SdivImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1002.
    return v5;
}

// Generated as internal constructor for term urem_imm.
pub fn constructor_urem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1011.
    return v5;
}

// Generated as internal constructor for term srem_imm.
pub fn constructor_srem_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SremImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1020.
    return v5;
}

// Generated as internal constructor for term irsub_imm.
pub fn constructor_irsub_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IrsubImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1029.
    return v5;
}

// Generated as internal constructor for term iadd_cin.
pub fn constructor_iadd_cin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IaddCin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1038.
    return v7;
}

// Generated as internal constructor for term uadd_overflow_trap.
pub fn constructor_uadd_overflow_trap<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: &TrapCode,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v6 = InstructionData::IntAddTrap {
        opcode: Opcode::UaddOverflowTrap,
        args: v5.clone(),
        code: arg3.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1047.
    return v7;
}

// Generated as internal constructor for term isub_bin.
pub fn constructor_isub_bin<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::IsubBin,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1056.
    return v7;
}

// Generated as internal constructor for term band.
pub fn constructor_band<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Band,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1065.
    return v6;
}

// Generated as internal constructor for term bor.
pub fn constructor_bor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1074.
    return v6;
}

// Generated as internal constructor for term bxor.
pub fn constructor_bxor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Bxor,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1083.
    return v6;
}

// Generated as internal constructor for term bnot.
pub fn constructor_bnot<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bnot,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1092.
    return v4;
}

// Generated as internal constructor for term band_not.
pub fn constructor_band_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BandNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1101.
    return v6;
}

// Generated as internal constructor for term bor_not.
pub fn constructor_bor_not<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1110.
    return v6;
}

// Generated as internal constructor for term bxor_not.
pub fn constructor_bxor_not<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::BxorNot,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1119.
    return v6;
}

// Generated as internal constructor for term band_imm.
pub fn constructor_band_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BandImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1128.
    return v5;
}

// Generated as internal constructor for term bor_imm.
pub fn constructor_bor_imm<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Imm64) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1137.
    return v5;
}

// Generated as internal constructor for term bxor_imm.
pub fn constructor_bxor_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::BxorImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1146.
    return v5;
}

// Generated as internal constructor for term rotl.
pub fn constructor_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1155.
    return v6;
}

// Generated as internal constructor for term rotr.
pub fn constructor_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Rotr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1164.
    return v6;
}

// Generated as internal constructor for term rotl_imm.
pub fn constructor_rotl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1173.
    return v5;
}

// Generated as internal constructor for term rotr_imm.
pub fn constructor_rotr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::RotrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1182.
    return v5;
}

// Generated as internal constructor for term ishl.
pub fn constructor_ishl<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ishl,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1191.
    return v6;
}

// Generated as internal constructor for term ushr.
pub fn constructor_ushr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Ushr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1200.
    return v6;
}

// Generated as internal constructor for term sshr.
pub fn constructor_sshr<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Sshr,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1209.
    return v6;
}

// Generated as internal constructor for term ishl_imm.
pub fn constructor_ishl_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::IshlImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1218.
    return v5;
}

// Generated as internal constructor for term ushr_imm.
pub fn constructor_ushr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::UshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1227.
    return v5;
}

// Generated as internal constructor for term sshr_imm.
pub fn constructor_sshr_imm<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Imm64,
) -> Value {
    let v4 = InstructionData::BinaryImm64 {
        opcode: Opcode::SshrImm,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1236.
    return v5;
}

// Generated as internal constructor for term bitrev.
pub fn constructor_bitrev<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bitrev,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1245.
    return v4;
}

// Generated as internal constructor for term clz.
pub fn constructor_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Clz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1254.
    return v4;
}

// Generated as internal constructor for term cls.
pub fn constructor_cls<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Cls,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1263.
    return v4;
}

// Generated as internal constructor for term ctz.
pub fn constructor_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ctz,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1272.
    return v4;
}

// Generated as internal constructor for term bswap.
pub fn constructor_bswap<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bswap,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1281.
    return v4;
}

// Generated as internal constructor for term popcnt.
pub fn constructor_popcnt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Popcnt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1290.
    return v4;
}

// Generated as internal constructor for term fcmp.
pub fn constructor_fcmp<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &FloatCC,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_2_ctor(ctx, arg2, arg3);
    let v6 = InstructionData::FloatCompare {
        opcode: Opcode::Fcmp,
        args: v5.clone(),
        cond: arg1.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1299.
    return v7;
}

// Generated as internal constructor for term fadd.
pub fn constructor_fadd<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fadd,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1308.
    return v6;
}

// Generated as internal constructor for term fsub.
pub fn constructor_fsub<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fsub,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1317.
    return v6;
}

// Generated as internal constructor for term fmul.
pub fn constructor_fmul<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmul,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1326.
    return v6;
}

// Generated as internal constructor for term fdiv.
pub fn constructor_fdiv<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fdiv,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1335.
    return v6;
}

// Generated as internal constructor for term sqrt.
pub fn constructor_sqrt<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sqrt,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1344.
    return v4;
}

// Generated as internal constructor for term fma.
pub fn constructor_fma<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
    arg3: Value,
) -> Value {
    let v5 = &C::value_array_3_ctor(ctx, arg1, arg2, arg3);
    let v6 = InstructionData::Ternary {
        opcode: Opcode::Fma,
        args: v5.clone(),
    };
    let v7 = C::make_inst_ctor(ctx, arg0, &v6);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1353.
    return v7;
}

// Generated as internal constructor for term fneg.
pub fn constructor_fneg<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fneg,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1362.
    return v4;
}

// Generated as internal constructor for term fabs.
pub fn constructor_fabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fabs,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1371.
    return v4;
}

// Generated as internal constructor for term fcopysign.
pub fn constructor_fcopysign<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fcopysign,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1380.
    return v6;
}

// Generated as internal constructor for term fmin.
pub fn constructor_fmin<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmin,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1389.
    return v6;
}

// Generated as internal constructor for term fmin_pseudo.
pub fn constructor_fmin_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FminPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1398.
    return v6;
}

// Generated as internal constructor for term fmax.
pub fn constructor_fmax<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Fmax,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1407.
    return v6;
}

// Generated as internal constructor for term fmax_pseudo.
pub fn constructor_fmax_pseudo<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::FmaxPseudo,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1416.
    return v6;
}

// Generated as internal constructor for term ceil.
pub fn constructor_ceil<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ceil,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1425.
    return v4;
}

// Generated as internal constructor for term floor.
pub fn constructor_floor<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Floor,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1434.
    return v4;
}

// Generated as internal constructor for term trunc.
pub fn constructor_trunc<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Trunc,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1443.
    return v4;
}

// Generated as internal constructor for term nearest.
pub fn constructor_nearest<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Nearest,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1452.
    return v4;
}

// Generated as internal constructor for term is_null.
pub fn constructor_is_null<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsNull,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1461.
    return v4;
}

// Generated as internal constructor for term is_invalid.
pub fn constructor_is_invalid<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::IsInvalid,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1470.
    return v4;
}

// Generated as internal constructor for term bitcast.
pub fn constructor_bitcast<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::Bitcast,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1479.
    return v5;
}

// Generated as internal constructor for term scalar_to_vector.
pub fn constructor_scalar_to_vector<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::ScalarToVector,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1488.
    return v4;
}

// Generated as internal constructor for term bmask.
pub fn constructor_bmask<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Bmask,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1497.
    return v4;
}

// Generated as internal constructor for term ireduce.
pub fn constructor_ireduce<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Ireduce,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1506.
    return v4;
}

// Generated as internal constructor for term snarrow.
pub fn constructor_snarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Snarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1515.
    return v6;
}

// Generated as internal constructor for term unarrow.
pub fn constructor_unarrow<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Unarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1524.
    return v6;
}

// Generated as internal constructor for term uunarrow.
pub fn constructor_uunarrow<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Uunarrow,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1533.
    return v6;
}

// Generated as internal constructor for term swiden_low.
pub fn constructor_swiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1542.
    return v4;
}

// Generated as internal constructor for term swiden_high.
pub fn constructor_swiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::SwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1551.
    return v4;
}

// Generated as internal constructor for term uwiden_low.
pub fn constructor_uwiden_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1560.
    return v4;
}

// Generated as internal constructor for term uwiden_high.
pub fn constructor_uwiden_high<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::UwidenHigh,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1569.
    return v4;
}

// Generated as internal constructor for term iadd_pairwise.
pub fn constructor_iadd_pairwise<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::IaddPairwise,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1578.
    return v6;
}

// Generated as internal constructor for term x86_pmaddubsw.
pub fn constructor_x86_pmaddubsw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Value,
) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::X86Pmaddubsw,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1587.
    return v6;
}

// Generated as internal constructor for term uextend.
pub fn constructor_uextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Uextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1596.
    return v4;
}

// Generated as internal constructor for term sextend.
pub fn constructor_sextend<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Sextend,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1605.
    return v4;
}

// Generated as internal constructor for term fpromote.
pub fn constructor_fpromote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fpromote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1614.
    return v4;
}

// Generated as internal constructor for term fdemote.
pub fn constructor_fdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1623.
    return v4;
}

// Generated as internal constructor for term fvdemote.
pub fn constructor_fvdemote<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::Fvdemote,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1632.
    return v4;
}

// Generated as internal constructor for term fvpromote_low.
pub fn constructor_fvpromote_low<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FvpromoteLow,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1641.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint.
pub fn constructor_fcvt_to_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1650.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint.
pub fn constructor_fcvt_to_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1659.
    return v4;
}

// Generated as internal constructor for term fcvt_to_uint_sat.
pub fn constructor_fcvt_to_uint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToUintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1668.
    return v4;
}

// Generated as internal constructor for term fcvt_to_sint_sat.
pub fn constructor_fcvt_to_sint_sat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtToSintSat,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1677.
    return v4;
}

// Generated as internal constructor for term x86_cvtt2dq.
pub fn constructor_x86_cvtt2dq<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::X86Cvtt2dq,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1686.
    return v4;
}

// Generated as internal constructor for term fcvt_from_uint.
pub fn constructor_fcvt_from_uint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromUint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1695.
    return v4;
}

// Generated as internal constructor for term fcvt_from_sint.
pub fn constructor_fcvt_from_sint<C: Context>(ctx: &mut C, arg0: Type, arg1: Value) -> Value {
    let v3 = InstructionData::Unary {
        opcode: Opcode::FcvtFromSint,
        arg: arg1,
    };
    let v4 = C::make_inst_ctor(ctx, arg0, &v3);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1704.
    return v4;
}

// Generated as internal constructor for term iconcat.
pub fn constructor_iconcat<C: Context>(ctx: &mut C, arg0: Type, arg1: Value, arg2: Value) -> Value {
    let v4 = &C::value_array_2_ctor(ctx, arg1, arg2);
    let v5 = InstructionData::Binary {
        opcode: Opcode::Iconcat,
        args: v4.clone(),
    };
    let v6 = C::make_inst_ctor(ctx, arg0, &v5);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1713.
    return v6;
}

// Generated as internal constructor for term atomic_rmw.
pub fn constructor_atomic_rmw<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: &AtomicRmwOp,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_2_ctor(ctx, arg3, arg4);
    let v7 = InstructionData::AtomicRmw {
        opcode: Opcode::AtomicRmw,
        args: v6.clone(),
        flags: arg1,
        op: arg2.clone(),
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1722.
    return v8;
}

// Generated as internal constructor for term atomic_cas.
pub fn constructor_atomic_cas<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
    arg3: Value,
    arg4: Value,
) -> Value {
    let v6 = &C::value_array_3_ctor(ctx, arg2, arg3, arg4);
    let v7 = InstructionData::AtomicCas {
        opcode: Opcode::AtomicCas,
        args: v6.clone(),
        flags: arg1,
    };
    let v8 = C::make_inst_ctor(ctx, arg0, &v7);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1731.
    return v8;
}

// Generated as internal constructor for term atomic_load.
pub fn constructor_atomic_load<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: MemFlags,
    arg2: Value,
) -> Value {
    let v4 = InstructionData::LoadNoOffset {
        opcode: Opcode::AtomicLoad,
        arg: arg2,
        flags: arg1,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1740.
    return v5;
}

// Generated as internal constructor for term extract_vector.
pub fn constructor_extract_vector<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Value,
    arg2: Uimm8,
) -> Value {
    let v4 = InstructionData::BinaryImm8 {
        opcode: Opcode::ExtractVector,
        arg: arg1,
        imm: arg2,
    };
    let v5 = C::make_inst_ctor(ctx, arg0, &v4);
    // Rule at /Users/admin/projects/public/wasmtime/cranelift/codegen/isle_generated_code/clif_opt.isle line 1749.
    return v5;
}
