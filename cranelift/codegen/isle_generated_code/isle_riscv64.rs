// GENERATED BY ISLE. DO NOT EDIT!
//
// Generated automatically from the instruction-selection DSL code in:
// - src/prelude.isle
// - src/prelude_lower.isle
// - src/isa/riscv64/inst.isle
// - src/isa/riscv64/lower.isle
// - /Users/avh/research/wasmtime/cranelift/codegen/isle_generated_code/clif_lower.isle

use super::*; // Pulls in all external types.
use std::marker::PhantomData;

/// Context during lowering: an implementation of this trait
/// must be provided with all external constructors and extractors.
/// A mutable borrow is passed along through all lowering logic.
pub trait Context {
    fn unit(&mut self) -> Unit;
    fn value_type(&mut self, arg0: Value) -> Type;
    fn u32_add(&mut self, arg0: u32, arg1: u32) -> u32;
    fn s32_add_fallible(&mut self, arg0: u32, arg1: u32) -> Option<u32>;
    fn u32_nonnegative(&mut self, arg0: u32) -> Option<u32>;
    fn offset32(&mut self, arg0: Offset32) -> u32;
    fn u32_lteq(&mut self, arg0: u32, arg1: u32) -> Option<Unit>;
    fn u8_lteq(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn u8_lt(&mut self, arg0: u8, arg1: u8) -> Option<Unit>;
    fn simm32(&mut self, arg0: Imm64) -> Option<u32>;
    fn uimm8(&mut self, arg0: Imm64) -> Option<u8>;
    fn u8_and(&mut self, arg0: u8, arg1: u8) -> u8;
    fn u8_as_u32(&mut self, arg0: u8) -> u32;
    fn u8_as_u64(&mut self, arg0: u8) -> u64;
    fn u16_as_u64(&mut self, arg0: u16) -> u64;
    fn u32_as_u64(&mut self, arg0: u32) -> u64;
    fn i64_as_u64(&mut self, arg0: i64) -> u64;
    fn u64_add(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sub(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_mul(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_sdiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_udiv(&mut self, arg0: u64, arg1: u64) -> Option<u64>;
    fn u64_and(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_or(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_xor(&mut self, arg0: u64, arg1: u64) -> u64;
    fn u64_not(&mut self, arg0: u64) -> u64;
    fn u64_sextend_u32(&mut self, arg0: u64) -> u64;
    fn u64_uextend_u32(&mut self, arg0: u64) -> u64;
    fn u64_is_zero(&mut self, arg0: u64) -> bool;
    fn u64_is_odd(&mut self, arg0: u64) -> bool;
    fn ty_bits(&mut self, arg0: Type) -> u8;
    fn ty_bits_u16(&mut self, arg0: Type) -> u16;
    fn ty_bits_u64(&mut self, arg0: Type) -> u64;
    fn ty_mask(&mut self, arg0: Type) -> u64;
    fn ty_bytes(&mut self, arg0: Type) -> u16;
    fn lane_type(&mut self, arg0: Type) -> Type;
    fn mem_flags_trusted(&mut self) -> MemFlags;
    fn intcc_reverse(&mut self, arg0: &IntCC) -> IntCC;
    fn intcc_inverse(&mut self, arg0: &IntCC) -> IntCC;
    fn floatcc_reverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn floatcc_inverse(&mut self, arg0: &FloatCC) -> FloatCC;
    fn fits_in_16(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn lane_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn fits_in_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_scalar_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_32_or_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_8_or_16(&mut self, arg0: Type) -> Option<Type>;
    fn int_fits_in_32(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int_ref_64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_scalar_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_float_or_vec(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vector_not_float(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_ctor(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec64(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn_vec128(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_vec128_int(&mut self, arg0: Type) -> Option<Type>;
    fn not_vec32x2(&mut self, arg0: Type) -> Option<Type>;
    fn not_i64x2(&mut self, arg0: Type) -> Option<()>;
    fn u8_from_uimm8(&mut self, arg0: Uimm8) -> u8;
    fn u64_from_bool(&mut self, arg0: bool) -> u64;
    fn u64_from_imm64(&mut self, arg0: Imm64) -> u64;
    fn nonzero_u64_from_imm64(&mut self, arg0: Imm64) -> Option<u64>;
    fn imm64(&mut self, arg0: u64) -> Imm64;
    fn imm64_masked(&mut self, arg0: Type, arg1: u64) -> Imm64;
    fn u64_from_ieee32(&mut self, arg0: Ieee32) -> u64;
    fn u64_from_ieee64(&mut self, arg0: Ieee64) -> u64;
    fn multi_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_lane(&mut self, arg0: Type) -> Option<(u32, u32)>;
    fn dynamic_int_lane(&mut self, arg0: Type) -> Option<u32>;
    fn dynamic_fp_lane(&mut self, arg0: Type) -> Option<u32>;
    fn ty_dyn64_int(&mut self, arg0: Type) -> Option<Type>;
    fn ty_dyn128_int(&mut self, arg0: Type) -> Option<Type>;
    fn offset32_to_u32(&mut self, arg0: Offset32) -> u32;
    fn intcc_unsigned(&mut self, arg0: &IntCC) -> IntCC;
    fn signed_cond_code(&mut self, arg0: &IntCC) -> Option<IntCC>;
    fn trap_code_division_by_zero(&mut self) -> TrapCode;
    fn trap_code_integer_overflow(&mut self) -> TrapCode;
    fn trap_code_bad_conversion_to_integer(&mut self) -> TrapCode;
    fn range(&mut self, arg0: usize, arg1: usize) -> Range;
    fn range_view(&mut self, arg0: Range) -> RangeView;
    fn value_reg(&mut self, arg0: Reg) -> ValueRegs;
    fn value_regs(&mut self, arg0: Reg, arg1: Reg) -> ValueRegs;
    fn value_regs_invalid(&mut self) -> ValueRegs;
    fn output_none(&mut self) -> InstOutput;
    fn output(&mut self, arg0: ValueRegs) -> InstOutput;
    fn output_pair(&mut self, arg0: ValueRegs, arg1: ValueRegs) -> InstOutput;
    fn output_builder_new(&mut self) -> InstOutputBuilder;
    fn output_builder_push(&mut self, arg0: &InstOutputBuilder, arg1: ValueRegs) -> Unit;
    fn output_builder_finish(&mut self, arg0: &InstOutputBuilder) -> InstOutput;
    fn temp_writable_reg(&mut self, arg0: Type) -> WritableReg;
    fn is_valid_reg(&mut self, arg0: Reg) -> bool;
    fn invalid_reg(&mut self) -> Reg;
    fn mark_value_used(&mut self, arg0: Value) -> Unit;
    fn put_in_reg(&mut self, arg0: Value) -> Reg;
    fn put_in_regs(&mut self, arg0: Value) -> ValueRegs;
    fn ensure_in_vreg(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn value_regs_get(&mut self, arg0: ValueRegs, arg1: usize) -> Reg;
    fn value_regs_len(&mut self, arg0: ValueRegs) -> usize;
    fn preg_to_reg(&mut self, arg0: PReg) -> Reg;
    fn value_list_slice(&mut self, arg0: ValueList) -> ValueSlice;
    fn value_slice_empty(&mut self, arg0: ValueSlice) -> Option<()>;
    fn value_slice_unwrap(&mut self, arg0: ValueSlice) -> Option<(Value, ValueSlice)>;
    fn value_slice_len(&mut self, arg0: ValueSlice) -> usize;
    fn value_slice_get(&mut self, arg0: ValueSlice, arg1: usize) -> Value;
    fn writable_reg_to_reg(&mut self, arg0: WritableReg) -> Reg;
    fn inst_results(&mut self, arg0: Inst) -> ValueSlice;
    fn first_result(&mut self, arg0: Inst) -> Option<Value>;
    fn inst_data(&mut self, arg0: Inst) -> InstructionData;
    fn def_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn zero_value(&mut self, arg0: Value) -> Option<Value>;
    fn is_sinkable_inst(&mut self, arg0: Value) -> Option<Inst>;
    fn maybe_uextend(&mut self, arg0: Value) -> Option<Value>;
    fn emit(&mut self, arg0: &MInst) -> Unit;
    fn sink_inst(&mut self, arg0: Inst) -> Unit;
    fn emit_u64_le_const(&mut self, arg0: u64) -> VCodeConstant;
    fn emit_u128_le_const(&mut self, arg0: u128) -> VCodeConstant;
    fn const_to_vconst(&mut self, arg0: Constant) -> VCodeConstant;
    fn avoid_div_traps(&mut self, arg0: Type) -> Option<()>;
    fn tls_model(&mut self, arg0: Type) -> TlsModel;
    fn tls_model_is_elf_gd(&mut self) -> Option<Unit>;
    fn tls_model_is_macho(&mut self) -> Option<Unit>;
    fn tls_model_is_coff(&mut self) -> Option<Unit>;
    fn preserve_frame_pointers(&mut self) -> Option<Unit>;
    fn box_external_name(&mut self, arg0: ExternalName) -> BoxExternalName;
    fn func_ref_data(&mut self, arg0: FuncRef) -> (SigRef, ExternalName, RelocDistance);
    fn symbol_value_data(
        &mut self,
        arg0: GlobalValue,
    ) -> Option<(ExternalName, RelocDistance, i64)>;
    fn reloc_distance_near(&mut self, arg0: RelocDistance) -> Option<()>;
    fn vec_mask_from_immediate(&mut self, arg0: Immediate) -> Option<VecMask>;
    fn u128_from_immediate(&mut self, arg0: Immediate) -> Option<u128>;
    fn u128_from_constant(&mut self, arg0: Constant) -> Option<u128>;
    fn u64_from_constant(&mut self, arg0: Constant) -> Option<u64>;
    fn only_writable_reg(&mut self, arg0: WritableValueRegs) -> Option<WritableReg>;
    fn writable_regs_get(&mut self, arg0: WritableValueRegs, arg1: usize) -> WritableReg;
    fn abi_num_args(&mut self, arg0: Sig) -> usize;
    fn abi_get_arg(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_num_rets(&mut self, arg0: Sig) -> usize;
    fn abi_get_ret(&mut self, arg0: Sig, arg1: usize) -> ABIArg;
    fn abi_ret_arg(&mut self, arg0: Sig) -> Option<ABIArg>;
    fn abi_no_ret_arg(&mut self, arg0: Sig) -> Option<()>;
    fn abi_sized_stack_arg_space(&mut self, arg0: Sig) -> i64;
    fn abi_sized_stack_ret_space(&mut self, arg0: Sig) -> i64;
    fn abi_stackslot_addr(&mut self, arg0: WritableReg, arg1: StackSlot, arg2: Offset32) -> MInst;
    fn abi_dynamic_stackslot_addr(&mut self, arg0: WritableReg, arg1: DynamicStackSlot) -> MInst;
    fn abi_arg_only_slot(&mut self, arg0: &ABIArg) -> Option<ABIArgSlot>;
    fn abi_arg_struct_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, u64)>;
    fn abi_arg_implicit_pointer(&mut self, arg0: &ABIArg) -> Option<(ABIArgSlot, i64, Type)>;
    fn real_reg_to_reg(&mut self, arg0: RealReg) -> Reg;
    fn real_reg_to_writable_reg(&mut self, arg0: RealReg) -> WritableReg;
    fn gen_move(&mut self, arg0: Type, arg1: WritableReg, arg2: Reg) -> MInst;
    fn gen_return(&mut self, arg0: ValueSlice) -> Unit;
    fn zero_reg(&mut self) -> Reg;
    fn imm(&mut self, arg0: Type, arg1: u64) -> Reg;
    fn imm_from_bits(&mut self, arg0: u64) -> Imm12;
    fn imm_from_neg_bits(&mut self, arg0: i64) -> Imm12;
    fn imm12_from_u64(&mut self, arg0: u64) -> Option<Imm12>;
    fn writable_zero_reg(&mut self) -> WritableReg;
    fn gen_default_frm(&mut self) -> OptionFloatRoundingMode;
    fn pack_float_rounding_mode(&mut self, arg0: &FRM) -> OptionFloatRoundingMode;
    fn neg_imm12(&mut self, arg0: Imm12) -> Imm12;
    fn u8_as_i32(&mut self, arg0: u8) -> i32;
    fn gen_select_reg(&mut self, arg0: &IntCC, arg1: Reg, arg2: Reg, arg3: Reg, arg4: Reg) -> Reg;
    fn load_u64_constant(&mut self, arg0: u64) -> Reg;
    fn ext_sign_bit(&mut self, arg0: Type, arg1: Reg) -> Reg;
    fn has_b(&mut self) -> bool;
    fn gen_shamt(&mut self, arg0: Type, arg1: Reg) -> ValueRegs;
    fn imm12_const(&mut self, arg0: i32) -> Imm12;
    fn imm12_const_add(&mut self, arg0: i32, arg1: i32) -> Imm12;
    fn imm12_and(&mut self, arg0: Imm12, arg1: i32) -> Imm12;
    fn gen_amode(&mut self, arg0: Reg, arg1: Offset32, arg2: Type) -> AMode;
    fn offset32_imm(&mut self, arg0: i32) -> Offset32;
    fn default_memflags(&mut self) -> MemFlags;
    fn offset32_add(&mut self, arg0: Offset32, arg1: i64) -> Offset32;
    fn valid_atomic_transaction(&mut self, arg0: Type) -> Option<Type>;
    fn atomic_amo(&mut self) -> AMO;
    fn move_f_to_x(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn move_x_to_f(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn gen_stack_addr(&mut self, arg0: StackSlot, arg1: Offset32) -> Reg;
    fn gen_move2(&mut self, arg0: Reg, arg1: Type, arg2: Type) -> Reg;
    fn gen_moves(&mut self, arg0: ValueRegs, arg1: Type, arg2: Type) -> ValueRegs;
    fn vec_writable_clone(&mut self, arg0: &VecWritableReg) -> VecWritableReg;
    fn vec_writable_to_regs(&mut self, arg0: &VecWritableReg) -> ValueRegs;
    fn alloc_vec_writable(&mut self, arg0: Type) -> VecWritableReg;
    fn load_op(&mut self, arg0: Type) -> LoadOP;
    fn store_op(&mut self, arg0: Type) -> StoreOP;
    fn load_ext_name(&mut self, arg0: ExternalName, arg1: i64) -> Reg;
    fn int_convert_2_float_op(&mut self, arg0: Type, arg1: bool, arg2: Type) -> FpuOPRR;
    fn inst_output_get(&mut self, arg0: InstOutput, arg1: u8) -> ValueRegs;
    fn label_to_br_target(&mut self, arg0: MachLabel) -> BranchTarget;
    fn vec_label_get(&mut self, arg0: &VecMachLabel, arg1: u8) -> MachLabel;
    fn lower_br_icmp(
        &mut self,
        arg0: &IntCC,
        arg1: ValueRegs,
        arg2: ValueRegs,
        arg3: &VecMachLabel,
        arg4: Type,
    ) -> Unit;
    fn lower_br_fcmp(
        &mut self,
        arg0: &FloatCC,
        arg1: Reg,
        arg2: Reg,
        arg3: &VecMachLabel,
        arg4: Type,
    ) -> Unit;
    fn int_zero_reg(&mut self, arg0: Type) -> ValueRegs;
    fn lower_brz_or_nz(
        &mut self,
        arg0: &IntCC,
        arg1: ValueRegs,
        arg2: &VecMachLabel,
        arg3: Type,
    ) -> Unit;
    fn lower_br_table(&mut self, arg0: Reg, arg1: &VecMachLabel) -> Unit;
    fn load_ra(&mut self) -> Reg;
    fn has_zbkb(&mut self) -> bool;
    fn has_zbb(&mut self) -> bool;
    fn shift_int_to_most_significant(&mut self, arg0: Reg, arg1: Type) -> Reg;
    fn gen_call(
        &mut self,
        arg0: SigRef,
        arg1: ExternalName,
        arg2: RelocDistance,
        arg3: ValueSlice,
    ) -> InstOutput;
    fn gen_call_indirect(&mut self, arg0: SigRef, arg1: Value, arg2: ValueSlice) -> InstOutput;
    fn fp_reg(&mut self) -> PReg;
    fn sp_reg(&mut self) -> PReg;
    fn is_atomic_rmw_max_etc(&mut self, arg0: &AtomicRmwOp) -> Option<(AtomicRmwOp, bool)>;
    fn unpack_value_array_2(&mut self, arg0: &ValueArray2) -> (Value, Value);
    fn pack_value_array_2(&mut self, arg0: Value, arg1: Value) -> ValueArray2;
    fn unpack_value_array_3(&mut self, arg0: &ValueArray3) -> (Value, Value, Value);
    fn pack_value_array_3(&mut self, arg0: Value, arg1: Value, arg2: Value) -> ValueArray3;
}

pub trait ContextIter {
    type Context;
    type Output;
    fn next(&mut self, ctx: &mut Self::Context) -> Option<Self::Output>;
}

pub struct ContextIterWrapper<Item, I: Iterator<Item = Item>, C: Context> {
    iter: I,
    _ctx: PhantomData<C>,
}
impl<Item, I: Iterator<Item = Item>, C: Context> From<I> for ContextIterWrapper<Item, I, C> {
    fn from(iter: I) -> Self {
        Self {
            iter,
            _ctx: PhantomData,
        }
    }
}
impl<Item, I: Iterator<Item = Item>, C: Context> ContextIter for ContextIterWrapper<Item, I, C> {
    type Context = C;
    type Output = Item;
    fn next(&mut self, _ctx: &mut Self::Context) -> Option<Self::Output> {
        self.iter.next()
    }
}

/// Internal type SideEffectNoResult: defined at src/prelude_lower.isle line 282.
#[derive(Clone, Debug)]
pub enum SideEffectNoResult {
    Inst {
        inst: MInst,
    },
    Inst2 {
        inst1: MInst,
        inst2: MInst,
    },
    Inst3 {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
    },
}

/// Internal type ProducesFlags: defined at src/prelude_lower.isle line 324.
#[derive(Clone, Debug)]
pub enum ProducesFlags {
    AlreadyExistingFlags,
    ProducesFlagsSideEffect { inst: MInst },
    ProducesFlagsTwiceSideEffect { inst1: MInst, inst2: MInst },
    ProducesFlagsReturnsReg { inst: MInst, result: Reg },
    ProducesFlagsReturnsResultWithConsumer { inst: MInst, result: Reg },
}

/// Internal type ConsumesFlags: defined at src/prelude_lower.isle line 346.
#[derive(Clone, Debug)]
pub enum ConsumesFlags {
    ConsumesFlagsSideEffect {
        inst: MInst,
    },
    ConsumesFlagsSideEffect2 {
        inst1: MInst,
        inst2: MInst,
    },
    ConsumesFlagsReturnsResultWithProducer {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsReturnsReg {
        inst: MInst,
        result: Reg,
    },
    ConsumesFlagsTwiceReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        result: ValueRegs,
    },
    ConsumesFlagsFourTimesReturnsValueRegs {
        inst1: MInst,
        inst2: MInst,
        inst3: MInst,
        inst4: MInst,
        result: ValueRegs,
    },
}

/// Internal type MInst: defined at src/isa/riscv64/inst.isle line 2.
#[derive(Clone, Debug)]
pub enum MInst {
    Nop0,
    Nop4,
    Lui {
        rd: WritableReg,
        imm: Imm20,
    },
    LoadConst32 {
        rd: WritableReg,
        imm: u32,
    },
    LoadConst64 {
        rd: WritableReg,
        imm: u64,
    },
    Auipc {
        rd: WritableReg,
        imm: Imm20,
    },
    FpuRR {
        alu_op: FpuOPRR,
        frm: OptionFloatRoundingMode,
        rd: WritableReg,
        rs: Reg,
    },
    AluRRR {
        alu_op: AluOPRRR,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
    },
    FpuRRR {
        alu_op: FpuOPRRR,
        frm: OptionFloatRoundingMode,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
    },
    FpuRRRR {
        alu_op: FpuOPRRRR,
        frm: OptionFloatRoundingMode,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        rs3: Reg,
    },
    AluRRImm12 {
        alu_op: AluOPRRI,
        rd: WritableReg,
        rs: Reg,
        imm12: Imm12,
    },
    Load {
        rd: WritableReg,
        op: LoadOP,
        flags: MemFlags,
        from: AMode,
    },
    Store {
        to: AMode,
        op: StoreOP,
        flags: MemFlags,
        src: Reg,
    },
    Args {
        args: VecArgPair,
    },
    Ret {
        rets: VecRetPair,
    },
    Extend {
        rd: WritableReg,
        rn: Reg,
        signed: bool,
        from_bits: u8,
        to_bits: u8,
    },
    AjustSp {
        amount: i64,
    },
    Call {
        info: BoxCallInfo,
    },
    CallInd {
        info: BoxCallIndInfo,
    },
    TrapIf {
        test: Reg,
        trap_code: TrapCode,
    },
    TrapIfC {
        rs1: Reg,
        rs2: Reg,
        cc: IntCC,
        trap_code: TrapCode,
    },
    TrapFf {
        cc: FloatCC,
        x: Reg,
        y: Reg,
        ty: Type,
        tmp: WritableReg,
        trap_code: TrapCode,
    },
    Jal {
        dest: BranchTarget,
    },
    CondBr {
        taken: BranchTarget,
        not_taken: BranchTarget,
        kind: IntegerCompare,
    },
    LoadExtName {
        rd: WritableReg,
        name: BoxExternalName,
        offset: i64,
    },
    LoadAddr {
        rd: WritableReg,
        mem: AMode,
    },
    VirtualSPOffsetAdj {
        amount: i64,
    },
    Mov {
        rd: WritableReg,
        rm: Reg,
        ty: Type,
    },
    MovFromPReg {
        rd: WritableReg,
        rm: PReg,
    },
    Fence {
        pred: u8,
        succ: u8,
    },
    FenceI,
    ECall,
    EBreak,
    Udf {
        trap_code: TrapCode,
    },
    Jalr {
        rd: WritableReg,
        base: Reg,
        offset: Imm12,
    },
    Atomic {
        op: AtomicOP,
        rd: WritableReg,
        addr: Reg,
        src: Reg,
        amo: AMO,
    },
    AtomicStore {
        src: Reg,
        ty: Type,
        p: Reg,
    },
    AtomicLoad {
        rd: WritableReg,
        ty: Type,
        p: Reg,
    },
    AtomicRmwLoop {
        offset: Reg,
        op: AtomicRmwOp,
        dst: WritableReg,
        ty: Type,
        p: Reg,
        x: Reg,
        t0: WritableReg,
    },
    Fcmp {
        cc: FloatCC,
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        ty: Type,
    },
    Select {
        dst: VecWritableReg,
        ty: Type,
        condition: Reg,
        x: ValueRegs,
        y: ValueRegs,
    },
    ReferenceCheck {
        rd: WritableReg,
        op: ReferenceCheckOP,
        x: Reg,
    },
    BrTable {
        index: Reg,
        tmp1: WritableReg,
        targets: VecBranchTarget,
    },
    AtomicCas {
        offset: Reg,
        t0: WritableReg,
        dst: WritableReg,
        e: Reg,
        addr: Reg,
        v: Reg,
        ty: Type,
    },
    IntSelect {
        op: IntSelectOP,
        dst: VecWritableReg,
        x: ValueRegs,
        y: ValueRegs,
        ty: Type,
    },
    Csr {
        csr_op: CsrOP,
        rd: WritableReg,
        rs: OptionReg,
        imm: OptionUimm5,
        csr: CsrAddress,
    },
    Icmp {
        cc: IntCC,
        rd: WritableReg,
        a: ValueRegs,
        b: ValueRegs,
        ty: Type,
    },
    SelectReg {
        rd: WritableReg,
        rs1: Reg,
        rs2: Reg,
        condition: IntegerCompare,
    },
    FcvtToInt {
        is_sat: bool,
        rd: WritableReg,
        tmp: WritableReg,
        rs: Reg,
        is_signed: bool,
        in_type: Type,
        out_type: Type,
    },
    SelectIf {
        if_spectre_guard: bool,
        rd: VecWritableReg,
        test: Reg,
        x: ValueRegs,
        y: ValueRegs,
    },
    RawData {
        data: VecU8,
    },
    Unwind {
        inst: UnwindInst,
    },
    DummyUse {
        reg: Reg,
    },
    FloatRound {
        op: FloatRoundOP,
        rd: WritableReg,
        int_tmp: WritableReg,
        f_tmp: WritableReg,
        rs: Reg,
        ty: Type,
    },
    FloatSelect {
        op: FloatSelectOP,
        rd: WritableReg,
        tmp: WritableReg,
        rs1: Reg,
        rs2: Reg,
        ty: Type,
    },
    FloatSelectPseudo {
        op: FloatSelectOP,
        rd: WritableReg,
        tmp: WritableReg,
        rs1: Reg,
        rs2: Reg,
        ty: Type,
    },
    Popcnt {
        sum: WritableReg,
        step: WritableReg,
        tmp: WritableReg,
        rs: Reg,
        ty: Type,
    },
    Cltz {
        leading: bool,
        sum: WritableReg,
        step: WritableReg,
        tmp: WritableReg,
        rs: Reg,
        ty: Type,
    },
    Rev8 {
        rs: Reg,
        step: WritableReg,
        tmp: WritableReg,
        rd: WritableReg,
    },
    Brev8 {
        rs: Reg,
        ty: Type,
        step: WritableReg,
        tmp: WritableReg,
        tmp2: WritableReg,
        rd: WritableReg,
    },
    StackProbeLoop {
        guard_size: u32,
        probe_count: u32,
        tmp: WritableReg,
    },
}

/// Internal type FloatSelectOP: defined at src/isa/riscv64/inst.isle line 359.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FloatSelectOP {
    Max,
    Min,
}

/// Internal type FloatRoundOP: defined at src/isa/riscv64/inst.isle line 364.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FloatRoundOP {
    Nearest,
    Ceil,
    Floor,
    Trunc,
}

/// Internal type CsrOP: defined at src/isa/riscv64/inst.isle line 371.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum CsrOP {
    Csrrw,
    Csrrs,
    Csrrc,
    Csrrwi,
    Csrrsi,
    Csrrci,
}

/// Internal type IntSelectOP: defined at src/isa/riscv64/inst.isle line 380.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum IntSelectOP {
    Smax,
    Umax,
    Smin,
    Umin,
}

/// Internal type ReferenceCheckOP: defined at src/isa/riscv64/inst.isle line 387.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum ReferenceCheckOP {
    IsNull,
    IsInvalid,
}

/// Internal type AtomicOP: defined at src/isa/riscv64/inst.isle line 392.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AtomicOP {
    LrW,
    ScW,
    AmoswapW,
    AmoaddW,
    AmoxorW,
    AmoandW,
    AmoorW,
    AmominW,
    AmomaxW,
    AmominuW,
    AmomaxuW,
    LrD,
    ScD,
    AmoswapD,
    AmoaddD,
    AmoxorD,
    AmoandD,
    AmoorD,
    AmominD,
    AmomaxD,
    AmominuD,
    AmomaxuD,
}

/// Internal type FpuOPRRRR: defined at src/isa/riscv64/inst.isle line 417.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuOPRRRR {
    FmaddS,
    FmsubS,
    FnmsubS,
    FnmaddS,
    FmaddD,
    FmsubD,
    FnmsubD,
    FnmaddD,
}

/// Internal type FClassResult: defined at src/isa/riscv64/inst.isle line 430.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FClassResult {
    NegInfinite,
    NegNormal,
    NegSubNormal,
    NegZero,
    PosZero,
    PosSubNormal,
    PosNormal,
    PosInfinite,
    SNaN,
    QNaN,
}

/// Internal type FpuOPRR: defined at src/isa/riscv64/inst.isle line 453.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuOPRR {
    FsqrtS,
    FcvtWS,
    FcvtWuS,
    FmvXW,
    FclassS,
    FcvtSw,
    FcvtSwU,
    FmvWX,
    FcvtLS,
    FcvtLuS,
    FcvtSL,
    FcvtSLU,
    FcvtLD,
    FcvtLuD,
    FmvXD,
    FcvtDL,
    FcvtDLu,
    FmvDX,
    FsqrtD,
    FcvtSD,
    FcvtDS,
    FclassD,
    FcvtWD,
    FcvtWuD,
    FcvtDW,
    FcvtDWU,
}

/// Internal type LoadOP: defined at src/isa/riscv64/inst.isle line 493.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum LoadOP {
    Lb,
    Lh,
    Lw,
    Lbu,
    Lhu,
    Lwu,
    Ld,
    Flw,
    Fld,
}

/// Internal type StoreOP: defined at src/isa/riscv64/inst.isle line 505.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum StoreOP {
    Sb,
    Sh,
    Sw,
    Sd,
    Fsw,
    Fsd,
}

/// Internal type AluOPRRR: defined at src/isa/riscv64/inst.isle line 514.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRR {
    Add,
    Sub,
    Sll,
    Slt,
    SltU,
    Sgt,
    Sgtu,
    Xor,
    Srl,
    Sra,
    Or,
    And,
    Addw,
    Subw,
    Sllw,
    Srlw,
    Sraw,
    Mul,
    Mulh,
    Mulhsu,
    Mulhu,
    Div,
    DivU,
    Rem,
    RemU,
    Mulw,
    Divw,
    Divuw,
    Remw,
    Remuw,
    Adduw,
    Andn,
    Bclr,
    Bext,
    Binv,
    Bset,
    Clmul,
    Clmulh,
    Clmulr,
    Max,
    Maxu,
    Min,
    Minu,
    Orn,
    Rol,
    Rolw,
    Ror,
    Rorw,
    Sh1add,
    Sh1adduw,
    Sh2add,
    Sh2adduw,
    Sh3add,
    Sh3adduw,
    Xnor,
}

/// Internal type FpuOPRRR: defined at src/isa/riscv64/inst.isle line 584.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FpuOPRRR {
    FaddS,
    FsubS,
    FmulS,
    FdivS,
    FsgnjS,
    FsgnjnS,
    FsgnjxS,
    FminS,
    FmaxS,
    FeqS,
    FltS,
    FleS,
    FaddD,
    FsubD,
    FmulD,
    FdivD,
    FsgnjD,
    FsgnjnD,
    FsgnjxD,
    FminD,
    FmaxD,
    FeqD,
    FltD,
    FleD,
}

/// Internal type AluOPRRI: defined at src/isa/riscv64/inst.isle line 617.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum AluOPRRI {
    Addi,
    Slti,
    SltiU,
    Xori,
    Ori,
    Andi,
    Slli,
    Srli,
    Srai,
    Addiw,
    Slliw,
    SrliW,
    Sraiw,
    Bclri,
    Bexti,
    Binvi,
    Bseti,
    Rori,
    Roriw,
    SlliUw,
    Clz,
    Clzw,
    Cpop,
    Cpopw,
    Ctz,
    Ctzw,
    Rev8,
    Sextb,
    Sexth,
    Zexth,
    Orcb,
    Brev8,
}

/// Internal type FRM: defined at src/isa/riscv64/inst.isle line 653.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FRM {
    RNE,
    RTZ,
    RDN,
    RUP,
    RMM,
    Fcsr,
}

/// Internal type FFlagsException: defined at src/isa/riscv64/inst.isle line 669.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FFlagsException {
    NV,
    DZ,
    OF,
    UF,
    NX,
}

/// Internal type FenceFm: defined at src/isa/riscv64/inst.isle line 688.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum FenceFm {
    None,
    Tso,
}

// Generated as internal constructor for term output_reg.
pub fn constructor_output_reg<C: Context>(ctx: &mut C, arg0: Reg) -> InstOutput {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 55.
    let expr0_0 = C::value_reg(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return expr1_0;
}

// Generated as internal constructor for term output_value.
pub fn constructor_output_value<C: Context>(ctx: &mut C, arg0: Value) -> InstOutput {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 59.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0 = C::output(ctx, expr0_0);
    return expr1_0;
}

// Generated as internal constructor for term temp_reg.
pub fn constructor_temp_reg<C: Context>(ctx: &mut C, arg0: Type) -> Reg {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 79.
    let expr0_0 = C::temp_writable_reg(ctx, pattern0_0);
    let expr1_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr1_0;
}

// Generated as internal constructor for term value_regs_range.
pub fn constructor_value_regs_range<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Range {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 128.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_len(ctx, pattern0_0);
    let expr2_0 = C::range(ctx, expr0_0, expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term lo_reg.
pub fn constructor_lo_reg<C: Context>(ctx: &mut C, arg0: Value) -> Reg {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 139.
    let expr0_0 = C::put_in_regs(ctx, pattern0_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term emit_side_effect.
pub fn constructor_emit_side_effect<C: Context>(ctx: &mut C, arg0: &SideEffectNoResult) -> Unit {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            // Rule at src/prelude_lower.isle line 292.
            let expr0_0 = C::emit(ctx, pattern1_0);
            return expr0_0;
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 294.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            return expr1_0;
        }
        &SideEffectNoResult::Inst3 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
            inst3: ref pattern1_2,
        } => {
            // Rule at src/prelude_lower.isle line 297.
            let expr0_0 = C::emit(ctx, pattern1_0);
            let expr1_0 = C::emit(ctx, pattern1_1);
            let expr2_0 = C::emit(ctx, pattern1_2);
            return expr2_0;
        }
        _ => {}
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "emit_side_effect", "src/prelude_lower.isle line 291"
    );
}

// Generated as internal constructor for term side_effect.
pub fn constructor_side_effect<C: Context>(ctx: &mut C, arg0: &SideEffectNoResult) -> InstOutput {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 305.
    let expr0_0 = constructor_emit_side_effect(ctx, pattern0_0);
    let expr1_0 = C::output_none(ctx);
    return expr1_0;
}

// Generated as internal constructor for term side_effect_concat.
pub fn constructor_side_effect_concat<C: Context>(
    ctx: &mut C,
    arg0: &SideEffectNoResult,
    arg1: &SideEffectNoResult,
) -> SideEffectNoResult {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &SideEffectNoResult::Inst {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &SideEffectNoResult::Inst {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 310.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                    };
                    return expr0_0;
                }
                &SideEffectNoResult::Inst2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 312.
                    let expr0_0 = SideEffectNoResult::Inst3 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                        inst3: pattern3_1.clone(),
                    };
                    return expr0_0;
                }
                _ => {}
            }
        }
        &SideEffectNoResult::Inst2 {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &SideEffectNoResult::Inst {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 314.
                let expr0_0 = SideEffectNoResult::Inst3 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern1_1.clone(),
                    inst3: pattern3_0.clone(),
                };
                return expr0_0;
            }
        }
        _ => {}
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "side_effect_concat", "src/prelude_lower.isle line 309"
    );
}

// Generated as internal constructor for term produces_flags_append.
pub fn constructor_produces_flags_append<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &MInst,
) -> ProducesFlags {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsSideEffect {
        inst: ref pattern1_0,
    } = pattern0_0
    {
        let pattern2_0 = arg1;
        // Rule at src/prelude_lower.isle line 339.
        let expr0_0 = ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: pattern1_0.clone(),
            inst2: pattern2_0.clone(),
        };
        return expr0_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "produces_flags_append", "src/prelude_lower.isle line 338"
    );
}

// Generated as internal constructor for term produces_flags_get_reg.
pub fn constructor_produces_flags_get_reg<C: Context>(ctx: &mut C, arg0: &ProducesFlags) -> Reg {
    let pattern0_0 = arg0;
    if let &ProducesFlags::ProducesFlagsReturnsReg {
        inst: ref pattern1_0,
        result: pattern1_1,
    } = pattern0_0
    {
        // Rule at src/prelude_lower.isle line 364.
        return pattern1_1;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "produces_flags_get_reg", "src/prelude_lower.isle line 363"
    );
}

// Generated as internal constructor for term produces_flags_ignore.
pub fn constructor_produces_flags_ignore<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
) -> ProducesFlags {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 369.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return expr0_0;
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            // Rule at src/prelude_lower.isle line 371.
            let expr0_0 = ProducesFlags::ProducesFlagsSideEffect {
                inst: pattern1_0.clone(),
            };
            return expr0_0;
        }
        _ => {}
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "produces_flags_ignore", "src/prelude_lower.isle line 368"
    );
}

// Generated as internal constructor for term consumes_flags_concat.
pub fn constructor_consumes_flags_concat<C: Context>(
    ctx: &mut C,
    arg0: &ConsumesFlags,
    arg1: &ConsumesFlags,
) -> ConsumesFlags {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ConsumesFlags::ConsumesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 384.
                let expr0_0 = ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern3_0.clone(),
                };
                return expr0_0;
            }
        }
        &ConsumesFlags::ConsumesFlagsReturnsReg {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsReturnsReg {
                inst: ref pattern3_0,
                result: pattern3_1,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 378.
                let expr0_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                let expr1_0 = ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: pattern1_0.clone(),
                    inst2: pattern3_0.clone(),
                    result: expr0_0,
                };
                return expr1_0;
            }
        }
        _ => {}
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "consumes_flags_concat", "src/prelude_lower.isle line 377"
    );
}

// Generated as internal constructor for term with_flags.
pub fn constructor_with_flags<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> ValueRegs {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 415.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern3_1);
                    return expr2_0;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src/prelude_lower.isle line 421.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    return pattern3_2;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src/prelude_lower.isle line 433.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::emit(ctx, pattern3_1);
                    let expr3_0 = C::emit(ctx, pattern3_2);
                    let expr4_0 = C::emit(ctx, pattern3_3);
                    return pattern3_4;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsReturnsResultWithConsumer {
            inst: ref pattern1_0,
            result: pattern1_1,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 409.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_reg(ctx, pattern1_1);
                    return expr2_0;
                }
                &ConsumesFlags::ConsumesFlagsReturnsResultWithProducer {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 401.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern3_0);
                    let expr2_0 = C::value_regs(ctx, pattern1_1, pattern3_1);
                    return expr2_0;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsReturnsReg {
                    inst: ref pattern3_0,
                    result: pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 449.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::value_reg(ctx, pattern3_1);
                    return expr3_0;
                }
                &ConsumesFlags::ConsumesFlagsTwiceReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    result: pattern3_2,
                } => {
                    // Rule at src/prelude_lower.isle line 456.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::emit(ctx, pattern3_1);
                    return pattern3_2;
                }
                &ConsumesFlags::ConsumesFlagsFourTimesReturnsValueRegs {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                    inst3: ref pattern3_2,
                    inst4: ref pattern3_3,
                    result: pattern3_4,
                } => {
                    // Rule at src/prelude_lower.isle line 469.
                    let expr0_0 = C::emit(ctx, pattern1_0);
                    let expr1_0 = C::emit(ctx, pattern1_1);
                    let expr2_0 = C::emit(ctx, pattern3_0);
                    let expr3_0 = C::emit(ctx, pattern3_1);
                    let expr4_0 = C::emit(ctx, pattern3_2);
                    let expr5_0 = C::emit(ctx, pattern3_3);
                    return pattern3_4;
                }
                _ => {}
            }
        }
        _ => {}
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "with_flags", "src/prelude_lower.isle line 399"
    );
}

// Generated as internal constructor for term with_flags_reg.
pub fn constructor_with_flags_reg<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/prelude_lower.isle line 487.
    let expr0_0 = constructor_with_flags(ctx, pattern0_0, pattern1_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term flags_to_producesflags.
pub fn constructor_flags_to_producesflags<C: Context>(ctx: &mut C, arg0: Value) -> ProducesFlags {
    let pattern0_0 = arg0;
    // Rule at src/prelude_lower.isle line 494.
    let expr0_0 = C::mark_value_used(ctx, pattern0_0);
    let expr1_0 = ProducesFlags::AlreadyExistingFlags;
    return expr1_0;
}

// Generated as internal constructor for term with_flags_side_effect.
pub fn constructor_with_flags_side_effect<C: Context>(
    ctx: &mut C,
    arg0: &ProducesFlags,
    arg1: &ConsumesFlags,
) -> SideEffectNoResult {
    let pattern0_0 = arg0;
    match pattern0_0 {
        &ProducesFlags::AlreadyExistingFlags => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 505.
                    let expr0_0 = SideEffectNoResult::Inst {
                        inst: pattern3_0.clone(),
                    };
                    return expr0_0;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 510.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern3_0.clone(),
                        inst2: pattern3_1.clone(),
                    };
                    return expr0_0;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsSideEffect {
            inst: ref pattern1_0,
        } => {
            let pattern2_0 = arg1;
            match pattern2_0 {
                &ConsumesFlags::ConsumesFlagsSideEffect {
                    inst: ref pattern3_0,
                } => {
                    // Rule at src/prelude_lower.isle line 515.
                    let expr0_0 = SideEffectNoResult::Inst2 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                    };
                    return expr0_0;
                }
                &ConsumesFlags::ConsumesFlagsSideEffect2 {
                    inst1: ref pattern3_0,
                    inst2: ref pattern3_1,
                } => {
                    // Rule at src/prelude_lower.isle line 520.
                    let expr0_0 = SideEffectNoResult::Inst3 {
                        inst1: pattern1_0.clone(),
                        inst2: pattern3_0.clone(),
                        inst3: pattern3_1.clone(),
                    };
                    return expr0_0;
                }
                _ => {}
            }
        }
        &ProducesFlags::ProducesFlagsTwiceSideEffect {
            inst1: ref pattern1_0,
            inst2: ref pattern1_1,
        } => {
            let pattern2_0 = arg1;
            if let &ConsumesFlags::ConsumesFlagsSideEffect {
                inst: ref pattern3_0,
            } = pattern2_0
            {
                // Rule at src/prelude_lower.isle line 525.
                let expr0_0 = SideEffectNoResult::Inst3 {
                    inst1: pattern1_0.clone(),
                    inst2: pattern1_1.clone(),
                    inst3: pattern3_0.clone(),
                };
                return expr0_0;
            }
        }
        _ => {}
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "with_flags_side_effect", "src/prelude_lower.isle line 503"
    );
}

// Generated as internal constructor for term lower_return.
pub fn constructor_lower_return<C: Context>(
    ctx: &mut C,
    arg0: Range,
    arg1: ValueSlice,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/prelude_lower.isle line 705.
    let expr0_0 = C::gen_return(ctx, pattern1_0);
    let expr1_0 = C::output_none(ctx);
    return expr1_0;
}

// Generated as internal constructor for term value_regs_zero.
pub fn constructor_value_regs_zero<C: Context>(ctx: &mut C) -> ValueRegs {
    // Rule at src/isa/riscv64/inst.isle line 718.
    let expr0_0: Type = I64;
    let expr1_0: u64 = 0i128 as u64;
    let expr2_0 = C::imm(ctx, expr0_0, expr1_0);
    let expr3_0: Type = I64;
    let expr4_0: u64 = 0i128 as u64;
    let expr5_0 = C::imm(ctx, expr3_0, expr4_0);
    let expr6_0 = C::value_regs(ctx, expr2_0, expr5_0);
    return expr6_0;
}

// Generated as internal constructor for term gen_float_round.
pub fn constructor_gen_float_round<C: Context>(
    ctx: &mut C,
    arg0: &FloatRoundOP,
    arg1: Reg,
    arg2: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 723.
    let expr0_0 = C::temp_writable_reg(ctx, pattern2_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0: Type = F64;
    let expr4_0 = C::temp_writable_reg(ctx, expr3_0);
    let expr5_0 = MInst::FloatRound {
        op: pattern0_0.clone(),
        rd: expr0_0,
        int_tmp: expr2_0,
        f_tmp: expr4_0,
        rs: pattern1_0,
        ty: pattern2_0,
    };
    let expr6_0 = C::emit(ctx, &expr5_0);
    let expr7_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr7_0;
}

// Generated as internal constructor for term gen_float_select_pseudo.
pub fn constructor_gen_float_select_pseudo<C: Context>(
    ctx: &mut C,
    arg0: &FloatSelectOP,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 733.
    let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0 = MInst::FloatSelectPseudo {
        op: pattern0_0.clone(),
        rd: expr0_0,
        tmp: expr2_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
        ty: pattern3_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr5_0;
}

// Generated as internal constructor for term gen_float_select.
pub fn constructor_gen_float_select<C: Context>(
    ctx: &mut C,
    arg0: &FloatSelectOP,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 742.
    let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0 = MInst::FloatSelect {
        op: pattern0_0.clone(),
        rd: expr0_0,
        tmp: expr2_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
        ty: pattern3_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr5_0;
}

// Generated as internal constructor for term fpu_rr.
pub fn constructor_fpu_rr<C: Context>(ctx: &mut C, arg0: &FpuOPRR, arg1: Type, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 771.
    let expr0_0 = C::temp_writable_reg(ctx, pattern1_0);
    let expr1_0 = C::gen_default_frm(ctx);
    let expr2_0 = MInst::FpuRR {
        alu_op: pattern0_0.clone(),
        frm: expr1_0,
        rd: expr0_0,
        rs: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr4_0;
}

// Generated as internal constructor for term alu_rrr.
pub fn constructor_alu_rrr<C: Context>(ctx: &mut C, arg0: &AluOPRRR, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 778.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRR {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs1: pattern1_0,
        rs2: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term alu_add.
pub fn constructor_alu_add<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 786.
    let expr0_0 = AluOPRRR::Add;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
    return expr1_0;
}

// Generated as internal constructor for term alu_and.
pub fn constructor_alu_and<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 791.
    let expr0_0 = AluOPRRR::And;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
    return expr1_0;
}

// Generated as internal constructor for term alu_sub.
pub fn constructor_alu_sub<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 798.
    let expr0_0 = AluOPRRR::Sub;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
    return expr1_0;
}

// Generated as internal constructor for term fpu_rrr.
pub fn constructor_fpu_rrr<C: Context>(
    ctx: &mut C,
    arg0: &FpuOPRRR,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 806.
    let expr0_0 = C::temp_writable_reg(ctx, pattern1_0);
    let expr1_0 = C::gen_default_frm(ctx);
    let expr2_0 = MInst::FpuRRR {
        alu_op: pattern0_0.clone(),
        frm: expr1_0,
        rd: expr0_0,
        rs1: pattern2_0,
        rs2: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr4_0;
}

// Generated as internal constructor for term fpu_rrrr.
pub fn constructor_fpu_rrrr<C: Context>(
    ctx: &mut C,
    arg0: &FpuOPRRRR,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
    arg4: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 814.
    let expr0_0 = C::temp_writable_reg(ctx, pattern1_0);
    let expr1_0 = C::gen_default_frm(ctx);
    let expr2_0 = MInst::FpuRRRR {
        alu_op: pattern0_0.clone(),
        frm: expr1_0,
        rd: expr0_0,
        rs1: pattern2_0,
        rs2: pattern3_0,
        rs3: pattern4_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr4_0;
}

// Generated as internal constructor for term alu_rr_imm12.
pub fn constructor_alu_rr_imm12<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRI,
    arg1: Reg,
    arg2: Imm12,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 822.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AluRRImm12 {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs: pattern1_0,
        imm12: pattern2_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term alu_andi.
pub fn constructor_alu_andi<C: Context>(ctx: &mut C, arg0: Reg, arg1: i32) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 828.
    let expr0_0 = AluOPRRI::Andi;
    let expr1_0 = C::imm12_const(ctx, pattern1_0);
    let expr2_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term alu_slli.
pub fn constructor_alu_slli<C: Context>(ctx: &mut C, arg0: Reg, arg1: i32) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 833.
    let expr0_0 = AluOPRRI::Slli;
    let expr1_0 = C::imm12_const(ctx, pattern1_0);
    let expr2_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term alu_srli.
pub fn constructor_alu_srli<C: Context>(ctx: &mut C, arg0: Reg, arg1: i32) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 836.
    let expr0_0 = AluOPRRI::Srli;
    let expr1_0 = C::imm12_const(ctx, pattern1_0);
    let expr2_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term alu_rr_funct12.
pub fn constructor_alu_rr_funct12<C: Context>(ctx: &mut C, arg0: &AluOPRRI, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 842.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = constructor_imm12_zero(ctx);
    let expr3_0 = MInst::AluRRImm12 {
        alu_op: pattern0_0.clone(),
        rd: expr1_0,
        rs: pattern1_0,
        imm12: expr2_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr5_0;
}

// Generated as internal constructor for term ext_int_if_need.
pub fn constructor_ext_int_if_need<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: ValueRegs,
    arg2: Type,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 856.
        return pattern1_0;
    }
    if pattern2_0 == I128 {
        // Rule at src/isa/riscv64/inst.isle line 859.
        return pattern1_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 850.
    let expr0_0 = constructor_convert_valueregs_reg(ctx, pattern1_0);
    let expr1_0 = C::ty_bits(ctx, pattern2_0);
    let expr2_0: u8 = 64i128 as u8;
    let expr3_0 = constructor_gen_extend(ctx, expr0_0, pattern0_0, expr1_0, expr2_0);
    let expr4_0 = C::value_reg(ctx, expr3_0);
    return expr4_0;
}

// Generated as internal constructor for term select_addi.
pub fn constructor_select_addi<C: Context>(ctx: &mut C, arg0: Type) -> AluOPRRI {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_32(ctx, pattern0_0) {
        // Rule at src/isa/riscv64/inst.isle line 875.
        let expr0_0 = AluOPRRI::Addiw;
        return expr0_0;
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        // Rule at src/isa/riscv64/inst.isle line 876.
        let expr0_0 = AluOPRRI::Addi;
        return expr0_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "select_addi", "src/isa/riscv64/inst.isle line 874"
    );
}

// Generated as internal constructor for term bnot_128.
pub fn constructor_bnot_128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> ValueRegs {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 881.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern0_0, expr0_0);
    let expr2_0 = constructor_gen_bit_not(ctx, expr1_0);
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, pattern0_0, expr3_0);
    let expr5_0 = constructor_gen_bit_not(ctx, expr4_0);
    let expr6_0 = C::value_regs(ctx, expr2_0, expr5_0);
    return expr6_0;
}

// Generated as internal constructor for term lower_bit_reverse.
pub fn constructor_lower_bit_reverse<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == I8 {
        // Rule at src/isa/riscv64/inst.isle line 892.
        let expr0_0: Type = I8;
        let expr1_0 = constructor_gen_brev8(ctx, pattern0_0, expr0_0);
        return expr1_0;
    }
    if pattern1_0 == I16 {
        // Rule at src/isa/riscv64/inst.isle line 896.
        let expr0_0: Type = I16;
        let expr1_0 = constructor_gen_brev8(ctx, pattern0_0, expr0_0);
        let expr2_0 = constructor_gen_rev8(ctx, expr1_0);
        let expr3_0 = AluOPRRI::Srli;
        let expr4_0: i32 = 48i128 as i32;
        let expr5_0 = C::imm12_const(ctx, expr4_0);
        let expr6_0 = constructor_alu_rr_imm12(ctx, &expr3_0, expr2_0, expr5_0);
        return expr6_0;
    }
    if pattern1_0 == I32 {
        // Rule at src/isa/riscv64/inst.isle line 904.
        let expr0_0: Type = I32;
        let expr1_0 = constructor_gen_brev8(ctx, pattern0_0, expr0_0);
        let expr2_0 = constructor_gen_rev8(ctx, expr1_0);
        let expr3_0 = AluOPRRI::Srli;
        let expr4_0: i32 = 32i128 as i32;
        let expr5_0 = C::imm12_const(ctx, expr4_0);
        let expr6_0 = constructor_alu_rr_imm12(ctx, &expr3_0, expr2_0, expr5_0);
        return expr6_0;
    }
    if pattern1_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 912.
        let expr0_0 = constructor_gen_rev8(ctx, pattern0_0);
        let expr1_0: Type = I64;
        let expr2_0 = constructor_gen_brev8(ctx, expr0_0, expr1_0);
        return expr2_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_bit_reverse", "src/isa/riscv64/inst.isle line 889"
    );
}

// Generated as internal constructor for term imm12_zero.
pub fn constructor_imm12_zero<C: Context>(ctx: &mut C) -> Imm12 {
    // Rule at src/isa/riscv64/inst.isle line 920.
    let expr0_0: i32 = 0i128 as i32;
    let expr1_0 = C::imm12_const(ctx, expr0_0);
    return expr1_0;
}

// Generated as internal constructor for term lower_ctz.
pub fn constructor_lower_ctz<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 934.
                let expr0_0 = AluOPRRI::Ctzw;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0);
                return expr1_0;
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 929.
                let expr0_0 = AluOPRRI::Ctz;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0);
                return expr1_0;
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 939.
            let expr0_0 = AluOPRRI::Bseti;
            let expr1_0 = C::ty_bits(ctx, pattern0_0);
            let expr2_0 = C::u8_as_i32(ctx, expr1_0);
            let expr3_0 = C::imm12_const(ctx, expr2_0);
            let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern1_0, expr3_0);
            let expr5_0 = AluOPRRI::Ctzw;
            let expr6_0 = constructor_alu_rr_funct12(ctx, &expr5_0, pattern1_0);
            return expr6_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 925.
            let expr0_0: bool = false;
            let expr1_0 = constructor_gen_cltz(ctx, expr0_0, pattern1_0, pattern0_0);
            return expr1_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_ctz", "src/isa/riscv64/inst.isle line 923"
    );
}

// Generated as internal constructor for term lower_ctz_128.
pub fn constructor_lower_ctz_128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> ValueRegs {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 949.
    let expr0_0: Type = I64;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0 = constructor_lower_ctz(ctx, expr0_0, expr2_0);
    let expr4_0: Type = I64;
    let expr5_0: usize = 1i128 as usize;
    let expr6_0 = C::value_regs_get(ctx, pattern0_0, expr5_0);
    let expr7_0 = constructor_lower_ctz(ctx, expr4_0, expr6_0);
    let expr8_0: u64 = 64i128 as u64;
    let expr9_0 = C::load_u64_constant(ctx, expr8_0);
    let expr10_0 = IntCC::Equal;
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr10_0, expr9_0, expr3_0, expr7_0, expr11_0);
    let expr13_0 = constructor_alu_add(ctx, expr3_0, expr12_0);
    let expr14_0: u64 = 0i128 as u64;
    let expr15_0 = C::load_u64_constant(ctx, expr14_0);
    let expr16_0 = C::value_regs(ctx, expr13_0, expr15_0);
    return expr16_0;
}

// Generated as internal constructor for term lower_clz.
pub fn constructor_lower_clz<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 978.
                let expr0_0 = AluOPRRI::Clzw;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0);
                return expr1_0;
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let mut closure3 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern3_0) = closure3() {
            if pattern3_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 974.
                let expr0_0 = AluOPRRI::Clz;
                let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern2_0);
                return expr1_0;
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 984.
            let expr0_0: bool = false;
            let expr1_0 = C::value_reg(ctx, pattern1_0);
            let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern0_0);
            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
            let expr4_0 = AluOPRRI::Clz;
            let expr5_0 = constructor_alu_rr_funct12(ctx, &expr4_0, expr3_0);
            let expr6_0 = AluOPRRI::Addi;
            let expr7_0 = C::ty_bits(ctx, pattern0_0);
            let expr8_0 = C::u8_as_i32(ctx, expr7_0);
            let expr9_0: i32 = -64i128 as i32;
            let expr10_0 = C::imm12_const_add(ctx, expr8_0, expr9_0);
            let expr11_0 = constructor_alu_rr_imm12(ctx, &expr6_0, expr5_0, expr10_0);
            return expr11_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 971.
            let expr0_0: bool = true;
            let expr1_0 = constructor_gen_cltz(ctx, expr0_0, pattern1_0, pattern0_0);
            return expr1_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_clz", "src/isa/riscv64/inst.isle line 969"
    );
}

// Generated as internal constructor for term lower_clz_i128.
pub fn constructor_lower_clz_i128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> ValueRegs {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1006.
    let expr0_0: Type = I64;
    let expr1_0: usize = 1i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0 = constructor_lower_clz(ctx, expr0_0, expr2_0);
    let expr4_0: Type = I64;
    let expr5_0: usize = 0i128 as usize;
    let expr6_0 = C::value_regs_get(ctx, pattern0_0, expr5_0);
    let expr7_0 = constructor_lower_clz(ctx, expr4_0, expr6_0);
    let expr8_0: u64 = 64i128 as u64;
    let expr9_0 = C::load_u64_constant(ctx, expr8_0);
    let expr10_0 = IntCC::Equal;
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr10_0, expr9_0, expr3_0, expr7_0, expr11_0);
    let expr13_0 = constructor_alu_add(ctx, expr3_0, expr12_0);
    let expr14_0: u64 = 0i128 as u64;
    let expr15_0 = C::load_u64_constant(ctx, expr14_0);
    let expr16_0 = C::value_regs(ctx, expr13_0, expr15_0);
    return expr16_0;
}

// Generated as internal constructor for term gen_extend.
pub fn constructor_gen_extend<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: bool,
    arg2: u8,
    arg3: u8,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1021.
    let expr0_0: Type = I16;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::Extend {
        rd: expr1_0,
        rn: pattern0_0,
        signed: pattern1_0,
        from_bits: pattern2_0,
        to_bits: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term lower_extend.
pub fn constructor_lower_extend<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: bool,
    arg2: u8,
    arg3: u8,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == true {
        let pattern3_0 = arg2;
        if pattern3_0 == 64i128 as u8 {
            let pattern5_0 = arg3;
            if pattern5_0 == 128i128 as u8 {
                // Rule at src/isa/riscv64/inst.isle line 1034.
                let expr0_0 = AluOPRRR::Slt;
                let expr1_0 = C::zero_reg(ctx);
                let expr2_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, expr1_0);
                let expr3_0: bool = true;
                let expr4_0: u8 = 1i128 as u8;
                let expr5_0: u8 = 64i128 as u8;
                let expr6_0 = constructor_gen_extend(ctx, expr2_0, expr3_0, expr4_0, expr5_0);
                let expr7_0: Type = I64;
                let expr8_0: Type = I64;
                let expr9_0 = C::gen_move2(ctx, pattern0_0, expr7_0, expr8_0);
                let expr10_0 = C::value_regs(ctx, expr9_0, expr6_0);
                return expr10_0;
            }
        }
    }
    if pattern1_0 == false {
        let pattern3_0 = arg2;
        if pattern3_0 == 64i128 as u8 {
            let pattern5_0 = arg3;
            if pattern5_0 == 128i128 as u8 {
                // Rule at src/isa/riscv64/inst.isle line 1051.
                let expr0_0: Type = I64;
                let expr1_0: Type = I64;
                let expr2_0 = C::gen_move2(ctx, pattern0_0, expr0_0, expr1_0);
                let expr3_0: u64 = 0i128 as u64;
                let expr4_0 = C::load_u64_constant(ctx, expr3_0);
                let expr5_0 = C::value_regs(ctx, expr2_0, expr4_0);
                return expr5_0;
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if pattern1_0 == true {
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        if pattern4_0 == 128i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1042.
            let expr0_0: bool = true;
            let expr1_0: u8 = 64i128 as u8;
            let expr2_0 = constructor_gen_extend(ctx, pattern0_0, expr0_0, pattern3_0, expr1_0);
            let expr3_0 = AluOPRRR::Slt;
            let expr4_0 = C::zero_reg(ctx);
            let expr5_0 = constructor_alu_rrr(ctx, &expr3_0, expr2_0, expr4_0);
            let expr6_0: bool = true;
            let expr7_0: u8 = 1i128 as u8;
            let expr8_0: u8 = 64i128 as u8;
            let expr9_0 = constructor_gen_extend(ctx, expr5_0, expr6_0, expr7_0, expr8_0);
            let expr10_0: Type = I64;
            let expr11_0: Type = I64;
            let expr12_0 = C::gen_move2(ctx, pattern0_0, expr10_0, expr11_0);
            let expr13_0 = C::value_regs(ctx, expr12_0, expr9_0);
            return expr13_0;
        }
    }
    if pattern1_0 == false {
        let pattern3_0 = arg2;
        let pattern4_0 = arg3;
        if pattern4_0 == 128i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1056.
            let expr0_0: bool = false;
            let expr1_0: u8 = 64i128 as u8;
            let expr2_0 = constructor_gen_extend(ctx, pattern0_0, expr0_0, pattern3_0, expr1_0);
            let expr3_0: u64 = 0i128 as u64;
            let expr4_0 = C::load_u64_constant(ctx, expr3_0);
            let expr5_0 = C::value_regs(ctx, expr2_0, expr4_0);
            return expr5_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1029.
    let expr0_0 = constructor_gen_extend(ctx, pattern0_0, pattern1_0, pattern2_0, pattern3_0);
    let expr1_0 = C::value_reg(ctx, expr0_0);
    return expr1_0;
}

// Generated as internal constructor for term lower_b128_binary.
pub fn constructor_lower_b128_binary<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRR,
    arg1: ValueRegs,
    arg2: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1065.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern1_0, expr0_0);
    let expr2_0: usize = 0i128 as usize;
    let expr3_0 = C::value_regs_get(ctx, pattern2_0, expr2_0);
    let expr4_0 = constructor_alu_rrr(ctx, pattern0_0, expr1_0, expr3_0);
    let expr5_0: usize = 1i128 as usize;
    let expr6_0 = C::value_regs_get(ctx, pattern1_0, expr5_0);
    let expr7_0: usize = 1i128 as usize;
    let expr8_0 = C::value_regs_get(ctx, pattern2_0, expr7_0);
    let expr9_0 = constructor_alu_rrr(ctx, pattern0_0, expr6_0, expr8_0);
    let expr10_0 = C::value_regs(ctx, expr4_0, expr9_0);
    return expr10_0;
}

// Generated as internal constructor for term lower_umlhi.
pub fn constructor_lower_umlhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/riscv64/inst.isle line 1074.
        let expr0_0 = AluOPRRR::Mulhu;
        let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0);
        return expr1_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1079.
    let expr0_0 = AluOPRRR::Mul;
    let expr1_0: bool = false;
    let expr2_0 = C::value_reg(ctx, pattern1_0);
    let expr3_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern0_0);
    let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0);
    let expr5_0: bool = false;
    let expr6_0 = C::value_reg(ctx, pattern2_0);
    let expr7_0 = constructor_ext_int_if_need(ctx, expr5_0, expr6_0, pattern0_0);
    let expr8_0 = constructor_convert_valueregs_reg(ctx, expr7_0);
    let expr9_0 = constructor_alu_rrr(ctx, &expr0_0, expr4_0, expr8_0);
    let expr10_0 = AluOPRRI::Srli;
    let expr11_0 = C::ty_bits(ctx, pattern0_0);
    let expr12_0 = C::u8_as_i32(ctx, expr11_0);
    let expr13_0 = C::imm12_const(ctx, expr12_0);
    let expr14_0 = constructor_alu_rr_imm12(ctx, &expr10_0, expr9_0, expr13_0);
    return expr14_0;
}

// Generated as internal constructor for term lower_smlhi.
pub fn constructor_lower_smlhi<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        // Rule at src/isa/riscv64/inst.isle line 1085.
        let expr0_0 = AluOPRRR::Mulh;
        let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0);
        return expr1_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1090.
    let expr0_0 = AluOPRRR::Mul;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern1_0, pattern2_0);
    let expr2_0 = AluOPRRI::Srli;
    let expr3_0 = C::ty_bits(ctx, pattern0_0);
    let expr4_0 = C::u8_as_i32(ctx, expr3_0);
    let expr5_0 = C::imm12_const(ctx, expr4_0);
    let expr6_0 = constructor_alu_rr_imm12(ctx, &expr2_0, expr1_0, expr5_0);
    return expr6_0;
}

// Generated as internal constructor for term lower_rotl.
pub fn constructor_lower_rotl<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1112.
                let expr0_0 = AluOPRRR::Rolw;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1102.
                let expr0_0 = AluOPRRR::Rol;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1118.
                let expr0_0: Type = I32;
                let expr1_0 = constructor_lower_rotl_shift(ctx, expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1108.
                let expr0_0: Type = I64;
                let expr1_0 = constructor_lower_rotl_shift(ctx, expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1122.
    let expr0_0 = constructor_lower_rotl_shift(ctx, pattern0_0, pattern1_0, pattern2_0);
    return expr0_0;
}

// Generated as internal constructor for term lower_rotl_shift.
pub fn constructor_lower_rotl_shift<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1131.
    let expr0_0 = C::gen_shamt(ctx, pattern0_0, pattern2_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
    let expr5_0 = AluOPRRR::Sll;
    let expr6_0 = constructor_alu_rrr(ctx, &expr5_0, pattern1_0, expr2_0);
    let expr7_0 = AluOPRRR::Srl;
    let expr8_0 = constructor_alu_rrr(ctx, &expr7_0, pattern1_0, expr4_0);
    let expr9_0 = IntCC::Equal;
    let expr10_0 = C::zero_reg(ctx);
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr9_0, expr2_0, expr10_0, expr11_0, expr8_0);
    let expr13_0 = AluOPRRR::Or;
    let expr14_0 = constructor_alu_rrr(ctx, &expr13_0, expr6_0, expr12_0);
    return expr14_0;
}

// Generated as internal constructor for term lower_rotr.
pub fn constructor_lower_rotr<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1160.
                let expr0_0 = AluOPRRR::Rorw;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == true {
                // Rule at src/isa/riscv64/inst.isle line 1151.
                let expr0_0 = AluOPRRR::Ror;
                let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1166.
                let expr0_0: Type = I32;
                let expr1_0 = constructor_lower_rotr_shift(ctx, expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        let pattern3_0 = arg2;
        let mut closure4 = || {
            let expr0_0 = C::has_b(ctx);
            return Some(expr0_0);
        };
        if let Some(pattern4_0) = closure4() {
            if pattern4_0 == false {
                // Rule at src/isa/riscv64/inst.isle line 1156.
                let expr0_0: Type = I64;
                let expr1_0 = constructor_lower_rotr_shift(ctx, expr0_0, pattern2_0, pattern3_0);
                return expr1_0;
            }
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1170.
    let expr0_0 = constructor_lower_rotr_shift(ctx, pattern0_0, pattern1_0, pattern2_0);
    return expr0_0;
}

// Generated as internal constructor for term lower_rotr_shift.
pub fn constructor_lower_rotr_shift<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1178.
    let expr0_0 = C::gen_shamt(ctx, pattern0_0, pattern2_0);
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
    let expr3_0: usize = 1i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
    let expr5_0 = AluOPRRR::Srl;
    let expr6_0 = constructor_alu_rrr(ctx, &expr5_0, pattern1_0, expr2_0);
    let expr7_0 = AluOPRRR::Sll;
    let expr8_0 = constructor_alu_rrr(ctx, &expr7_0, pattern1_0, expr4_0);
    let expr9_0 = IntCC::Equal;
    let expr10_0 = C::zero_reg(ctx);
    let expr11_0 = C::zero_reg(ctx);
    let expr12_0 = C::gen_select_reg(ctx, &expr9_0, expr2_0, expr10_0, expr11_0, expr8_0);
    let expr13_0 = AluOPRRR::Or;
    let expr14_0 = constructor_alu_rrr(ctx, &expr13_0, expr6_0, expr12_0);
    return expr14_0;
}

// Generated as internal constructor for term lower_cls.
pub fn constructor_lower_cls<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1193.
    let expr0_0: bool = true;
    let expr1_0 = C::value_reg(ctx, pattern0_0);
    let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern1_0);
    let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
    let expr4_0 = IntCC::SignedLessThan;
    let expr5_0 = C::zero_reg(ctx);
    let expr6_0 = constructor_gen_bit_not(ctx, pattern0_0);
    let expr7_0 = C::gen_select_reg(ctx, &expr4_0, expr3_0, expr5_0, expr6_0, pattern0_0);
    let expr8_0 = constructor_lower_clz(ctx, pattern1_0, expr7_0);
    let expr9_0 = AluOPRRI::Addi;
    let expr10_0: i32 = -1i128 as i32;
    let expr11_0 = C::imm12_const(ctx, expr10_0);
    let expr12_0 = constructor_alu_rr_imm12(ctx, &expr9_0, expr8_0, expr11_0);
    return expr12_0;
}

// Generated as internal constructor for term gen_cltz.
pub fn constructor_gen_cltz<C: Context>(ctx: &mut C, arg0: bool, arg1: Reg, arg2: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1205.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
    let expr4_0: Type = I64;
    let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
    let expr6_0 = MInst::Cltz {
        leading: pattern0_0,
        sum: expr5_0,
        step: expr3_0,
        tmp: expr1_0,
        rs: pattern1_0,
        ty: pattern2_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_reg_to_reg(ctx, expr5_0);
    return expr8_0;
}

// Generated as internal constructor for term gen_popcnt.
pub fn constructor_gen_popcnt<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1215.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
    let expr4_0: Type = I64;
    let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
    let expr6_0 = MInst::Popcnt {
        sum: expr5_0,
        step: expr3_0,
        tmp: expr1_0,
        rs: pattern0_0,
        ty: pattern1_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_reg_to_reg(ctx, expr5_0);
    return expr8_0;
}

// Generated as internal constructor for term lower_popcnt.
pub fn constructor_lower_popcnt<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1224.
            let expr0_0 = AluOPRRI::Cpop;
            let expr1_0: bool = false;
            let expr2_0 = C::value_reg(ctx, pattern0_0);
            let expr3_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern1_0);
            let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0);
            let expr5_0 = constructor_alu_rr_funct12(ctx, &expr0_0, expr4_0);
            return expr5_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1227.
            let expr0_0 = constructor_gen_popcnt(ctx, pattern0_0, pattern1_0);
            return expr0_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_popcnt", "src/isa/riscv64/inst.isle line 1223"
    );
}

// Generated as internal constructor for term lower_popcnt_i128.
pub fn constructor_lower_popcnt_i128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> ValueRegs {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1233.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern0_0, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = constructor_lower_popcnt(ctx, expr1_0, expr2_0);
    let expr4_0: usize = 1i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, pattern0_0, expr4_0);
    let expr6_0: Type = I64;
    let expr7_0 = constructor_lower_popcnt(ctx, expr5_0, expr6_0);
    let expr8_0 = constructor_alu_add(ctx, expr3_0, expr7_0);
    let expr9_0: u64 = 0i128 as u64;
    let expr10_0 = C::load_u64_constant(ctx, expr9_0);
    let expr11_0 = C::value_regs(ctx, expr8_0, expr10_0);
    return expr11_0;
}

// Generated as internal constructor for term lower_i128_rotl.
pub fn constructor_lower_i128_rotl<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1245.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 0i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr5_0);
    let expr12_0 = AluOPRRR::Srl;
    let expr13_0: usize = 1i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern0_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr12_0, expr14_0, expr7_0);
    let expr16_0 = IntCC::Equal;
    let expr17_0 = C::zero_reg(ctx);
    let expr18_0 = C::zero_reg(ctx);
    let expr19_0 = C::gen_select_reg(ctx, &expr16_0, expr5_0, expr17_0, expr18_0, expr15_0);
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr11_0, expr19_0);
    let expr22_0 = AluOPRRR::Sll;
    let expr23_0: usize = 1i128 as usize;
    let expr24_0 = C::value_regs_get(ctx, pattern0_0, expr23_0);
    let expr25_0 = constructor_alu_rrr(ctx, &expr22_0, expr24_0, expr5_0);
    let expr26_0 = AluOPRRR::Srl;
    let expr27_0: usize = 0i128 as usize;
    let expr28_0 = C::value_regs_get(ctx, pattern0_0, expr27_0);
    let expr29_0 = constructor_alu_rrr(ctx, &expr26_0, expr28_0, expr7_0);
    let expr30_0 = IntCC::Equal;
    let expr31_0 = C::zero_reg(ctx);
    let expr32_0 = C::zero_reg(ctx);
    let expr33_0 = C::gen_select_reg(ctx, &expr30_0, expr5_0, expr31_0, expr32_0, expr29_0);
    let expr34_0 = AluOPRRR::Or;
    let expr35_0 = constructor_alu_rrr(ctx, &expr34_0, expr25_0, expr33_0);
    let expr36_0: u64 = 64i128 as u64;
    let expr37_0 = C::load_u64_constant(ctx, expr36_0);
    let expr38_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr39_0 = C::gen_select_reg(ctx, &expr38_0, expr5_0, expr37_0, expr35_0, expr21_0);
    let expr40_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr41_0 = C::gen_select_reg(ctx, &expr40_0, expr5_0, expr37_0, expr21_0, expr35_0);
    let expr42_0 = C::value_regs(ctx, expr39_0, expr41_0);
    return expr42_0;
}

// Generated as internal constructor for term lower_i128_rotr.
pub fn constructor_lower_i128_rotr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1273.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Srl;
    let expr9_0: usize = 0i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr5_0);
    let expr12_0 = AluOPRRR::Sll;
    let expr13_0: usize = 1i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern0_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr12_0, expr14_0, expr7_0);
    let expr16_0 = IntCC::Equal;
    let expr17_0 = C::zero_reg(ctx);
    let expr18_0 = C::zero_reg(ctx);
    let expr19_0 = C::gen_select_reg(ctx, &expr16_0, expr5_0, expr17_0, expr18_0, expr15_0);
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr11_0, expr19_0);
    let expr22_0 = AluOPRRR::Srl;
    let expr23_0: usize = 1i128 as usize;
    let expr24_0 = C::value_regs_get(ctx, pattern0_0, expr23_0);
    let expr25_0 = constructor_alu_rrr(ctx, &expr22_0, expr24_0, expr5_0);
    let expr26_0 = AluOPRRR::Sll;
    let expr27_0: usize = 0i128 as usize;
    let expr28_0 = C::value_regs_get(ctx, pattern0_0, expr27_0);
    let expr29_0 = constructor_alu_rrr(ctx, &expr26_0, expr28_0, expr7_0);
    let expr30_0 = IntCC::Equal;
    let expr31_0 = C::zero_reg(ctx);
    let expr32_0 = C::zero_reg(ctx);
    let expr33_0 = C::gen_select_reg(ctx, &expr30_0, expr5_0, expr31_0, expr32_0, expr29_0);
    let expr34_0 = AluOPRRR::Or;
    let expr35_0 = constructor_alu_rrr(ctx, &expr34_0, expr25_0, expr33_0);
    let expr36_0: u64 = 64i128 as u64;
    let expr37_0 = C::load_u64_constant(ctx, expr36_0);
    let expr38_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr39_0 = C::gen_select_reg(ctx, &expr38_0, expr5_0, expr37_0, expr35_0, expr21_0);
    let expr40_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr41_0 = C::gen_select_reg(ctx, &expr40_0, expr5_0, expr37_0, expr21_0, expr35_0);
    let expr42_0 = C::value_regs(ctx, expr39_0, expr41_0);
    return expr42_0;
}

// Generated as internal constructor for term lower_i128_ishl.
pub fn constructor_lower_i128_ishl<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1302.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 0i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr5_0);
    let expr12_0 = AluOPRRR::Srl;
    let expr13_0: usize = 0i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern0_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr12_0, expr14_0, expr7_0);
    let expr16_0 = IntCC::Equal;
    let expr17_0 = C::zero_reg(ctx);
    let expr18_0 = C::zero_reg(ctx);
    let expr19_0 = C::gen_select_reg(ctx, &expr16_0, expr5_0, expr17_0, expr18_0, expr15_0);
    let expr20_0 = AluOPRRR::Sll;
    let expr21_0: usize = 1i128 as usize;
    let expr22_0 = C::value_regs_get(ctx, pattern0_0, expr21_0);
    let expr23_0 = constructor_alu_rrr(ctx, &expr20_0, expr22_0, expr5_0);
    let expr24_0 = AluOPRRR::Or;
    let expr25_0 = constructor_alu_rrr(ctx, &expr24_0, expr19_0, expr23_0);
    let expr26_0: u64 = 64i128 as u64;
    let expr27_0 = C::load_u64_constant(ctx, expr26_0);
    let expr28_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr29_0 = C::zero_reg(ctx);
    let expr30_0 = C::gen_select_reg(ctx, &expr28_0, expr5_0, expr27_0, expr29_0, expr11_0);
    let expr31_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr32_0 = C::gen_select_reg(ctx, &expr31_0, expr5_0, expr27_0, expr11_0, expr25_0);
    let expr33_0 = C::value_regs(ctx, expr30_0, expr32_0);
    return expr33_0;
}

// Generated as internal constructor for term lower_i128_ushr.
pub fn constructor_lower_i128_ushr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1323.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 1i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr7_0);
    let expr12_0 = IntCC::Equal;
    let expr13_0 = C::zero_reg(ctx);
    let expr14_0 = C::zero_reg(ctx);
    let expr15_0 = C::gen_select_reg(ctx, &expr12_0, expr5_0, expr13_0, expr14_0, expr11_0);
    let expr16_0 = AluOPRRR::Srl;
    let expr17_0: usize = 0i128 as usize;
    let expr18_0 = C::value_regs_get(ctx, pattern0_0, expr17_0);
    let expr19_0 = constructor_alu_rrr(ctx, &expr16_0, expr18_0, expr5_0);
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr15_0, expr19_0);
    let expr22_0: u64 = 64i128 as u64;
    let expr23_0 = C::load_u64_constant(ctx, expr22_0);
    let expr24_0 = AluOPRRR::Srl;
    let expr25_0: usize = 1i128 as usize;
    let expr26_0 = C::value_regs_get(ctx, pattern0_0, expr25_0);
    let expr27_0 = constructor_alu_rrr(ctx, &expr24_0, expr26_0, expr5_0);
    let expr28_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr29_0 = C::gen_select_reg(ctx, &expr28_0, expr5_0, expr23_0, expr27_0, expr21_0);
    let expr30_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr31_0 = C::zero_reg(ctx);
    let expr32_0 = C::gen_select_reg(ctx, &expr30_0, expr5_0, expr23_0, expr31_0, expr27_0);
    let expr33_0 = C::value_regs(ctx, expr29_0, expr32_0);
    return expr33_0;
}

// Generated as internal constructor for term lower_i128_sshr.
pub fn constructor_lower_i128_sshr<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1347.
    let expr0_0: Type = I128;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern1_0, expr1_0);
    let expr3_0 = C::gen_shamt(ctx, expr0_0, expr2_0);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
    let expr6_0: usize = 1i128 as usize;
    let expr7_0 = C::value_regs_get(ctx, expr3_0, expr6_0);
    let expr8_0 = AluOPRRR::Sll;
    let expr9_0: usize = 1i128 as usize;
    let expr10_0 = C::value_regs_get(ctx, pattern0_0, expr9_0);
    let expr11_0 = constructor_alu_rrr(ctx, &expr8_0, expr10_0, expr7_0);
    let expr12_0 = IntCC::Equal;
    let expr13_0 = C::zero_reg(ctx);
    let expr14_0 = C::zero_reg(ctx);
    let expr15_0 = C::gen_select_reg(ctx, &expr12_0, expr5_0, expr13_0, expr14_0, expr11_0);
    let expr16_0 = AluOPRRR::Srl;
    let expr17_0: usize = 0i128 as usize;
    let expr18_0 = C::value_regs_get(ctx, pattern0_0, expr17_0);
    let expr19_0 = constructor_alu_rrr(ctx, &expr16_0, expr18_0, expr5_0);
    let expr20_0 = AluOPRRR::Or;
    let expr21_0 = constructor_alu_rrr(ctx, &expr20_0, expr15_0, expr19_0);
    let expr22_0: u64 = 64i128 as u64;
    let expr23_0 = C::load_u64_constant(ctx, expr22_0);
    let expr24_0 = AluOPRRR::Sra;
    let expr25_0: usize = 1i128 as usize;
    let expr26_0 = C::value_regs_get(ctx, pattern0_0, expr25_0);
    let expr27_0 = constructor_alu_rrr(ctx, &expr24_0, expr26_0, expr5_0);
    let expr28_0: i32 = -1i128 as i32;
    let expr29_0 = constructor_load_imm12(ctx, expr28_0);
    let expr30_0 = IntCC::SignedLessThan;
    let expr31_0: usize = 1i128 as usize;
    let expr32_0 = C::value_regs_get(ctx, pattern0_0, expr31_0);
    let expr33_0 = C::zero_reg(ctx);
    let expr34_0 = C::zero_reg(ctx);
    let expr35_0 = C::gen_select_reg(ctx, &expr30_0, expr32_0, expr33_0, expr29_0, expr34_0);
    let expr36_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr37_0 = C::gen_select_reg(ctx, &expr36_0, expr5_0, expr23_0, expr27_0, expr21_0);
    let expr38_0 = IntCC::UnsignedGreaterThanOrEqual;
    let expr39_0 = C::gen_select_reg(ctx, &expr38_0, expr5_0, expr23_0, expr35_0, expr27_0);
    let expr40_0 = C::value_regs(ctx, expr37_0, expr39_0);
    return expr40_0;
}

// Generated as internal constructor for term load_imm12.
pub fn constructor_load_imm12<C: Context>(ctx: &mut C, arg0: i32) -> Reg {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1373.
    let expr0_0 = AluOPRRI::Addi;
    let expr1_0 = C::zero_reg(ctx);
    let expr2_0 = C::imm12_const(ctx, pattern0_0);
    let expr3_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term lower_cls_i128.
pub fn constructor_lower_cls_i128<C: Context>(ctx: &mut C, arg0: ValueRegs) -> ValueRegs {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1378.
    let expr0_0 = IntCC::SignedLessThan;
    let expr1_0: usize = 1i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0 = C::zero_reg(ctx);
    let expr4_0: usize = 0i128 as usize;
    let expr5_0 = C::value_regs_get(ctx, pattern0_0, expr4_0);
    let expr6_0 = constructor_gen_bit_not(ctx, expr5_0);
    let expr7_0: usize = 0i128 as usize;
    let expr8_0 = C::value_regs_get(ctx, pattern0_0, expr7_0);
    let expr9_0 = C::gen_select_reg(ctx, &expr0_0, expr2_0, expr3_0, expr6_0, expr8_0);
    let expr10_0 = IntCC::SignedLessThan;
    let expr11_0: usize = 1i128 as usize;
    let expr12_0 = C::value_regs_get(ctx, pattern0_0, expr11_0);
    let expr13_0 = C::zero_reg(ctx);
    let expr14_0: usize = 1i128 as usize;
    let expr15_0 = C::value_regs_get(ctx, pattern0_0, expr14_0);
    let expr16_0 = constructor_gen_bit_not(ctx, expr15_0);
    let expr17_0: usize = 1i128 as usize;
    let expr18_0 = C::value_regs_get(ctx, pattern0_0, expr17_0);
    let expr19_0 = C::gen_select_reg(ctx, &expr10_0, expr12_0, expr13_0, expr16_0, expr18_0);
    let expr20_0 = C::value_regs(ctx, expr9_0, expr19_0);
    let expr21_0 = constructor_lower_clz_i128(ctx, expr20_0);
    let expr22_0: usize = 0i128 as usize;
    let expr23_0 = C::value_regs_get(ctx, expr21_0, expr22_0);
    let expr24_0 = AluOPRRI::Addi;
    let expr25_0: i32 = -1i128 as i32;
    let expr26_0 = C::imm12_const(ctx, expr25_0);
    let expr27_0 = constructor_alu_rr_imm12(ctx, &expr24_0, expr23_0, expr26_0);
    let expr28_0: u64 = 0i128 as u64;
    let expr29_0 = C::load_u64_constant(ctx, expr28_0);
    let expr30_0 = C::value_regs(ctx, expr27_0, expr29_0);
    return expr30_0;
}

// Generated as internal constructor for term gen_load.
pub fn constructor_gen_load<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: &LoadOP,
    arg3: MemFlags,
    arg4: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 1413.
    let expr0_0 = C::temp_writable_reg(ctx, pattern4_0);
    let expr1_0: Type = I64;
    let expr2_0 = C::gen_amode(ctx, pattern0_0, pattern1_0, expr1_0);
    let expr3_0 = MInst::Load {
        rd: expr0_0,
        op: pattern2_0.clone(),
        flags: pattern3_0,
        from: expr2_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr5_0;
}

// Generated as internal constructor for term gen_load_128.
pub fn constructor_gen_load_128<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: MemFlags,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1421.
    let expr0_0 = LoadOP::Ld;
    let expr1_0: Type = I64;
    let expr2_0 = constructor_gen_load(ctx, pattern0_0, pattern1_0, &expr0_0, pattern2_0, expr1_0);
    let expr3_0: i64 = 8i128 as i64;
    let expr4_0 = C::offset32_add(ctx, pattern1_0, expr3_0);
    let expr5_0 = LoadOP::Ld;
    let expr6_0: Type = I64;
    let expr7_0 = constructor_gen_load(ctx, pattern0_0, expr4_0, &expr5_0, pattern2_0, expr6_0);
    let expr8_0 = C::value_regs(ctx, expr2_0, expr7_0);
    return expr8_0;
}

// Generated as internal constructor for term gen_store.
pub fn constructor_gen_store<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: &StoreOP,
    arg3: MemFlags,
    arg4: Reg,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 1436.
    let expr0_0: Type = I64;
    let expr1_0 = C::gen_amode(ctx, pattern0_0, pattern1_0, expr0_0);
    let expr2_0 = MInst::Store {
        to: expr1_0,
        op: pattern2_0.clone(),
        flags: pattern3_0,
        src: pattern4_0,
    };
    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
    let expr4_0 = constructor_side_effect(ctx, &expr3_0);
    return expr4_0;
}

// Generated as internal constructor for term gen_store_128.
pub fn constructor_gen_store_128<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Offset32,
    arg2: MemFlags,
    arg3: ValueRegs,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1442.
    let expr0_0: Type = I64;
    let expr1_0 = C::gen_amode(ctx, pattern0_0, pattern1_0, expr0_0);
    let expr2_0 = StoreOP::Sd;
    let expr3_0: usize = 0i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, pattern3_0, expr3_0);
    let expr5_0 = MInst::Store {
        to: expr1_0,
        op: expr2_0,
        flags: pattern2_0,
        src: expr4_0,
    };
    let expr6_0: i64 = 8i128 as i64;
    let expr7_0 = C::offset32_add(ctx, pattern1_0, expr6_0);
    let expr8_0: Type = I64;
    let expr9_0 = C::gen_amode(ctx, pattern0_0, expr7_0, expr8_0);
    let expr10_0 = StoreOP::Sd;
    let expr11_0: usize = 1i128 as usize;
    let expr12_0 = C::value_regs_get(ctx, pattern3_0, expr11_0);
    let expr13_0 = MInst::Store {
        to: expr9_0,
        op: expr10_0,
        flags: pattern2_0,
        src: expr12_0,
    };
    let expr14_0 = SideEffectNoResult::Inst2 {
        inst1: expr5_0,
        inst2: expr13_0,
    };
    let expr15_0 = constructor_side_effect(ctx, &expr14_0);
    return expr15_0;
}

// Generated as internal constructor for term gen_atomic.
pub fn constructor_gen_atomic<C: Context>(
    ctx: &mut C,
    arg0: &AtomicOP,
    arg1: Reg,
    arg2: Reg,
    arg3: AMO,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1455.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::Atomic {
        op: pattern0_0.clone(),
        rd: expr1_0,
        addr: pattern1_0,
        src: pattern2_0,
        amo: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term get_atomic_rmw_op.
pub fn constructor_get_atomic_rmw_op<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &AtomicRmwOp,
) -> AtomicOP {
    let pattern0_0 = arg0;
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &AtomicRmwOp::Add => {
                // Rule at src/isa/riscv64/inst.isle line 1464.
                let expr0_0 = AtomicOP::AmoaddW;
                return expr0_0;
            }
            &AtomicRmwOp::And => {
                // Rule at src/isa/riscv64/inst.isle line 1471.
                let expr0_0 = AtomicOP::AmoandW;
                return expr0_0;
            }
            &AtomicRmwOp::Or => {
                // Rule at src/isa/riscv64/inst.isle line 1479.
                let expr0_0 = AtomicOP::AmoorW;
                return expr0_0;
            }
            &AtomicRmwOp::Smax => {
                // Rule at src/isa/riscv64/inst.isle line 1487.
                let expr0_0 = AtomicOP::AmomaxW;
                return expr0_0;
            }
            &AtomicRmwOp::Smin => {
                // Rule at src/isa/riscv64/inst.isle line 1495.
                let expr0_0 = AtomicOP::AmominW;
                return expr0_0;
            }
            &AtomicRmwOp::Umax => {
                // Rule at src/isa/riscv64/inst.isle line 1503.
                let expr0_0 = AtomicOP::AmomaxuW;
                return expr0_0;
            }
            &AtomicRmwOp::Umin => {
                // Rule at src/isa/riscv64/inst.isle line 1512.
                let expr0_0 = AtomicOP::AmominuW;
                return expr0_0;
            }
            &AtomicRmwOp::Xchg => {
                // Rule at src/isa/riscv64/inst.isle line 1520.
                let expr0_0 = AtomicOP::AmoswapW;
                return expr0_0;
            }
            &AtomicRmwOp::Xor => {
                // Rule at src/isa/riscv64/inst.isle line 1528.
                let expr0_0 = AtomicOP::AmoxorW;
                return expr0_0;
            }
            _ => {}
        }
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &AtomicRmwOp::Add => {
                // Rule at src/isa/riscv64/inst.isle line 1467.
                let expr0_0 = AtomicOP::AmoaddD;
                return expr0_0;
            }
            &AtomicRmwOp::And => {
                // Rule at src/isa/riscv64/inst.isle line 1475.
                let expr0_0 = AtomicOP::AmoandD;
                return expr0_0;
            }
            &AtomicRmwOp::Or => {
                // Rule at src/isa/riscv64/inst.isle line 1483.
                let expr0_0 = AtomicOP::AmoorD;
                return expr0_0;
            }
            &AtomicRmwOp::Smax => {
                // Rule at src/isa/riscv64/inst.isle line 1491.
                let expr0_0 = AtomicOP::AmomaxD;
                return expr0_0;
            }
            &AtomicRmwOp::Smin => {
                // Rule at src/isa/riscv64/inst.isle line 1499.
                let expr0_0 = AtomicOP::AmominD;
                return expr0_0;
            }
            &AtomicRmwOp::Umax => {
                // Rule at src/isa/riscv64/inst.isle line 1508.
                let expr0_0 = AtomicOP::AmomaxuD;
                return expr0_0;
            }
            &AtomicRmwOp::Umin => {
                // Rule at src/isa/riscv64/inst.isle line 1516.
                let expr0_0 = AtomicOP::AmominuD;
                return expr0_0;
            }
            &AtomicRmwOp::Xchg => {
                // Rule at src/isa/riscv64/inst.isle line 1524.
                let expr0_0 = AtomicOP::AmoswapD;
                return expr0_0;
            }
            &AtomicRmwOp::Xor => {
                // Rule at src/isa/riscv64/inst.isle line 1532.
                let expr0_0 = AtomicOP::AmoxorD;
                return expr0_0;
            }
            _ => {}
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "get_atomic_rmw_op", "src/isa/riscv64/inst.isle line 1462"
    );
}

// Generated as internal constructor for term gen_atomic_load.
pub fn constructor_gen_atomic_load<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1541.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::AtomicLoad {
        rd: expr1_0,
        ty: pattern1_0,
        p: pattern0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term gen_atomic_store.
pub fn constructor_gen_atomic_store<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Type,
    arg2: Reg,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1550.
    let expr0_0 = MInst::AtomicStore {
        src: pattern2_0,
        ty: pattern1_0,
        p: pattern0_0,
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term gen_bit_not.
pub fn constructor_gen_bit_not<C: Context>(ctx: &mut C, arg0: Reg) -> Reg {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1556.
    let expr0_0 = AluOPRRI::Xori;
    let expr1_0: i32 = -1i128 as i32;
    let expr2_0 = C::imm12_const(ctx, expr1_0);
    let expr3_0 = constructor_alu_rr_imm12(ctx, &expr0_0, pattern0_0, expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term f_arithmatic_op.
pub fn constructor_f_arithmatic_op<C: Context>(ctx: &mut C, arg0: Type, arg1: &Opcode) -> FpuOPRRR {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &Opcode::Fadd => {
                // Rule at src/isa/riscv64/inst.isle line 1563.
                let expr0_0 = FpuOPRRR::FaddS;
                return expr0_0;
            }
            &Opcode::Fsub => {
                // Rule at src/isa/riscv64/inst.isle line 1571.
                let expr0_0 = FpuOPRRR::FsubS;
                return expr0_0;
            }
            &Opcode::Fmul => {
                // Rule at src/isa/riscv64/inst.isle line 1578.
                let expr0_0 = FpuOPRRR::FmulS;
                return expr0_0;
            }
            &Opcode::Fdiv => {
                // Rule at src/isa/riscv64/inst.isle line 1586.
                let expr0_0 = FpuOPRRR::FdivS;
                return expr0_0;
            }
            _ => {}
        }
    }
    if pattern0_0 == F64 {
        let pattern2_0 = arg1;
        match pattern2_0 {
            &Opcode::Fadd => {
                // Rule at src/isa/riscv64/inst.isle line 1567.
                let expr0_0 = FpuOPRRR::FaddD;
                return expr0_0;
            }
            &Opcode::Fsub => {
                // Rule at src/isa/riscv64/inst.isle line 1574.
                let expr0_0 = FpuOPRRR::FsubD;
                return expr0_0;
            }
            &Opcode::Fmul => {
                // Rule at src/isa/riscv64/inst.isle line 1582.
                let expr0_0 = FpuOPRRR::FmulD;
                return expr0_0;
            }
            &Opcode::Fdiv => {
                // Rule at src/isa/riscv64/inst.isle line 1590.
                let expr0_0 = FpuOPRRR::FdivD;
                return expr0_0;
            }
            _ => {}
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "f_arithmatic_op", "src/isa/riscv64/inst.isle line 1561"
    );
}

// Generated as internal constructor for term f_copysign_op.
pub fn constructor_f_copysign_op<C: Context>(ctx: &mut C, arg0: Type) -> FpuOPRRR {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/riscv64/inst.isle line 1603.
        let expr0_0 = FpuOPRRR::FsgnjS;
        return expr0_0;
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/riscv64/inst.isle line 1604.
        let expr0_0 = FpuOPRRR::FsgnjD;
        return expr0_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "f_copysign_op", "src/isa/riscv64/inst.isle line 1602"
    );
}

// Generated as internal constructor for term f_copy_neg_sign_op.
pub fn constructor_f_copy_neg_sign_op<C: Context>(ctx: &mut C, arg0: Type) -> FpuOPRRR {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/riscv64/inst.isle line 1608.
        let expr0_0 = FpuOPRRR::FsgnjnS;
        return expr0_0;
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/riscv64/inst.isle line 1609.
        let expr0_0 = FpuOPRRR::FsgnjnD;
        return expr0_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "f_copy_neg_sign_op", "src/isa/riscv64/inst.isle line 1607"
    );
}

// Generated as internal constructor for term fabs_copy_sign.
pub fn constructor_fabs_copy_sign<C: Context>(ctx: &mut C, arg0: Type) -> FpuOPRRR {
    let pattern0_0 = arg0;
    if pattern0_0 == F32 {
        // Rule at src/isa/riscv64/inst.isle line 1612.
        let expr0_0 = FpuOPRRR::FsgnjxS;
        return expr0_0;
    }
    if pattern0_0 == F64 {
        // Rule at src/isa/riscv64/inst.isle line 1613.
        let expr0_0 = FpuOPRRR::FsgnjxD;
        return expr0_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "fabs_copy_sign", "src/isa/riscv64/inst.isle line 1611"
    );
}

// Generated as internal constructor for term gen_reference_check.
pub fn constructor_gen_reference_check<C: Context>(
    ctx: &mut C,
    arg0: &ReferenceCheckOP,
    arg1: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1631.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::ReferenceCheck {
        rd: expr1_0,
        op: pattern0_0.clone(),
        x: pattern1_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term gen_select.
pub fn constructor_gen_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: ValueRegs,
    arg3: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1640.
    let expr0_0 = C::alloc_vec_writable(ctx, pattern0_0);
    let expr1_0 = C::vec_writable_clone(ctx, &expr0_0);
    let expr2_0 = MInst::Select {
        dst: expr0_0,
        ty: pattern0_0,
        condition: pattern1_0,
        x: pattern2_0,
        y: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::vec_writable_to_regs(ctx, &expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term gen_bitselect.
pub fn constructor_gen_bitselect<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Reg,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1661.
    let expr0_0 = AluOPRRR::And;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern1_0, pattern2_0);
    let expr2_0 = constructor_gen_bit_not(ctx, pattern1_0);
    let expr3_0 = AluOPRRR::And;
    let expr4_0 = constructor_alu_rrr(ctx, &expr3_0, expr2_0, pattern3_0);
    let expr5_0 = AluOPRRR::Or;
    let expr6_0 = constructor_alu_rrr(ctx, &expr5_0, expr1_0, expr4_0);
    return expr6_0;
}

// Generated as internal constructor for term gen_int_select.
pub fn constructor_gen_int_select<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: &IntSelectOP,
    arg2: ValueRegs,
    arg3: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1674.
    let expr0_0 = C::alloc_vec_writable(ctx, pattern0_0);
    let expr1_0 = C::vec_writable_clone(ctx, &expr0_0);
    let expr2_0 = MInst::IntSelect {
        op: pattern1_0.clone(),
        dst: expr1_0,
        x: pattern2_0,
        y: pattern3_0,
        ty: pattern0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::vec_writable_to_regs(ctx, &expr0_0);
    return expr4_0;
}

// Generated as internal constructor for term udf.
pub fn constructor_udf<C: Context>(ctx: &mut C, arg0: &TrapCode) -> InstOutput {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1684.
    let expr0_0 = MInst::Udf {
        trap_code: pattern0_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term int_load_op.
pub fn constructor_int_load_op<C: Context>(ctx: &mut C, arg0: bool, arg1: u8) -> LoadOP {
    let pattern0_0 = arg0;
    if pattern0_0 == true {
        let pattern2_0 = arg1;
        if pattern2_0 == 8i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1700.
            let expr0_0 = LoadOP::Lb;
            return expr0_0;
        }
        if pattern2_0 == 16i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1707.
            let expr0_0 = LoadOP::Lh;
            return expr0_0;
        }
        if pattern2_0 == 32i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1713.
            let expr0_0 = LoadOP::Lw;
            return expr0_0;
        }
    }
    if pattern0_0 == false {
        let pattern2_0 = arg1;
        if pattern2_0 == 8i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1696.
            let expr0_0 = LoadOP::Lbu;
            return expr0_0;
        }
        if pattern2_0 == 16i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1704.
            let expr0_0 = LoadOP::Lhu;
            return expr0_0;
        }
        if pattern2_0 == 32i128 as u8 {
            // Rule at src/isa/riscv64/inst.isle line 1710.
            let expr0_0 = LoadOP::Lwu;
            return expr0_0;
        }
    }
    let pattern1_0 = arg1;
    if pattern1_0 == 64i128 as u8 {
        // Rule at src/isa/riscv64/inst.isle line 1717.
        let expr0_0 = LoadOP::Ld;
        return expr0_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "int_load_op", "src/isa/riscv64/inst.isle line 1694"
    );
}

// Generated as internal constructor for term gen_fcvt_int.
pub fn constructor_gen_fcvt_int<C: Context>(
    ctx: &mut C,
    arg0: bool,
    arg1: Reg,
    arg2: bool,
    arg3: Type,
    arg4: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 1730.
    let expr0_0 = C::temp_writable_reg(ctx, pattern4_0);
    let expr1_0: Type = F64;
    let expr2_0 = C::temp_writable_reg(ctx, expr1_0);
    let expr3_0 = MInst::FcvtToInt {
        is_sat: pattern0_0,
        rd: expr0_0,
        tmp: expr2_0,
        rs: pattern1_0,
        is_signed: pattern2_0,
        in_type: pattern3_0,
        out_type: pattern4_0,
    };
    let expr4_0 = C::emit(ctx, &expr3_0);
    let expr5_0 = C::writable_reg_to_reg(ctx, expr0_0);
    return expr5_0;
}

// Generated as internal constructor for term lower_float_binary.
pub fn constructor_lower_float_binary<C: Context>(
    ctx: &mut C,
    arg0: &AluOPRRR,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1743.
    let expr0_0 = C::move_f_to_x(ctx, pattern1_0, pattern3_0);
    let expr1_0 = C::move_f_to_x(ctx, pattern2_0, pattern3_0);
    let expr2_0 = constructor_alu_rrr(ctx, pattern0_0, expr0_0, expr1_0);
    let expr3_0 = C::move_x_to_f(ctx, expr2_0, pattern3_0);
    return expr3_0;
}

// Generated as internal constructor for term lower_float_bnot.
pub fn constructor_lower_float_bnot<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1755.
    let expr0_0 = C::move_f_to_x(ctx, pattern0_0, pattern1_0);
    let expr1_0 = constructor_gen_bit_not(ctx, expr0_0);
    let expr2_0 = C::move_x_to_f(ctx, expr1_0, pattern1_0);
    return expr2_0;
}

// Generated as internal constructor for term convert_valueregs_reg.
pub fn constructor_convert_valueregs_reg<C: Context>(ctx: &mut C, arg0: ValueRegs) -> Reg {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1767.
    let expr0_0: usize = 0i128 as usize;
    let expr1_0 = C::value_regs_get(ctx, pattern0_0, expr0_0);
    return expr1_0;
}

// Generated as internal constructor for term lower_icmp.
pub fn constructor_lower_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: ValueRegs,
    arg2: ValueRegs,
    arg3: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let mut closure4 = || {
        let expr0_0 = C::signed_cond_code(ctx, pattern0_0)?;
        return Some(expr0_0);
    };
    if let Some(pattern4_0) = closure4() {
        // Rule at src/isa/riscv64/inst.isle line 1773.
        let expr0_0: bool = true;
        let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern1_0, pattern3_0);
        let expr2_0: bool = true;
        let expr3_0 = constructor_ext_int_if_need(ctx, expr2_0, pattern2_0, pattern3_0);
        let expr4_0 = constructor_gen_icmp(ctx, pattern0_0, expr1_0, expr3_0, pattern3_0);
        return expr4_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 1776.
    let expr0_0: bool = false;
    let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern1_0, pattern3_0);
    let expr2_0: bool = false;
    let expr3_0 = constructor_ext_int_if_need(ctx, expr2_0, pattern2_0, pattern3_0);
    let expr4_0 = constructor_gen_icmp(ctx, pattern0_0, expr1_0, expr3_0, pattern3_0);
    return expr4_0;
}

// Generated as internal constructor for term lower_icmp_over_flow.
pub fn constructor_lower_icmp_over_flow<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
    arg2: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 1791.
        let expr0_0 = AluOPRRR::Sgt;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern1_0);
        let expr2_0 = C::zero_reg(ctx);
        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
        let expr4_0 = constructor_convert_valueregs_reg(ctx, pattern0_0);
        let expr5_0 = constructor_convert_valueregs_reg(ctx, pattern1_0);
        let expr6_0 = constructor_alu_sub(ctx, expr4_0, expr5_0);
        let expr7_0 = AluOPRRR::Slt;
        let expr8_0 = constructor_convert_valueregs_reg(ctx, pattern0_0);
        let expr9_0 = constructor_alu_rrr(ctx, &expr7_0, expr6_0, expr8_0);
        let expr10_0 = IntCC::NotEqual;
        let expr11_0 = C::value_reg(ctx, expr3_0);
        let expr12_0 = C::value_reg(ctx, expr9_0);
        let expr13_0: Type = I64;
        let expr14_0 = constructor_gen_icmp(ctx, &expr10_0, expr11_0, expr12_0, expr13_0);
        return expr14_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I128 {
        // Rule at src/isa/riscv64/inst.isle line 1800.
        let expr0_0 = AluOPRRI::Srli;
        let expr1_0: usize = 1i128 as usize;
        let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
        let expr3_0: i32 = 63i128 as i32;
        let expr4_0 = C::imm12_const(ctx, expr3_0);
        let expr5_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr2_0, expr4_0);
        let expr6_0 = AluOPRRI::Srli;
        let expr7_0: usize = 1i128 as usize;
        let expr8_0 = C::value_regs_get(ctx, pattern1_0, expr7_0);
        let expr9_0: i32 = 63i128 as i32;
        let expr10_0 = C::imm12_const(ctx, expr9_0);
        let expr11_0 = constructor_alu_rr_imm12(ctx, &expr6_0, expr8_0, expr10_0);
        let expr12_0 = constructor_i128_sub(ctx, pattern0_0, pattern1_0);
        let expr13_0 = AluOPRRI::Srli;
        let expr14_0: usize = 1i128 as usize;
        let expr15_0 = C::value_regs_get(ctx, expr12_0, expr14_0);
        let expr16_0: i32 = 63i128 as i32;
        let expr17_0 = C::imm12_const(ctx, expr16_0);
        let expr18_0 = constructor_alu_rr_imm12(ctx, &expr13_0, expr15_0, expr17_0);
        let expr19_0 = constructor_gen_bit_not(ctx, expr11_0);
        let expr20_0 = constructor_gen_bit_not(ctx, expr18_0);
        let expr21_0 = constructor_alu_and(ctx, expr19_0, expr20_0);
        let expr22_0 = constructor_alu_and(ctx, expr5_0, expr21_0);
        let expr23_0 = constructor_gen_bit_not(ctx, expr5_0);
        let expr24_0 = constructor_alu_and(ctx, expr11_0, expr18_0);
        let expr25_0 = constructor_alu_and(ctx, expr23_0, expr24_0);
        let expr26_0 = AluOPRRR::Or;
        let expr27_0 = constructor_alu_rrr(ctx, &expr26_0, expr22_0, expr25_0);
        let expr28_0: bool = true;
        let expr29_0: u8 = 1i128 as u8;
        let expr30_0: u8 = 64i128 as u8;
        let expr31_0 = constructor_gen_extend(ctx, expr27_0, expr28_0, expr29_0, expr30_0);
        return expr31_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 1782.
    let expr0_0: bool = true;
    let expr1_0 = constructor_ext_int_if_need(ctx, expr0_0, pattern0_0, pattern2_0);
    let expr2_0 = constructor_convert_valueregs_reg(ctx, expr1_0);
    let expr3_0: bool = true;
    let expr4_0 = constructor_ext_int_if_need(ctx, expr3_0, pattern1_0, pattern2_0);
    let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0);
    let expr6_0 = constructor_alu_sub(ctx, expr2_0, expr5_0);
    let expr7_0: Type = I64;
    let expr8_0 = C::temp_writable_reg(ctx, expr7_0);
    let expr9_0: bool = true;
    let expr10_0 = C::ty_bits(ctx, pattern2_0);
    let expr11_0: u8 = 64i128 as u8;
    let expr12_0 = MInst::Extend {
        rd: expr8_0,
        rn: expr6_0,
        signed: expr9_0,
        from_bits: expr10_0,
        to_bits: expr11_0,
    };
    let expr13_0 = C::emit(ctx, &expr12_0);
    let expr14_0 = IntCC::NotEqual;
    let expr15_0 = C::writable_reg_to_reg(ctx, expr8_0);
    let expr16_0 = C::value_reg(ctx, expr15_0);
    let expr17_0 = C::value_reg(ctx, expr6_0);
    let expr18_0: Type = I64;
    let expr19_0 = constructor_gen_icmp(ctx, &expr14_0, expr16_0, expr17_0, expr18_0);
    return expr19_0;
}

// Generated as internal constructor for term i128_sub.
pub fn constructor_i128_sub<C: Context>(
    ctx: &mut C,
    arg0: ValueRegs,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1826.
    let expr0_0 = AluOPRRR::Sub;
    let expr1_0: usize = 0i128 as usize;
    let expr2_0 = C::value_regs_get(ctx, pattern0_0, expr1_0);
    let expr3_0: usize = 0i128 as usize;
    let expr4_0 = C::value_regs_get(ctx, pattern1_0, expr3_0);
    let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr2_0, expr4_0);
    let expr6_0 = AluOPRRR::SltU;
    let expr7_0: usize = 0i128 as usize;
    let expr8_0 = C::value_regs_get(ctx, pattern0_0, expr7_0);
    let expr9_0 = constructor_alu_rrr(ctx, &expr6_0, expr8_0, expr5_0);
    let expr10_0 = AluOPRRR::Sub;
    let expr11_0: usize = 1i128 as usize;
    let expr12_0 = C::value_regs_get(ctx, pattern0_0, expr11_0);
    let expr13_0: usize = 1i128 as usize;
    let expr14_0 = C::value_regs_get(ctx, pattern1_0, expr13_0);
    let expr15_0 = constructor_alu_rrr(ctx, &expr10_0, expr12_0, expr14_0);
    let expr16_0 = AluOPRRR::Sub;
    let expr17_0 = constructor_alu_rrr(ctx, &expr16_0, expr15_0, expr9_0);
    let expr18_0 = C::value_regs(ctx, expr5_0, expr17_0);
    return expr18_0;
}

// Generated as internal constructor for term gen_fabs.
pub fn constructor_gen_fabs<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 1841.
    let expr0_0 = constructor_fabs_copy_sign(ctx, pattern1_0);
    let expr1_0 = constructor_fpu_rrr(ctx, &expr0_0, pattern1_0, pattern0_0, pattern0_0);
    return expr1_0;
}

// Generated as internal constructor for term lower_uadd_overflow.
pub fn constructor_lower_uadd_overflow<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: Type,
) -> ValueRegs {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if pattern2_0 == I64 {
        // Rule at src/isa/riscv64/inst.isle line 1847.
        let expr0_0 = constructor_alu_add(ctx, pattern0_0, pattern1_0);
        let expr1_0 = IntCC::UnsignedLessThan;
        let expr2_0 = C::value_reg(ctx, expr0_0);
        let expr3_0 = C::value_reg(ctx, pattern0_0);
        let expr4_0: Type = I64;
        let expr5_0 = constructor_gen_icmp(ctx, &expr1_0, expr2_0, expr3_0, expr4_0);
        let expr6_0 = C::value_regs(ctx, expr0_0, expr5_0);
        return expr6_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
        // Rule at src/isa/riscv64/inst.isle line 1854.
        let expr0_0: bool = false;
        let expr1_0 = C::value_reg(ctx, pattern0_0);
        let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
        let expr4_0: bool = false;
        let expr5_0 = C::value_reg(ctx, pattern1_0);
        let expr6_0 = constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0);
        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0);
        let expr8_0 = constructor_alu_add(ctx, expr3_0, expr7_0);
        let expr9_0 = C::ty_bits(ctx, pattern3_0);
        let expr10_0 = C::u8_as_i32(ctx, expr9_0);
        let expr11_0 = constructor_alu_srli(ctx, expr8_0, expr10_0);
        let expr12_0 = C::value_regs(ctx, expr8_0, expr11_0);
        return expr12_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_uadd_overflow", "src/isa/riscv64/inst.isle line 1845"
    );
}

// Generated as internal constructor for term gen_jump.
pub fn constructor_gen_jump<C: Context>(ctx: &mut C, arg0: MachLabel) -> MInst {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 1869.
    let expr0_0 = C::label_to_br_target(ctx, pattern0_0);
    let expr1_0 = MInst::Jal { dest: expr0_0 };
    return expr1_0;
}

// Generated as internal constructor for term lower_branch.
pub fn constructor_lower_branch<C: Context>(
    ctx: &mut C,
    arg0: Inst,
    arg1: &VecMachLabel,
) -> Option<Unit> {
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::Branch {
        opcode: ref pattern2_0,
        args: pattern2_1,
        destination: pattern2_2,
    } = &pattern1_0
    {
        match pattern2_0 {
            &Opcode::Brz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    let pattern6_0 = C::value_type(ctx, pattern5_0);
                    if pattern6_0 == I128 {
                        let pattern8_0 = arg1;
                        // Rule at src/isa/riscv64/inst.isle line 1926.
                        let expr0_0 = C::zero_reg(ctx);
                        let expr1_0 = C::zero_reg(ctx);
                        let expr2_0 = C::value_regs(ctx, expr0_0, expr1_0);
                        let expr3_0 = IntCC::Equal;
                        let expr4_0 = C::put_in_regs(ctx, pattern5_0);
                        let expr5_0: Type = I128;
                        let expr6_0 =
                            constructor_gen_icmp(ctx, &expr3_0, expr4_0, expr2_0, expr5_0);
                        let expr7_0 = IntCC::NotEqual;
                        let expr8_0 = C::value_reg(ctx, expr6_0);
                        let expr9_0: Type = I64;
                        let expr10_0 =
                            C::lower_brz_or_nz(ctx, &expr7_0, expr8_0, pattern8_0, expr9_0);
                        return Some(expr10_0);
                    }
                }
            }
            &Opcode::Brnz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    let pattern6_0 = C::value_type(ctx, pattern5_0);
                    if pattern6_0 == I128 {
                        let pattern8_0 = arg1;
                        // Rule at src/isa/riscv64/inst.isle line 1946.
                        let expr0_0 = C::zero_reg(ctx);
                        let expr1_0 = C::zero_reg(ctx);
                        let expr2_0 = C::value_regs(ctx, expr0_0, expr1_0);
                        let expr3_0 = IntCC::NotEqual;
                        let expr4_0 = C::put_in_regs(ctx, pattern5_0);
                        let expr5_0: Type = I128;
                        let expr6_0 =
                            constructor_gen_icmp(ctx, &expr3_0, expr4_0, expr2_0, expr5_0);
                        let expr7_0 = IntCC::NotEqual;
                        let expr8_0 = C::value_reg(ctx, expr6_0);
                        let expr9_0: Type = I64;
                        let expr10_0 =
                            C::lower_brz_or_nz(ctx, &expr7_0, expr8_0, pattern8_0, expr9_0);
                        return Some(expr10_0);
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::Branch {
        opcode: ref pattern2_0,
        args: pattern2_1,
        destination: pattern2_2,
    } = &pattern1_0
    {
        match pattern2_0 {
            &Opcode::Brz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::def_inst(ctx, pattern5_0) {
                        let pattern7_0 = C::inst_data(ctx, pattern6_0);
                        match &pattern7_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Fcmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1936.
                                    let expr0_0 = C::floatcc_inverse(ctx, pattern8_2);
                                    let expr1_0 = C::put_in_reg(ctx, pattern10_0);
                                    let expr2_0 = C::put_in_reg(ctx, pattern10_1);
                                    let expr3_0 = C::lower_br_fcmp(
                                        ctx,
                                        &expr0_0,
                                        expr1_0,
                                        expr2_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr3_0);
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Icmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1932.
                                    let expr0_0 = C::intcc_inverse(ctx, pattern8_2);
                                    let expr1_0 = C::put_in_regs(ctx, pattern10_0);
                                    let expr2_0 = C::put_in_regs(ctx, pattern10_1);
                                    let expr3_0 = C::lower_br_icmp(
                                        ctx,
                                        &expr0_0,
                                        expr1_0,
                                        expr2_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr3_0);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            &Opcode::Brnz => {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    if let Some(pattern6_0) = C::def_inst(ctx, pattern5_0) {
                        let pattern7_0 = C::inst_data(ctx, pattern6_0);
                        match &pattern7_0 {
                            &InstructionData::FloatCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Fcmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1956.
                                    let expr0_0 = C::put_in_reg(ctx, pattern10_0);
                                    let expr1_0 = C::put_in_reg(ctx, pattern10_1);
                                    let expr2_0 = C::lower_br_fcmp(
                                        ctx,
                                        pattern8_2,
                                        expr0_0,
                                        expr1_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr2_0);
                                }
                            }
                            &InstructionData::IntCompare {
                                opcode: ref pattern8_0,
                                args: ref pattern8_1,
                                cond: ref pattern8_2,
                            } => {
                                if let &Opcode::Icmp = pattern8_0 {
                                    let (pattern10_0, pattern10_1) =
                                        C::unpack_value_array_2(ctx, pattern8_1);
                                    let pattern11_0 = C::value_type(ctx, pattern10_0);
                                    let pattern12_0 = arg1;
                                    // Rule at src/isa/riscv64/inst.isle line 1952.
                                    let expr0_0 = C::put_in_regs(ctx, pattern10_0);
                                    let expr1_0 = C::put_in_regs(ctx, pattern10_1);
                                    let expr2_0 = C::lower_br_icmp(
                                        ctx,
                                        pattern8_2,
                                        expr0_0,
                                        expr1_0,
                                        pattern12_0,
                                        pattern11_0,
                                    );
                                    return Some(expr2_0);
                                }
                            }
                            _ => {}
                        }
                    }
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::BranchTable {
            opcode: ref pattern2_0,
            arg: pattern2_1,
            destination: pattern2_2,
            table: pattern2_3,
        } => {
            if let &Opcode::BrTable = pattern2_0 {
                let pattern4_0 = arg1;
                // Rule at src/isa/riscv64/inst.isle line 1965.
                let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                let expr1_0 = C::lower_br_table(ctx, expr0_0, pattern4_0);
                return Some(expr1_0);
            }
        }
        &InstructionData::Branch {
            opcode: ref pattern2_0,
            args: pattern2_1,
            destination: pattern2_2,
        } => {
            match pattern2_0 {
                &Opcode::Brz => {
                    let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                        let pattern6_0 = C::value_type(ctx, pattern5_0);
                        let pattern7_0 = arg1;
                        // Rule at src/isa/riscv64/inst.isle line 1922.
                        let expr0_0 = IntCC::Equal;
                        let expr1_0 = C::put_in_regs(ctx, pattern5_0);
                        let expr2_0 = constructor_normalize_cmp_value(ctx, pattern6_0, expr1_0);
                        let expr3_0 =
                            C::lower_brz_or_nz(ctx, &expr0_0, expr2_0, pattern7_0, pattern6_0);
                        return Some(expr3_0);
                    }
                }
                &Opcode::Brnz => {
                    let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                    if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                        let pattern6_0 = C::value_type(ctx, pattern5_0);
                        let pattern7_0 = arg1;
                        // Rule at src/isa/riscv64/inst.isle line 1942.
                        let expr0_0 = IntCC::NotEqual;
                        let expr1_0 = C::put_in_regs(ctx, pattern5_0);
                        let expr2_0 = constructor_normalize_cmp_value(ctx, pattern6_0, expr1_0);
                        let expr3_0 =
                            C::lower_brz_or_nz(ctx, &expr0_0, expr2_0, pattern7_0, pattern6_0);
                        return Some(expr3_0);
                    }
                }
                _ => {}
            }
        }
        &InstructionData::Jump {
            opcode: ref pattern2_0,
            args: pattern2_1,
            destination: pattern2_2,
        } => {
            if let &Opcode::Jump = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                let pattern5_0 = arg1;
                // Rule at src/isa/riscv64/inst.isle line 1876.
                let expr0_0: u8 = 0i128 as u8;
                let expr1_0 = C::vec_label_get(ctx, pattern5_0, expr0_0);
                let expr2_0 = constructor_gen_jump(ctx, expr1_0);
                let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
                let expr4_0 = constructor_emit_side_effect(ctx, &expr3_0);
                return Some(expr4_0);
            }
        }
        _ => {}
    }
    return None;
}

// Generated as internal constructor for term normalize_cmp_value.
pub fn constructor_normalize_cmp_value<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    if pattern0_0 == I8 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1899.
        let expr0_0 = AluOPRRI::Andi;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern2_0);
        let expr2_0: i32 = 255i128 as i32;
        let expr3_0 = C::imm12_const(ctx, expr2_0);
        let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0);
        let expr5_0 = C::value_reg(ctx, expr4_0);
        return expr5_0;
    }
    if pattern0_0 == I16 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1901.
        let expr0_0 = AluOPRRR::And;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern2_0);
        let expr2_0: Type = I16;
        let expr3_0: u64 = 65535i128 as u64;
        let expr4_0 = C::imm(ctx, expr2_0, expr3_0);
        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
        let expr6_0 = C::value_reg(ctx, expr5_0);
        return expr6_0;
    }
    if pattern0_0 == I32 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1903.
        let expr0_0 = AluOPRRI::Addiw;
        let expr1_0 = constructor_convert_valueregs_reg(ctx, pattern2_0);
        let expr2_0: i32 = 0i128 as i32;
        let expr3_0 = C::imm12_const(ctx, expr2_0);
        let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0);
        let expr5_0 = C::value_reg(ctx, expr4_0);
        return expr5_0;
    }
    if pattern0_0 == I64 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1906.
        return pattern2_0;
    }
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1907.
        return pattern2_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "normalize_cmp_value", "src/isa/riscv64/inst.isle line 1897"
    );
}

// Generated as internal constructor for term truthy_to_reg.
pub fn constructor_truthy_to_reg<C: Context>(ctx: &mut C, arg0: Type, arg1: ValueRegs) -> Reg {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1913.
        let expr0_0: usize = 0i128 as usize;
        let expr1_0 = C::value_regs_get(ctx, pattern2_0, expr0_0);
        return expr1_0;
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 1915.
        let expr0_0: usize = 0i128 as usize;
        let expr1_0 = C::value_regs_get(ctx, pattern2_0, expr0_0);
        let expr2_0: usize = 1i128 as usize;
        let expr3_0 = C::value_regs_get(ctx, pattern2_0, expr2_0);
        let expr4_0 = AluOPRRR::Or;
        let expr5_0 = constructor_alu_rrr(ctx, &expr4_0, expr1_0, expr3_0);
        return expr5_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "truthy_to_reg", "src/isa/riscv64/inst.isle line 1912"
    );
}

// Generated as internal constructor for term gen_andn.
pub fn constructor_gen_andn<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1973.
            let expr0_0 = AluOPRRR::Andn;
            let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
            return expr1_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1979.
            let expr0_0 = constructor_gen_bit_not(ctx, pattern1_0);
            let expr1_0 = constructor_alu_and(ctx, pattern0_0, expr0_0);
            return expr1_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "gen_andn", "src/isa/riscv64/inst.isle line 1972"
    );
}

// Generated as internal constructor for term gen_orn.
pub fn constructor_gen_orn<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 1987.
            let expr0_0 = AluOPRRR::Orn;
            let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
            return expr1_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 1993.
            let expr0_0 = constructor_gen_bit_not(ctx, pattern1_0);
            let expr1_0 = AluOPRRR::Or;
            let expr2_0 = constructor_alu_rrr(ctx, &expr1_0, pattern0_0, expr0_0);
            return expr2_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "gen_orn", "src/isa/riscv64/inst.isle line 1986"
    );
}

// Generated as internal constructor for term gen_rev8.
pub fn constructor_gen_rev8<C: Context>(ctx: &mut C, arg0: Reg) -> Reg {
    let pattern0_0 = arg0;
    let mut closure1 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern1_0) = closure1() {
        if pattern1_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 2000.
            let expr0_0 = AluOPRRI::Rev8;
            let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern0_0);
            return expr1_0;
        }
    }
    let pattern0_0 = arg0;
    let mut closure1 = || {
        let expr0_0 = C::has_b(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern1_0) = closure1() {
        if pattern1_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 2006.
            let expr0_0: Type = I64;
            let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
            let expr2_0: Type = I64;
            let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
            let expr4_0: Type = I64;
            let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
            let expr6_0 = MInst::Rev8 {
                rs: pattern0_0,
                step: expr5_0,
                tmp: expr3_0,
                rd: expr1_0,
            };
            let expr7_0 = C::emit(ctx, &expr6_0);
            let expr8_0 = C::writable_reg_to_reg(ctx, expr1_0);
            return expr8_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "gen_rev8", "src/isa/riscv64/inst.isle line 1999"
    );
}

// Generated as internal constructor for term gen_brev8.
pub fn constructor_gen_brev8<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_zbkb(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == true {
            // Rule at src/isa/riscv64/inst.isle line 2022.
            let expr0_0 = AluOPRRI::Brev8;
            let expr1_0 = constructor_alu_rr_funct12(ctx, &expr0_0, pattern0_0);
            return expr1_0;
        }
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let mut closure2 = || {
        let expr0_0 = C::has_zbkb(ctx);
        return Some(expr0_0);
    };
    if let Some(pattern2_0) = closure2() {
        if pattern2_0 == false {
            // Rule at src/isa/riscv64/inst.isle line 2027.
            let expr0_0: Type = I64;
            let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
            let expr2_0: Type = I64;
            let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
            let expr4_0: Type = I64;
            let expr5_0 = C::temp_writable_reg(ctx, expr4_0);
            let expr6_0: Type = I64;
            let expr7_0 = C::temp_writable_reg(ctx, expr6_0);
            let expr8_0 = MInst::Brev8 {
                rs: pattern0_0,
                ty: pattern1_0,
                step: expr5_0,
                tmp: expr1_0,
                tmp2: expr3_0,
                rd: expr7_0,
            };
            let expr9_0 = C::emit(ctx, &expr8_0);
            let expr10_0 = C::writable_reg_to_reg(ctx, expr7_0);
            return expr10_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "gen_brev8", "src/isa/riscv64/inst.isle line 2021"
    );
}

// Generated as internal constructor for term gen_xor_not.
pub fn constructor_gen_xor_not<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2040.
    let expr0_0 = constructor_gen_bit_not(ctx, pattern1_0);
    let expr1_0 = AluOPRRR::Xor;
    let expr2_0 = constructor_alu_rrr(ctx, &expr1_0, pattern0_0, expr0_0);
    return expr2_0;
}

// Generated as internal constructor for term neg.
pub fn constructor_neg<C: Context>(ctx: &mut C, arg0: Type, arg1: ValueRegs) -> ValueRegs {
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 2052.
        let expr0_0 = constructor_value_regs_zero(ctx);
        let expr1_0 = constructor_i128_sub(ctx, expr0_0, pattern2_0);
        return expr1_0;
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        if let Some(pattern2_0) = C::ty_int(ctx, pattern1_0) {
            let pattern3_0 = arg1;
            // Rule at src/isa/riscv64/inst.isle line 2048.
            let expr0_0 = AluOPRRR::Sub;
            let expr1_0 = C::zero_reg(ctx);
            let expr2_0: usize = 0i128 as usize;
            let expr3_0 = C::value_regs_get(ctx, pattern3_0, expr2_0);
            let expr4_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr3_0);
            let expr5_0 = C::value_reg(ctx, expr4_0);
            return expr5_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "neg", "src/isa/riscv64/inst.isle line 2047"
    );
}

// Generated as internal constructor for term max.
pub fn constructor_max<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        if let Some(pattern2_0) = C::ty_int(ctx, pattern1_0) {
            let pattern3_0 = arg1;
            let pattern4_0 = arg2;
            let mut closure5 = || {
                let expr0_0 = C::has_zbb(ctx);
                return Some(expr0_0);
            };
            if let Some(pattern5_0) = closure5() {
                if pattern5_0 == true {
                    // Rule at src/isa/riscv64/inst.isle line 2058.
                    let expr0_0 = AluOPRRR::Max;
                    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern3_0, pattern4_0);
                    return expr1_0;
                }
                if pattern5_0 == false {
                    // Rule at src/isa/riscv64/inst.isle line 2062.
                    let expr0_0 = IntCC::SignedGreaterThan;
                    let expr1_0 = C::gen_select_reg(
                        ctx, &expr0_0, pattern3_0, pattern4_0, pattern3_0, pattern4_0,
                    );
                    return expr1_0;
                }
            }
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "max", "src/isa/riscv64/inst.isle line 2057"
    );
}

// Generated as internal constructor for term lower_iabs.
pub fn constructor_lower_iabs<C: Context>(ctx: &mut C, arg0: Type, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        // Rule at src/isa/riscv64/inst.isle line 2074.
        let expr0_0: bool = true;
        let expr1_0 = C::value_reg(ctx, pattern2_0);
        let expr2_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern1_0);
        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
        let expr4_0: Type = I64;
        let expr5_0 = C::value_reg(ctx, expr3_0);
        let expr6_0 = constructor_neg(ctx, expr4_0, expr5_0);
        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0);
        let expr8_0: Type = I64;
        let expr9_0 = constructor_max(ctx, expr8_0, expr3_0, expr7_0);
        return expr9_0;
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_iabs", "src/isa/riscv64/inst.isle line 2067"
    );
}

// Generated as internal constructor for term gen_trapff.
pub fn constructor_gen_trapff<C: Context>(
    ctx: &mut C,
    arg0: &FloatCC,
    arg1: Reg,
    arg2: Reg,
    arg3: Type,
    arg4: &TrapCode,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    let pattern4_0 = arg4;
    // Rule at src/isa/riscv64/inst.isle line 2083.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::TrapFf {
        cc: pattern0_0.clone(),
        x: pattern1_0,
        y: pattern2_0,
        ty: pattern3_0,
        tmp: expr1_0,
        trap_code: pattern4_0.clone(),
    };
    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
    let expr4_0 = constructor_side_effect(ctx, &expr3_0);
    return expr4_0;
}

// Generated as internal constructor for term gen_trapif.
pub fn constructor_gen_trapif<C: Context>(ctx: &mut C, arg0: Reg, arg1: &TrapCode) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2090.
    let expr0_0 = MInst::TrapIf {
        test: pattern0_0,
        trap_code: pattern1_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term gen_trapifc.
pub fn constructor_gen_trapifc<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: Reg,
    arg2: Reg,
    arg3: &TrapCode,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/inst.isle line 2095.
    let expr0_0 = MInst::TrapIfC {
        rs1: pattern1_0,
        rs2: pattern2_0,
        cc: pattern0_0.clone(),
        trap_code: pattern3_0.clone(),
    };
    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
    let expr2_0 = constructor_side_effect(ctx, &expr1_0);
    return expr2_0;
}

// Generated as internal constructor for term gen_div_overflow.
pub fn constructor_gen_div_overflow<C: Context>(
    ctx: &mut C,
    arg0: Reg,
    arg1: Reg,
    arg2: Type,
) -> InstOutput {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 2104.
    let expr0_0: i32 = -1i128 as i32;
    let expr1_0 = constructor_load_imm12(ctx, expr0_0);
    let expr2_0: i32 = 1i128 as i32;
    let expr3_0 = constructor_load_imm12(ctx, expr2_0);
    let expr4_0: i32 = 63i128 as i32;
    let expr5_0 = constructor_alu_slli(ctx, expr3_0, expr4_0);
    let expr6_0 = C::shift_int_to_most_significant(ctx, pattern0_0, pattern2_0);
    let expr7_0 = IntCC::Equal;
    let expr8_0 = C::value_reg(ctx, expr1_0);
    let expr9_0 = C::value_reg(ctx, pattern1_0);
    let expr10_0 = constructor_gen_icmp(ctx, &expr7_0, expr8_0, expr9_0, pattern2_0);
    let expr11_0 = IntCC::Equal;
    let expr12_0 = C::value_reg(ctx, expr5_0);
    let expr13_0 = C::value_reg(ctx, expr6_0);
    let expr14_0 = constructor_gen_icmp(ctx, &expr11_0, expr12_0, expr13_0, pattern2_0);
    let expr15_0 = constructor_alu_and(ctx, expr10_0, expr14_0);
    let expr16_0 = TrapCode::IntegerOverflow;
    let expr17_0 = constructor_gen_trapif(ctx, expr15_0, &expr16_0);
    return expr17_0;
}

// Generated as internal constructor for term gen_div_by_zero.
pub fn constructor_gen_div_by_zero<C: Context>(ctx: &mut C, arg0: Reg) -> InstOutput {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 2116.
    let expr0_0 = IntCC::Equal;
    let expr1_0 = C::zero_reg(ctx);
    let expr2_0 = TrapCode::IntegerDivisionByZero;
    let expr3_0 = constructor_gen_trapifc(ctx, &expr0_0, expr1_0, pattern0_0, &expr2_0);
    return expr3_0;
}

// Generated as internal constructor for term madd.
pub fn constructor_madd<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg, arg2: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    // Rule at src/isa/riscv64/inst.isle line 2130.
    let expr0_0 = AluOPRRR::Mul;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
    let expr2_0 = constructor_alu_add(ctx, expr1_0, pattern2_0);
    return expr2_0;
}

// Generated as internal constructor for term umulh.
pub fn constructor_umulh<C: Context>(ctx: &mut C, arg0: Reg, arg1: Reg) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/inst.isle line 2136.
    let expr0_0 = AluOPRRR::Mulhu;
    let expr1_0 = constructor_alu_rrr(ctx, &expr0_0, pattern0_0, pattern1_0);
    return expr1_0;
}

// Generated as internal constructor for term lower_bmask.
pub fn constructor_lower_bmask<C: Context>(
    ctx: &mut C,
    arg0: Type,
    arg1: Type,
    arg2: ValueRegs,
) -> ValueRegs {
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        if pattern2_0 == I128 {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2176.
            let expr0_0: Type = I64;
            let expr1_0: Type = I128;
            let expr2_0 = constructor_lower_bmask(ctx, expr0_0, expr1_0, pattern4_0);
            let expr3_0: usize = 0i128 as usize;
            let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
            let expr5_0: usize = 0i128 as usize;
            let expr6_0 = C::value_regs_get(ctx, expr2_0, expr5_0);
            let expr7_0 = C::value_regs(ctx, expr4_0, expr6_0);
            return expr7_0;
        }
    }
    let pattern0_0 = arg0;
    if pattern0_0 == I128 {
        let pattern2_0 = arg1;
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2167.
            let expr0_0: Type = I64;
            let expr1_0 = constructor_lower_bmask(ctx, expr0_0, pattern3_0, pattern4_0);
            let expr2_0: usize = 0i128 as usize;
            let expr3_0 = C::value_regs_get(ctx, expr1_0, expr2_0);
            let expr4_0: usize = 0i128 as usize;
            let expr5_0 = C::value_regs_get(ctx, expr1_0, expr4_0);
            let expr6_0 = C::value_regs(ctx, expr3_0, expr5_0);
            return expr6_0;
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if pattern2_0 == I128 {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2157.
            let expr0_0: usize = 0i128 as usize;
            let expr1_0 = C::value_regs_get(ctx, pattern4_0, expr0_0);
            let expr2_0: usize = 1i128 as usize;
            let expr3_0 = C::value_regs_get(ctx, pattern4_0, expr2_0);
            let expr4_0 = AluOPRRR::Or;
            let expr5_0 = constructor_alu_rrr(ctx, &expr4_0, expr1_0, expr3_0);
            let expr6_0: Type = I64;
            let expr7_0 = C::value_reg(ctx, expr5_0);
            let expr8_0 = constructor_lower_bmask(ctx, pattern1_0, expr6_0, expr7_0);
            return expr8_0;
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::fits_in_64(ctx, pattern0_0) {
        let pattern2_0 = arg1;
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = arg2;
            // Rule at src/isa/riscv64/inst.isle line 2147.
            let expr0_0 = constructor_normalize_cmp_value(ctx, pattern3_0, pattern4_0);
            let expr1_0 = constructor_convert_valueregs_reg(ctx, expr0_0);
            let expr2_0 = C::zero_reg(ctx);
            let expr3_0: i32 = -1i128 as i32;
            let expr4_0 = constructor_load_imm12(ctx, expr3_0);
            let expr5_0 = IntCC::Equal;
            let expr6_0 = C::gen_select_reg(ctx, &expr5_0, expr2_0, expr1_0, expr2_0, expr4_0);
            let expr7_0 = C::value_reg(ctx, expr6_0);
            return expr7_0;
        }
    }
    return unreachable!(
        "no rule matched for term {} at {}; should it be partial?",
        "lower_bmask", "src/isa/riscv64/inst.isle line 2141"
    );
}

// Generated as internal constructor for term gen_mov_from_preg.
pub fn constructor_gen_mov_from_preg<C: Context>(ctx: &mut C, arg0: PReg) -> Reg {
    let pattern0_0 = arg0;
    // Rule at src/isa/riscv64/inst.isle line 2187.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::MovFromPReg {
        rd: expr1_0,
        rm: pattern0_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term lower.
pub fn constructor_lower<C: Context>(ctx: &mut C, arg0: Inst) -> Option<InstOutput> {
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 311.
                                        let expr0_0 = AluOPRRI::Slliw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0: i32 = 7i128 as i32;
                                        let expr3_0 = C::imm12_and(ctx, pattern13_0, expr2_0);
                                        let expr4_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr1_0, expr3_0,
                                        );
                                        let expr5_0 = constructor_output_reg(ctx, expr4_0);
                                        return Some(expr5_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 337.
                                        let expr0_0 = AluOPRRI::SrliW;
                                        let expr1_0: bool = false;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I8;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        );
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0);
                                        let expr6_0: i32 = 7i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        );
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0);
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 364.
                                        let expr0_0 = AluOPRRI::Srai;
                                        let expr1_0: bool = true;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I8;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        );
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0);
                                        let expr6_0: i32 = 7i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        );
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0);
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I16 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 317.
                                        let expr0_0 = AluOPRRI::Slliw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0: i32 = 15i128 as i32;
                                        let expr3_0 = C::imm12_and(ctx, pattern13_0, expr2_0);
                                        let expr4_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr1_0, expr3_0,
                                        );
                                        let expr5_0 = constructor_output_reg(ctx, expr4_0);
                                        return Some(expr5_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 343.
                                        let expr0_0 = AluOPRRI::SrliW;
                                        let expr1_0: bool = false;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I16;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        );
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0);
                                        let expr6_0: i32 = 15i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        );
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0);
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 370.
                                        let expr0_0 = AluOPRRI::Srai;
                                        let expr1_0: bool = true;
                                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                                        let expr3_0: Type = I16;
                                        let expr4_0 = constructor_ext_int_if_need(
                                            ctx, expr1_0, expr2_0, expr3_0,
                                        );
                                        let expr5_0 =
                                            constructor_convert_valueregs_reg(ctx, expr4_0);
                                        let expr6_0: i32 = 15i128 as i32;
                                        let expr7_0 = C::imm12_and(ctx, pattern13_0, expr6_0);
                                        let expr8_0 = constructor_alu_rr_imm12(
                                            ctx, &expr0_0, expr5_0, expr7_0,
                                        );
                                        let expr9_0 = constructor_output_reg(ctx, expr8_0);
                                        return Some(expr9_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 322.
                                        let expr0_0 = AluOPRRI::Slliw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 348.
                                        let expr0_0 = AluOPRRI::SrliW;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 375.
                                        let expr0_0 = AluOPRRI::Sraiw;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 325.
                                        let expr0_0 = AluOPRRI::Slli;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 351.
                                        let expr0_0 = AluOPRRI::Srli;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 379.
                                        let expr0_0 = AluOPRRI::Srai;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 40.
                                        let expr0_0 = constructor_select_addi(ctx, pattern3_0);
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 193.
                                        let expr0_0 = AluOPRRI::Andi;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 213.
                                        let expr0_0 = AluOPRRI::Ori;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 231.
                                        let expr0_0 = AluOPRRI::Xori;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::fits_in_16(ctx, pattern3_0) {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::AtomicRmw {
                    opcode: ref pattern6_0,
                    args: ref pattern6_1,
                    flags: pattern6_2,
                    op: ref pattern6_3,
                } = &pattern5_0
                {
                    if let &Opcode::AtomicRmw = pattern6_0 {
                        let (pattern8_0, pattern8_1) = C::unpack_value_array_2(ctx, pattern6_1);
                        if let Some((pattern9_0, pattern9_1)) =
                            C::is_atomic_rmw_max_etc(ctx, pattern6_3)
                        {
                            if pattern9_1 == true {
                                // Rule at src/isa/riscv64/lower.isle line 474.
                                let expr0_0 = C::put_in_reg(ctx, pattern8_0);
                                let expr1_0: bool = true;
                                let expr2_0 = C::put_in_regs(ctx, pattern8_1);
                                let expr3_0 =
                                    constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern4_0);
                                let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0);
                                let expr5_0 = constructor_gen_atomic_rmw_loop(
                                    ctx,
                                    &pattern9_0,
                                    pattern4_0,
                                    expr0_0,
                                    expr4_0,
                                );
                                let expr6_0 = constructor_output_reg(ctx, expr5_0);
                                return Some(expr6_0);
                            }
                            if pattern9_1 == false {
                                // Rule at src/isa/riscv64/lower.isle line 480.
                                let expr0_0 = C::put_in_reg(ctx, pattern8_0);
                                let expr1_0: bool = false;
                                let expr2_0 = C::put_in_regs(ctx, pattern8_1);
                                let expr3_0 =
                                    constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern4_0);
                                let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0);
                                let expr5_0 = constructor_gen_atomic_rmw_loop(
                                    ctx,
                                    &pattern9_0,
                                    pattern4_0,
                                    expr0_0,
                                    expr4_0,
                                );
                                let expr6_0 = constructor_output_reg(ctx, expr5_0);
                                return Some(expr6_0);
                            }
                        }
                    }
                }
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I8 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 308.
                        let expr0_0 = AluOPRRR::Sllw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0: i32 = 7i128 as i32;
                        let expr6_0 = constructor_alu_andi(ctx, expr4_0, expr5_0);
                        let expr7_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr6_0);
                        let expr8_0 = constructor_output_reg(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 334.
                        let expr0_0 = AluOPRRR::Srlw;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I8;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0);
                        let expr6_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr7_0: usize = 0i128 as usize;
                        let expr8_0 = C::value_regs_get(ctx, expr6_0, expr7_0);
                        let expr9_0: i32 = 7i128 as i32;
                        let expr10_0 = constructor_alu_andi(ctx, expr8_0, expr9_0);
                        let expr11_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr10_0);
                        let expr12_0 = constructor_output_reg(ctx, expr11_0);
                        return Some(expr12_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 361.
                        let expr0_0 = AluOPRRR::Sra;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I8;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0);
                        let expr6_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr7_0: usize = 0i128 as usize;
                        let expr8_0 = C::value_regs_get(ctx, expr6_0, expr7_0);
                        let expr9_0: i32 = 7i128 as i32;
                        let expr10_0 = constructor_alu_andi(ctx, expr8_0, expr9_0);
                        let expr11_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr10_0);
                        let expr12_0 = constructor_output_reg(ctx, expr11_0);
                        return Some(expr12_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I16 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 314.
                        let expr0_0 = AluOPRRR::Sllw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0: i32 = 15i128 as i32;
                        let expr6_0 = constructor_alu_andi(ctx, expr4_0, expr5_0);
                        let expr7_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr6_0);
                        let expr8_0 = constructor_output_reg(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 340.
                        let expr0_0 = AluOPRRR::Srlw;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I16;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0);
                        let expr6_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr7_0: usize = 0i128 as usize;
                        let expr8_0 = C::value_regs_get(ctx, expr6_0, expr7_0);
                        let expr9_0: i32 = 15i128 as i32;
                        let expr10_0 = constructor_alu_andi(ctx, expr8_0, expr9_0);
                        let expr11_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr10_0);
                        let expr12_0 = constructor_output_reg(ctx, expr11_0);
                        return Some(expr12_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 367.
                        let expr0_0 = AluOPRRR::Sra;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr3_0: Type = I16;
                        let expr4_0 = constructor_ext_int_if_need(ctx, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0);
                        let expr6_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr7_0: usize = 0i128 as usize;
                        let expr8_0 = C::value_regs_get(ctx, expr6_0, expr7_0);
                        let expr9_0: i32 = 15i128 as i32;
                        let expr10_0 = constructor_alu_andi(ctx, expr8_0, expr9_0);
                        let expr11_0 = constructor_alu_rrr(ctx, &expr0_0, expr5_0, expr10_0);
                        let expr12_0 = constructor_output_reg(ctx, expr11_0);
                        return Some(expr12_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 320.
                        let expr0_0 = AluOPRRR::Sllw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 346.
                        let expr0_0 = AluOPRRR::Srlw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 373.
                        let expr0_0 = AluOPRRR::Sraw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Ishl => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 327.
                        let expr0_0 = AluOPRRR::Sll;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::Ushr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 353.
                        let expr0_0 = AluOPRRR::Srl;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::Sshr => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 377.
                        let expr0_0 = AluOPRRR::Sra;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr3_0: usize = 0i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bitrev => {
                            // Rule at src/isa/riscv64/lower.isle line 263.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0: Type = I64;
                            let expr4_0 = constructor_lower_bit_reverse(ctx, expr2_0, expr3_0);
                            let expr5_0: usize = 1i128 as usize;
                            let expr6_0 = C::value_regs_get(ctx, expr0_0, expr5_0);
                            let expr7_0: Type = I64;
                            let expr8_0 = constructor_lower_bit_reverse(ctx, expr6_0, expr7_0);
                            let expr9_0 = C::value_regs(ctx, expr8_0, expr4_0);
                            let expr10_0 = C::output(ctx, expr9_0);
                            return Some(expr10_0);
                        }
                        &Opcode::Clz => {
                            // Rule at src/isa/riscv64/lower.isle line 280.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_clz_i128(ctx, expr0_0);
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Cls => {
                            // Rule at src/isa/riscv64/lower.isle line 426.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_cls_i128(ctx, expr0_0);
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Ctz => {
                            // Rule at src/isa/riscv64/lower.isle line 274.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_ctz_128(ctx, expr0_0);
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Popcnt => {
                            // Rule at src/isa/riscv64/lower.isle line 304.
                            let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_popcnt_i128(ctx, expr0_0);
                            let expr2_0 = C::output(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Load {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                    offset: pattern5_3,
                } => {
                    if let &Opcode::Load = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 714.
                        let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr1_0 =
                            constructor_gen_load_128(ctx, expr0_0, pattern5_3, pattern5_2);
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::BandNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 295.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_gen_andn(ctx, expr2_0, expr5_0);
                            let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr7_0, expr8_0);
                            let expr10_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr11_0: usize = 1i128 as usize;
                            let expr12_0 = C::value_regs_get(ctx, expr10_0, expr11_0);
                            let expr13_0 = constructor_gen_andn(ctx, expr9_0, expr12_0);
                            let expr14_0 = C::value_regs(ctx, expr6_0, expr13_0);
                            let expr15_0 = C::output(ctx, expr14_0);
                            return Some(expr15_0);
                        }
                        &Opcode::BorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 416.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_gen_orn(ctx, expr2_0, expr5_0);
                            let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr7_0, expr8_0);
                            let expr10_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr11_0: usize = 1i128 as usize;
                            let expr12_0 = C::value_regs_get(ctx, expr10_0, expr11_0);
                            let expr13_0 = constructor_gen_orn(ctx, expr9_0, expr12_0);
                            let expr14_0 = C::value_regs(ctx, expr6_0, expr13_0);
                            let expr15_0 = C::output(ctx, expr14_0);
                            return Some(expr15_0);
                        }
                        &Opcode::BxorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 404.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_gen_xor_not(ctx, expr2_0, expr5_0);
                            let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr7_0, expr8_0);
                            let expr10_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr11_0: usize = 1i128 as usize;
                            let expr12_0 = C::value_regs_get(ctx, expr10_0, expr11_0);
                            let expr13_0 = constructor_gen_xor_not(ctx, expr9_0, expr12_0);
                            let expr14_0 = C::value_regs(ctx, expr6_0, expr13_0);
                            let expr15_0 = C::output(ctx, expr14_0);
                            return Some(expr15_0);
                        }
                        &Opcode::Rotl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 389.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_rotl(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Rotr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 396.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_rotr(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_1) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 37.
                                        let expr0_0 = constructor_select_addi(ctx, pattern3_0);
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 196.
                                        let expr0_0 = AluOPRRI::Andi;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 216.
                                        let expr0_0 = AluOPRRI::Ori;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        if let Some(pattern8_0) = C::def_inst(ctx, pattern7_0) {
                            let pattern9_0 = C::inst_data(ctx, pattern8_0);
                            if let &InstructionData::UnaryImm {
                                opcode: ref pattern10_0,
                                imm: pattern10_1,
                            } = &pattern9_0
                            {
                                if let &Opcode::Iconst = pattern10_0 {
                                    let pattern12_0 = C::u64_from_imm64(ctx, pattern10_1);
                                    if let Some(pattern13_0) = C::imm12_from_u64(ctx, pattern12_0) {
                                        // Rule at src/isa/riscv64/lower.isle line 234.
                                        let expr0_0 = AluOPRRI::Xori;
                                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                                        let expr2_0 = constructor_alu_rr_imm12(
                                            ctx,
                                            &expr0_0,
                                            expr1_0,
                                            pattern13_0,
                                        );
                                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                                        return Some(expr3_0);
                                    }
                                }
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            if let Some(pattern4_0) = C::fits_in_16(ctx, pattern3_0) {
                let pattern5_0 = C::inst_data(ctx, pattern0_0);
                if let &InstructionData::AtomicRmw {
                    opcode: ref pattern6_0,
                    args: ref pattern6_1,
                    flags: pattern6_2,
                    op: ref pattern6_3,
                } = &pattern5_0
                {
                    if let &Opcode::AtomicRmw = pattern6_0 {
                        let (pattern8_0, pattern8_1) = C::unpack_value_array_2(ctx, pattern6_1);
                        // Rule at src/isa/riscv64/lower.isle line 467.
                        let expr0_0 = C::put_in_reg(ctx, pattern8_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern8_1);
                        let expr2_0 = constructor_gen_atomic_rmw_loop(
                            ctx, pattern6_3, pattern4_0, expr0_0, expr1_0,
                        );
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        if let &InstructionData::Ternary {
            opcode: ref pattern4_0,
            args: ref pattern4_1,
        } = &pattern3_0
        {
            if let &Opcode::Select = pattern4_0 {
                let (pattern6_0, pattern6_1, pattern6_2) = C::unpack_value_array_3(ctx, pattern4_1);
                if let Some(pattern7_0) = C::def_inst(ctx, pattern6_0) {
                    let pattern8_0 = C::inst_data(ctx, pattern7_0);
                    if let &InstructionData::IntCompare {
                        opcode: ref pattern9_0,
                        args: ref pattern9_1,
                        cond: ref pattern9_2,
                    } = &pattern8_0
                    {
                        if let &Opcode::Icmp = pattern9_0 {
                            let (pattern11_0, pattern11_1) =
                                C::unpack_value_array_2(ctx, pattern9_1);
                            let pattern12_0 = C::value_type(ctx, pattern11_1);
                            // Rule at src/isa/riscv64/lower.isle line 614.
                            let expr0_0 = C::put_in_regs(ctx, pattern11_0);
                            let expr1_0 =
                                constructor_normalize_cmp_value(ctx, pattern12_0, expr0_0);
                            let expr2_0 = constructor_convert_valueregs_reg(ctx, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern11_1);
                            let expr4_0 =
                                constructor_normalize_cmp_value(ctx, pattern12_0, expr3_0);
                            let expr5_0 = constructor_convert_valueregs_reg(ctx, expr4_0);
                            let expr6_0 = C::put_in_reg(ctx, pattern6_1);
                            let expr7_0 = C::put_in_reg(ctx, pattern6_2);
                            let expr8_0 = C::gen_select_reg(
                                ctx, pattern9_2, expr2_0, expr5_0, expr6_0, expr7_0,
                            );
                            let expr9_0 = constructor_output_reg(ctx, expr8_0);
                            return Some(expr9_0);
                        }
                    }
                }
            }
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    if let &InstructionData::Store {
        opcode: ref pattern2_0,
        args: ref pattern2_1,
        flags: pattern2_2,
        offset: pattern2_3,
    } = &pattern1_0
    {
        if let &Opcode::Store = pattern2_0 {
            let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
            let pattern5_0 = C::value_type(ctx, pattern4_0);
            if pattern5_0 == I128 {
                // Rule at src/isa/riscv64/lower.isle line 738.
                let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                let expr1_0 = C::put_in_regs(ctx, pattern4_0);
                let expr2_0 =
                    constructor_gen_store_128(ctx, expr0_0, pattern2_3, pattern2_2, expr1_0);
                return Some(expr2_0);
            }
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if pattern2_0 == I32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 172.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0: Type = I32;
                        let expr3_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0);
                        let expr5_0 = constructor_gen_div_by_zero(ctx, expr4_0);
                        let expr6_0 = AluOPRRR::Remuw;
                        let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr8_0 = constructor_alu_rrr(ctx, &expr6_0, expr7_0, expr4_0);
                        let expr9_0 = constructor_output_reg(ctx, expr8_0);
                        return Some(expr9_0);
                    }
                    &Opcode::Srem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 166.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0: Type = I32;
                        let expr3_0 = constructor_ext_int_if_need(ctx, expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_convert_valueregs_reg(ctx, expr3_0);
                        let expr5_0 = constructor_gen_div_by_zero(ctx, expr4_0);
                        let expr6_0 = AluOPRRR::Remw;
                        let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr8_0 = constructor_alu_rrr(ctx, &expr6_0, expr7_0, expr4_0);
                        let expr9_0 = constructor_output_reg(ctx, expr8_0);
                        return Some(expr9_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Udiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 147.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr1_0 = constructor_gen_div_by_zero(ctx, expr0_0);
                        let expr2_0 = AluOPRRR::DivU;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr2_0, expr3_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::Sdiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 141.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr2_0: Type = I64;
                        let expr3_0 = constructor_gen_div_overflow(ctx, expr0_0, expr1_0, expr2_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_gen_div_by_zero(ctx, expr4_0);
                        let expr6_0 = AluOPRRR::Div;
                        let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr8_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr9_0 = constructor_alu_rrr(ctx, &expr6_0, expr7_0, expr8_0);
                        let expr10_0 = constructor_output_reg(ctx, expr9_0);
                        return Some(expr10_0);
                    }
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 183.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr1_0 = constructor_gen_div_by_zero(ctx, expr0_0);
                        let expr2_0 = AluOPRRR::RemU;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr2_0, expr3_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::Srem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 178.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr1_0 = constructor_gen_div_by_zero(ctx, expr0_0);
                        let expr2_0 = AluOPRRR::Rem;
                        let expr3_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr5_0 = constructor_alu_rrr(ctx, &expr2_0, expr3_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    _ => {}
                }
            }
        }
        if pattern2_0 == I128 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    if let &Opcode::Bnot = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 248.
                        let expr0_0 = C::put_in_regs(ctx, pattern5_1);
                        let expr1_0 = constructor_bnot_128(ctx, expr0_0);
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iadd => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 44.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr4_0: usize = 0i128 as usize;
                            let expr5_0 = C::value_regs_get(ctx, expr3_0, expr4_0);
                            let expr6_0 = constructor_alu_add(ctx, expr2_0, expr5_0);
                            let expr7_0 = AluOPRRR::SltU;
                            let expr8_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr9_0: usize = 0i128 as usize;
                            let expr10_0 = C::value_regs_get(ctx, expr8_0, expr9_0);
                            let expr11_0 = constructor_alu_rrr(ctx, &expr7_0, expr6_0, expr10_0);
                            let expr12_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr13_0: usize = 1i128 as usize;
                            let expr14_0 = C::value_regs_get(ctx, expr12_0, expr13_0);
                            let expr15_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr16_0: usize = 1i128 as usize;
                            let expr17_0 = C::value_regs_get(ctx, expr15_0, expr16_0);
                            let expr18_0 = constructor_alu_add(ctx, expr14_0, expr17_0);
                            let expr19_0 = constructor_alu_add(ctx, expr18_0, expr11_0);
                            let expr20_0 = C::value_regs(ctx, expr6_0, expr19_0);
                            let expr21_0 = C::output(ctx, expr20_0);
                            return Some(expr21_0);
                        }
                        &Opcode::Isub => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 73.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_i128_sub(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Imul => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 98.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0: usize = 0i128 as usize;
                            let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                            let expr3_0: usize = 1i128 as usize;
                            let expr4_0 = C::value_regs_get(ctx, expr0_0, expr3_0);
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0: usize = 0i128 as usize;
                            let expr7_0 = C::value_regs_get(ctx, expr5_0, expr6_0);
                            let expr8_0: usize = 1i128 as usize;
                            let expr9_0 = C::value_regs_get(ctx, expr5_0, expr8_0);
                            let expr10_0 = constructor_umulh(ctx, expr2_0, expr7_0);
                            let expr11_0 = constructor_madd(ctx, expr2_0, expr9_0, expr10_0);
                            let expr12_0 = constructor_madd(ctx, expr4_0, expr7_0, expr11_0);
                            let expr13_0 = C::zero_reg(ctx);
                            let expr14_0 = constructor_madd(ctx, expr2_0, expr7_0, expr13_0);
                            let expr15_0 = C::value_regs(ctx, expr14_0, expr12_0);
                            let expr16_0 = C::output(ctx, expr15_0);
                            return Some(expr16_0);
                        }
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 199.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 =
                                constructor_lower_b128_binary(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 218.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 =
                                constructor_lower_b128_binary(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 236.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr3_0 =
                                constructor_lower_b128_binary(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::output(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        &Opcode::Ishl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 330.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_ishl(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Ushr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 356.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0 = constructor_lower_i128_ushr(ctx, expr0_0, expr1_0);
                            let expr3_0 = C::output(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Sshr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 381.
                            let expr0_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr2_0: usize = 0i128 as usize;
                            let expr3_0 = C::value_regs_get(ctx, expr1_0, expr2_0);
                            let expr4_0 = C::value_reg(ctx, expr3_0);
                            let expr5_0 = constructor_lower_i128_sshr(ctx, expr0_0, expr4_0);
                            let expr6_0 = C::output(ctx, expr5_0);
                            return Some(expr6_0);
                        }
                        &Opcode::Iconcat => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 636.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0: Type = I64;
                            let expr2_0: Type = I64;
                            let expr3_0 = C::gen_move2(ctx, expr0_0, expr1_0, expr2_0);
                            let expr4_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr5_0: Type = I64;
                            let expr6_0: Type = I64;
                            let expr7_0 = C::gen_move2(ctx, expr4_0, expr5_0, expr6_0);
                            let expr8_0 = C::value_regs(ctx, expr3_0, expr7_0);
                            let expr9_0 = C::output(ctx, expr8_0);
                            return Some(expr9_0);
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F32 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bnot => {
                            // Rule at src/isa/riscv64/lower.isle line 251.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0: Type = F32;
                            let expr2_0 = constructor_lower_float_bnot(ctx, expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Sqrt => {
                            // Rule at src/isa/riscv64/lower.isle line 452.
                            let expr0_0 = FpuOPRR::FsqrtS;
                            let expr1_0: Type = F64;
                            let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr3_0 = constructor_fpu_rr(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = constructor_output_reg(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 202.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F32;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 220.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F32;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 238.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F32;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Ternary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Fma = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 445.
                        let expr0_0 = FpuOPRRRR::FmaddS;
                        let expr1_0: Type = F64;
                        let expr2_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr5_0 =
                            constructor_fpu_rrrr(ctx, &expr0_0, expr1_0, expr2_0, expr3_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                }
                _ => {}
            }
        }
        if pattern2_0 == F64 {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Bnot => {
                            // Rule at src/isa/riscv64/lower.isle line 255.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0: Type = F64;
                            let expr2_0 = constructor_lower_float_bnot(ctx, expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Sqrt => {
                            // Rule at src/isa/riscv64/lower.isle line 455.
                            let expr0_0 = FpuOPRR::FsqrtD;
                            let expr1_0: Type = F64;
                            let expr2_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr3_0 = constructor_fpu_rr(ctx, &expr0_0, expr1_0, expr2_0);
                            let expr4_0 = constructor_output_reg(ctx, expr3_0);
                            return Some(expr4_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Band => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 204.
                            let expr0_0 = AluOPRRR::And;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F64;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                        &Opcode::Bor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 222.
                            let expr0_0 = AluOPRRR::Or;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F64;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                        &Opcode::Bxor => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 240.
                            let expr0_0 = AluOPRRR::Xor;
                            let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr3_0: Type = F64;
                            let expr4_0 = constructor_lower_float_binary(
                                ctx, &expr0_0, expr1_0, expr2_0, expr3_0,
                            );
                            let expr5_0 = constructor_output_reg(ctx, expr4_0);
                            return Some(expr5_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Ternary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    if let &Opcode::Fma = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 447.
                        let expr0_0 = FpuOPRRRR::FmaddD;
                        let expr1_0: Type = F64;
                        let expr2_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr4_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr5_0 =
                            constructor_fpu_rrrr(ctx, &expr0_0, expr1_0, expr2_0, expr3_0, expr4_0);
                        let expr6_0 = constructor_output_reg(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::Unary {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Iabs => {
                            // Rule at src/isa/riscv64/lower.isle line 870.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_iabs(ctx, pattern3_0, expr0_0);
                            let expr2_0 = constructor_output_reg(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Cls => {
                            // Rule at src/isa/riscv64/lower.isle line 424.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_cls(ctx, expr0_0, pattern3_0);
                            let expr2_0 = constructor_output_reg(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        &Opcode::Popcnt => {
                            // Rule at src/isa/riscv64/lower.isle line 302.
                            let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                            let expr1_0 = constructor_lower_popcnt(ctx, expr0_0, pattern3_0);
                            let expr2_0 = constructor_output_reg(ctx, expr1_0);
                            return Some(expr2_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::Binary {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                } => {
                    match pattern5_0 {
                        &Opcode::Umulhi => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 94.
                            let expr0_0: bool = false;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                            let expr4_0: bool = false;
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0 =
                                constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0);
                            let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0);
                            let expr8_0 =
                                constructor_lower_umlhi(ctx, pattern3_0, expr3_0, expr7_0);
                            let expr9_0 = constructor_output_reg(ctx, expr8_0);
                            return Some(expr9_0);
                        }
                        &Opcode::Smulhi => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 90.
                            let expr0_0: bool = true;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                            let expr4_0: bool = true;
                            let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr6_0 =
                                constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0);
                            let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0);
                            let expr8_0 =
                                constructor_lower_smlhi(ctx, pattern3_0, expr3_0, expr7_0);
                            let expr9_0 = constructor_output_reg(ctx, expr8_0);
                            return Some(expr9_0);
                        }
                        &Opcode::BandNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 293.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_gen_andn(ctx, expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::BorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 413.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_gen_orn(ctx, expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::BxorNot => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 402.
                            let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                            let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                            let expr2_0 = constructor_gen_xor_not(ctx, expr0_0, expr1_0);
                            let expr3_0 = constructor_output_reg(ctx, expr2_0);
                            return Some(expr3_0);
                        }
                        &Opcode::Rotl => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 386.
                            let expr0_0: bool = false;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                            let expr4_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr5_0: usize = 0i128 as usize;
                            let expr6_0 = C::value_regs_get(ctx, expr4_0, expr5_0);
                            let expr7_0 = constructor_lower_rotl(ctx, pattern3_0, expr3_0, expr6_0);
                            let expr8_0 = constructor_output_reg(ctx, expr7_0);
                            return Some(expr8_0);
                        }
                        &Opcode::Rotr => {
                            let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                            // Rule at src/isa/riscv64/lower.isle line 393.
                            let expr0_0: bool = false;
                            let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                            let expr2_0 =
                                constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                            let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                            let expr4_0 = C::put_in_regs(ctx, pattern7_1);
                            let expr5_0: usize = 0i128 as usize;
                            let expr6_0 = C::value_regs_get(ctx, expr4_0, expr5_0);
                            let expr7_0 = constructor_lower_rotr(ctx, pattern3_0, expr3_0, expr6_0);
                            let expr8_0 = constructor_output_reg(ctx, expr7_0);
                            return Some(expr8_0);
                        }
                        _ => {}
                    }
                }
                &InstructionData::IntAddTrap {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    code: ref pattern5_2,
                } => {
                    if let &Opcode::UaddOverflowTrap = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 58.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_lower_uadd_overflow(ctx, expr0_0, expr1_0, pattern3_0);
                        let expr3_0: usize = 1i128 as usize;
                        let expr4_0 = C::value_regs_get(ctx, expr2_0, expr3_0);
                        let expr5_0 = constructor_gen_trapif(ctx, expr4_0, pattern5_2);
                        let expr6_0: usize = 0i128 as usize;
                        let expr7_0 = C::value_regs_get(ctx, expr2_0, expr6_0);
                        let expr8_0 = constructor_output_reg(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                }
                _ => {}
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            match &pattern4_0 {
                &InstructionData::LoadNoOffset {
                    opcode: ref pattern5_0,
                    arg: pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::AtomicLoad = pattern5_0 {
                        // Rule at src/isa/riscv64/lower.isle line 516.
                        let expr0_0 = C::put_in_reg(ctx, pattern5_1);
                        let expr1_0 = constructor_gen_atomic_load(ctx, expr0_0, pattern3_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                }
                &InstructionData::AtomicRmw {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    flags: pattern5_2,
                    op: ref pattern5_3,
                } => {
                    if let &Opcode::AtomicRmw = pattern5_0 {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        match pattern5_3 {
                            &AtomicRmwOp::Nand => {
                                // Rule at src/isa/riscv64/lower.isle line 507.
                                let expr0_0 = AtomicRmwOp::Nand;
                                let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                                let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                                let expr3_0 = constructor_gen_atomic_rmw_loop(
                                    ctx, &expr0_0, pattern3_0, expr1_0, expr2_0,
                                );
                                let expr4_0 = constructor_output_reg(ctx, expr3_0);
                                return Some(expr4_0);
                            }
                            &AtomicRmwOp::Sub => {
                                // Rule at src/isa/riscv64/lower.isle line 489.
                                let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
                                let expr1_0 = AluOPRRR::Sub;
                                let expr2_0 = C::zero_reg(ctx);
                                let expr3_0 = C::put_in_reg(ctx, pattern7_1);
                                let expr4_0 = constructor_alu_rrr(ctx, &expr1_0, expr2_0, expr3_0);
                                let expr5_0 = AtomicRmwOp::Add;
                                let expr6_0 =
                                    constructor_get_atomic_rmw_op(ctx, pattern3_0, &expr5_0);
                                let expr7_0 = C::put_in_reg(ctx, pattern7_0);
                                let expr8_0 = C::atomic_amo(ctx);
                                let expr9_0 = constructor_gen_atomic(
                                    ctx, &expr6_0, expr7_0, expr4_0, expr8_0,
                                );
                                let expr10_0 = constructor_output_reg(ctx, expr9_0);
                                return Some(expr10_0);
                            }
                            _ => {}
                        }
                    }
                }
                &InstructionData::AtomicCas {
                    opcode: ref pattern5_0,
                    args: ref pattern5_1,
                    flags: pattern5_2,
                } => {
                    if let &Opcode::AtomicCas = pattern5_0 {
                        let (pattern7_0, pattern7_1, pattern7_2) =
                            C::unpack_value_array_3(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 542.
                        let expr0_0 = C::temp_writable_reg(ctx, pattern3_0);
                        let expr1_0 = C::temp_writable_reg(ctx, pattern3_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr3_0 = constructor_gen_atomic_offset(ctx, expr2_0, pattern3_0);
                        let expr4_0: bool = false;
                        let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0);
                        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0);
                        let expr8_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr9_0 = constructor_gen_atomic_p(ctx, expr8_0, pattern3_0);
                        let expr10_0 = C::put_in_reg(ctx, pattern7_2);
                        let expr11_0 = MInst::AtomicCas {
                            offset: expr3_0,
                            t0: expr0_0,
                            dst: expr1_0,
                            e: expr7_0,
                            addr: expr9_0,
                            v: expr10_0,
                            ty: pattern3_0,
                        };
                        let expr12_0 = C::emit(ctx, &expr11_0);
                        let expr13_0 = C::writable_reg_to_reg(ctx, expr1_0);
                        let expr14_0 = constructor_output_reg(ctx, expr13_0);
                        return Some(expr14_0);
                    }
                }
                _ => {}
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        match &pattern3_0 {
            &InstructionData::NullAry {
                opcode: ref pattern4_0,
            } => {
                if let &Opcode::Null = pattern4_0 {
                    // Rule at src/isa/riscv64/lower.isle line 24.
                    let expr0_0: u64 = 0i128 as u64;
                    let expr1_0 = C::imm(ctx, pattern2_0, expr0_0);
                    let expr2_0 = constructor_output_reg(ctx, expr1_0);
                    return Some(expr2_0);
                }
            }
            &InstructionData::Unary {
                opcode: ref pattern4_0,
                arg: pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Ineg => {
                        // Rule at src/isa/riscv64/lower.isle line 79.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr1_0 = constructor_neg(ctx, pattern2_0, expr0_0);
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Bitrev => {
                        // Rule at src/isa/riscv64/lower.isle line 260.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_bit_reverse(ctx, expr0_0, pattern2_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Clz => {
                        // Rule at src/isa/riscv64/lower.isle line 278.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_clz(ctx, pattern2_0, expr0_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Ctz => {
                        // Rule at src/isa/riscv64/lower.isle line 271.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_ctz(ctx, pattern2_0, expr0_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Fneg => {
                        // Rule at src/isa/riscv64/lower.isle line 437.
                        let expr0_0 = constructor_f_copy_neg_sign_op(ctx, pattern2_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr3_0 =
                            constructor_fpu_rrr(ctx, &expr0_0, pattern2_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Fabs => {
                        // Rule at src/isa/riscv64/lower.isle line 432.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0 = constructor_gen_fabs(ctx, expr0_0, pattern2_0);
                        let expr2_0 = constructor_output_reg(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Ceil => {
                        // Rule at src/isa/riscv64/lower.isle line 815.
                        let expr0_0 = FloatRoundOP::Ceil;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Floor => {
                        // Rule at src/isa/riscv64/lower.isle line 821.
                        let expr0_0 = FloatRoundOP::Floor;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Trunc => {
                        // Rule at src/isa/riscv64/lower.isle line 825.
                        let expr0_0 = FloatRoundOP::Trunc;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Nearest => {
                        // Rule at src/isa/riscv64/lower.isle line 830.
                        let expr0_0 = FloatRoundOP::Nearest;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 =
                            constructor_gen_float_round(ctx, &expr0_0, expr1_0, pattern2_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Bmask => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 849.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr1_0 = constructor_lower_bmask(ctx, pattern2_0, pattern6_0, expr0_0);
                        let expr2_0 = C::output(ctx, expr1_0);
                        return Some(expr2_0);
                    }
                    &Opcode::Ireduce => {
                        // Rule at src/isa/riscv64/lower.isle line 551.
                        let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                        let expr1_0: usize = 0i128 as usize;
                        let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                        let expr3_0 = C::gen_move2(ctx, expr2_0, pattern2_0, pattern2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Uextend => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 284.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0: bool = false;
                        let expr2_0 = C::ty_bits(ctx, pattern6_0);
                        let expr3_0 = C::ty_bits(ctx, pattern2_0);
                        let expr4_0 =
                            constructor_lower_extend(ctx, expr0_0, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = C::output(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Sextend => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 288.
                        let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr1_0: bool = true;
                        let expr2_0 = C::ty_bits(ctx, pattern6_0);
                        let expr3_0 = C::ty_bits(ctx, pattern2_0);
                        let expr4_0 =
                            constructor_lower_extend(ctx, expr0_0, expr1_0, expr2_0, expr3_0);
                        let expr5_0 = C::output(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Fpromote => {
                        // Rule at src/isa/riscv64/lower.isle line 556.
                        let expr0_0 = FpuOPRR::FcvtDS;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = constructor_fpu_rr(ctx, &expr0_0, pattern2_0, expr1_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Fdemote => {
                        // Rule at src/isa/riscv64/lower.isle line 560.
                        let expr0_0 = FpuOPRR::FcvtSD;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0 = constructor_fpu_rr(ctx, &expr0_0, pattern2_0, expr1_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::FcvtToUint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 775.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = false;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtToSint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 780.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = true;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtToUintSat => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 790.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = false;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtToSintSat => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 785.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr2_0: bool = true;
                        let expr3_0 = constructor_gen_fcvt_int(
                            ctx, expr0_0, expr1_0, expr2_0, pattern6_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtFromUint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 800.
                        let expr0_0: bool = false;
                        let expr1_0 =
                            C::int_convert_2_float_op(ctx, pattern6_0, expr0_0, pattern2_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr3_0 = constructor_fpu_rr(ctx, &expr1_0, pattern2_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FcvtFromSint => {
                        let pattern6_0 = C::value_type(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 795.
                        let expr0_0: bool = true;
                        let expr1_0 =
                            C::int_convert_2_float_op(ctx, pattern6_0, expr0_0, pattern2_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern4_1);
                        let expr3_0 = constructor_fpu_rr(ctx, &expr1_0, pattern2_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
            &InstructionData::LoadNoOffset {
                opcode: ref pattern4_0,
                arg: pattern4_1,
                flags: pattern4_2,
            } => {
                if let &Opcode::Bitcast = pattern4_0 {
                    let pattern6_0 = C::value_type(ctx, pattern4_1);
                    // Rule at src/isa/riscv64/lower.isle line 810.
                    let expr0_0 = C::put_in_regs(ctx, pattern4_1);
                    let expr1_0 = C::gen_moves(ctx, expr0_0, pattern6_0, pattern2_0);
                    let expr2_0 = C::output(ctx, expr1_0);
                    return Some(expr2_0);
                }
            }
            &InstructionData::Load {
                opcode: ref pattern4_0,
                arg: pattern4_1,
                flags: pattern4_2,
                offset: pattern4_3,
            } => {
                if let &Opcode::Load = pattern4_0 {
                    // Rule at src/isa/riscv64/lower.isle line 710.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::load_op(ctx, pattern2_0);
                    let expr2_0 = constructor_gen_load(
                        ctx, expr0_0, pattern4_3, &expr1_0, pattern4_2, pattern2_0,
                    );
                    let expr3_0 = constructor_output_reg(ctx, expr2_0);
                    return Some(expr3_0);
                }
            }
            &InstructionData::UnaryImm {
                opcode: ref pattern4_0,
                imm: pattern4_1,
            } => {
                if let &Opcode::Iconst = pattern4_0 {
                    let pattern6_0 = C::u64_from_imm64(ctx, pattern4_1);
                    // Rule at src/isa/riscv64/lower.isle line 9.
                    let expr0_0 = C::imm(ctx, pattern2_0, pattern6_0);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0);
                    return Some(expr1_0);
                }
            }
            &InstructionData::Binary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Smin => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 649.
                        let expr0_0 = IntSelectOP::Smin;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0);
                        let expr4_0: bool = true;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0);
                        let expr7_0 =
                            constructor_gen_int_select(ctx, pattern2_0, &expr0_0, expr3_0, expr6_0);
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Umin => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 658.
                        let expr0_0 = IntSelectOP::Umin;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0);
                        let expr4_0: bool = false;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0);
                        let expr7_0 =
                            constructor_gen_int_select(ctx, pattern2_0, &expr0_0, expr3_0, expr6_0);
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Smax => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 644.
                        let expr0_0 = IntSelectOP::Smax;
                        let expr1_0: bool = true;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0);
                        let expr4_0: bool = true;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0);
                        let expr7_0 =
                            constructor_gen_int_select(ctx, pattern2_0, &expr0_0, expr3_0, expr6_0);
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Umax => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 653.
                        let expr0_0 = IntSelectOP::Umax;
                        let expr1_0: bool = false;
                        let expr2_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr3_0 =
                            constructor_ext_int_if_need(ctx, expr1_0, expr2_0, pattern2_0);
                        let expr4_0: bool = false;
                        let expr5_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern2_0);
                        let expr7_0 =
                            constructor_gen_int_select(ctx, pattern2_0, &expr0_0, expr3_0, expr6_0);
                        let expr8_0 = C::output(ctx, expr7_0);
                        return Some(expr8_0);
                    }
                    &Opcode::Fadd => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 566.
                        let expr0_0 = Opcode::Fadd;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_output_reg(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Fsub => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 569.
                        let expr0_0 = Opcode::Fsub;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_output_reg(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Fmul => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 572.
                        let expr0_0 = Opcode::Fmul;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_output_reg(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Fdiv => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 575.
                        let expr0_0 = Opcode::Fdiv;
                        let expr1_0 = constructor_f_arithmatic_op(ctx, pattern2_0, &expr0_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr3_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr4_0 =
                            constructor_fpu_rrr(ctx, &expr1_0, pattern2_0, expr2_0, expr3_0);
                        let expr5_0 = constructor_output_reg(ctx, expr4_0);
                        return Some(expr5_0);
                    }
                    &Opcode::Fcopysign => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 441.
                        let expr0_0 = constructor_f_copysign_op(ctx, pattern2_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 =
                            constructor_fpu_rrr(ctx, &expr0_0, pattern2_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Fmin => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 579.
                        let expr0_0 = FloatSelectOP::Min;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FminPseudo => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 583.
                        let expr0_0 = FloatSelectOP::Min;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select_pseudo(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Fmax => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 587.
                        let expr0_0 = FloatSelectOP::Max;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::FmaxPseudo => {
                        let (pattern6_0, pattern6_1) = C::unpack_value_array_2(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 591.
                        let expr0_0 = FloatSelectOP::Max;
                        let expr1_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr3_0 = constructor_gen_float_select_pseudo(
                            ctx, &expr0_0, expr1_0, expr2_0, pattern2_0,
                        );
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
            &InstructionData::Ternary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                match pattern4_0 {
                    &Opcode::Select => {
                        let (pattern6_0, pattern6_1, pattern6_2) =
                            C::unpack_value_array_3(ctx, pattern4_1);
                        let pattern7_0 = C::value_type(ctx, pattern6_0);
                        // Rule at src/isa/riscv64/lower.isle line 611.
                        let expr0_0 = C::put_in_regs(ctx, pattern6_0);
                        let expr1_0 = constructor_normalize_cmp_value(ctx, pattern7_0, expr0_0);
                        let expr2_0 = constructor_truthy_to_reg(ctx, pattern7_0, expr1_0);
                        let expr3_0 = C::put_in_regs(ctx, pattern6_1);
                        let expr4_0 = C::put_in_regs(ctx, pattern6_2);
                        let expr5_0 =
                            constructor_gen_select(ctx, pattern2_0, expr2_0, expr3_0, expr4_0);
                        let expr6_0 = C::output(ctx, expr5_0);
                        return Some(expr6_0);
                    }
                    &Opcode::SelectSpectreGuard => {
                        let (pattern6_0, pattern6_1, pattern6_2) =
                            C::unpack_value_array_3(ctx, pattern4_1);
                        if let Some(pattern7_0) = C::def_inst(ctx, pattern6_0) {
                            let pattern8_0 = C::inst_data(ctx, pattern7_0);
                            if let &InstructionData::IntCompare {
                                opcode: ref pattern9_0,
                                args: ref pattern9_1,
                                cond: ref pattern9_2,
                            } = &pattern8_0
                            {
                                if let &Opcode::Icmp = pattern9_0 {
                                    let (pattern11_0, pattern11_1) =
                                        C::unpack_value_array_2(ctx, pattern9_1);
                                    let pattern12_0 = C::value_type(ctx, pattern11_0);
                                    // Rule at src/isa/riscv64/lower.isle line 836.
                                    let expr0_0 = C::alloc_vec_writable(ctx, pattern2_0);
                                    let expr1_0 = C::put_in_regs(ctx, pattern11_0);
                                    let expr2_0 = C::put_in_regs(ctx, pattern11_1);
                                    let expr3_0 = constructor_lower_icmp(
                                        ctx,
                                        pattern9_2,
                                        expr1_0,
                                        expr2_0,
                                        pattern12_0,
                                    );
                                    let expr4_0: bool = true;
                                    let expr5_0 = C::vec_writable_clone(ctx, &expr0_0);
                                    let expr6_0 = C::put_in_regs(ctx, pattern6_1);
                                    let expr7_0 = C::put_in_regs(ctx, pattern6_2);
                                    let expr8_0 = MInst::SelectIf {
                                        if_spectre_guard: expr4_0,
                                        rd: expr5_0,
                                        test: expr3_0,
                                        x: expr6_0,
                                        y: expr7_0,
                                    };
                                    let expr9_0 = C::emit(ctx, &expr8_0);
                                    let expr10_0 = C::vec_writable_to_regs(ctx, &expr0_0);
                                    let expr11_0 = C::output(ctx, expr10_0);
                                    return Some(expr11_0);
                                }
                            }
                        }
                    }
                    &Opcode::Bitselect => {
                        let (pattern6_0, pattern6_1, pattern6_2) =
                            C::unpack_value_array_3(ctx, pattern4_1);
                        // Rule at src/isa/riscv64/lower.isle line 623.
                        let expr0_0 = C::put_in_reg(ctx, pattern6_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern6_1);
                        let expr2_0 = C::put_in_reg(ctx, pattern6_2);
                        let expr3_0 =
                            constructor_gen_bitselect(ctx, pattern2_0, expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }
    let pattern1_0 = C::inst_data(ctx, pattern0_0);
    match &pattern1_0 {
        &InstructionData::NullAry {
            opcode: ref pattern2_0,
        } => {
            match pattern2_0 {
                &Opcode::Debugtrap => {
                    // Rule at src/isa/riscv64/lower.isle line 663.
                    let expr0_0 = MInst::EBreak;
                    let expr1_0 = SideEffectNoResult::Inst { inst: expr0_0 };
                    let expr2_0 = constructor_side_effect(ctx, &expr1_0);
                    return Some(expr2_0);
                }
                &Opcode::GetFramePointer => {
                    // Rule at src/isa/riscv64/lower.isle line 859.
                    let expr0_0 = C::fp_reg(ctx);
                    let expr1_0 = constructor_gen_mov_from_preg(ctx, expr0_0);
                    let expr2_0 = constructor_output_reg(ctx, expr1_0);
                    return Some(expr2_0);
                }
                &Opcode::GetStackPointer => {
                    // Rule at src/isa/riscv64/lower.isle line 862.
                    let expr0_0 = C::sp_reg(ctx);
                    let expr1_0 = constructor_gen_mov_from_preg(ctx, expr0_0);
                    let expr2_0 = constructor_output_reg(ctx, expr1_0);
                    return Some(expr2_0);
                }
                &Opcode::GetReturnAddress => {
                    // Rule at src/isa/riscv64/lower.isle line 865.
                    let expr0_0 = C::load_ra(ctx);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0);
                    return Some(expr1_0);
                }
                &Opcode::Fence => {
                    // Rule at src/isa/riscv64/lower.isle line 668.
                    let expr0_0: u8 = 15i128 as u8;
                    let expr1_0: u8 = 15i128 as u8;
                    let expr2_0 = MInst::Fence {
                        pred: expr0_0,
                        succ: expr1_0,
                    };
                    let expr3_0 = SideEffectNoResult::Inst { inst: expr2_0 };
                    let expr4_0 = constructor_side_effect(ctx, &expr3_0);
                    return Some(expr4_0);
                }
                _ => {}
            }
        }
        &InstructionData::Unary {
            opcode: ref pattern2_0,
            arg: pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::IsNull => {
                    // Rule at src/isa/riscv64/lower.isle line 601.
                    let expr0_0 = ReferenceCheckOP::IsNull;
                    let expr1_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr2_0 = constructor_gen_reference_check(ctx, &expr0_0, expr1_0);
                    let expr3_0 = constructor_output_reg(ctx, expr2_0);
                    return Some(expr3_0);
                }
                &Opcode::IsInvalid => {
                    // Rule at src/isa/riscv64/lower.isle line 606.
                    let expr0_0 = ReferenceCheckOP::IsInvalid;
                    let expr1_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr2_0 = constructor_gen_reference_check(ctx, &expr0_0, expr1_0);
                    let expr3_0 = constructor_output_reg(ctx, expr2_0);
                    return Some(expr3_0);
                }
                &Opcode::Isplit => {
                    // Rule at src/isa/riscv64/lower.isle line 628.
                    let expr0_0 = C::put_in_regs(ctx, pattern2_1);
                    let expr1_0: usize = 0i128 as usize;
                    let expr2_0 = C::value_regs_get(ctx, expr0_0, expr1_0);
                    let expr3_0: Type = I64;
                    let expr4_0: Type = I64;
                    let expr5_0 = C::gen_move2(ctx, expr2_0, expr3_0, expr4_0);
                    let expr6_0 = C::put_in_regs(ctx, pattern2_1);
                    let expr7_0: usize = 1i128 as usize;
                    let expr8_0 = C::value_regs_get(ctx, expr6_0, expr7_0);
                    let expr9_0: Type = I64;
                    let expr10_0: Type = I64;
                    let expr11_0 = C::gen_move2(ctx, expr8_0, expr9_0, expr10_0);
                    let expr12_0 = C::value_reg(ctx, expr5_0);
                    let expr13_0 = C::value_reg(ctx, expr11_0);
                    let expr14_0 = C::output_pair(ctx, expr12_0, expr13_0);
                    return Some(expr14_0);
                }
                _ => {}
            }
        }
        &InstructionData::Load {
            opcode: ref pattern2_0,
            arg: pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            match pattern2_0 {
                &Opcode::Uload8 => {
                    // Rule at src/isa/riscv64/lower.isle line 683.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = false;
                    let expr2_0: u8 = 8i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0);
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    );
                    let expr6_0 = constructor_output_reg(ctx, expr5_0);
                    return Some(expr6_0);
                }
                &Opcode::Sload8 => {
                    // Rule at src/isa/riscv64/lower.isle line 687.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = true;
                    let expr2_0: u8 = 8i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0);
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    );
                    let expr6_0 = constructor_output_reg(ctx, expr5_0);
                    return Some(expr6_0);
                }
                &Opcode::Uload16 => {
                    // Rule at src/isa/riscv64/lower.isle line 691.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = false;
                    let expr2_0: u8 = 16i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0);
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    );
                    let expr6_0 = constructor_output_reg(ctx, expr5_0);
                    return Some(expr6_0);
                }
                &Opcode::Sload16 => {
                    // Rule at src/isa/riscv64/lower.isle line 696.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = true;
                    let expr2_0: u8 = 16i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0);
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    );
                    let expr6_0 = constructor_output_reg(ctx, expr5_0);
                    return Some(expr6_0);
                }
                &Opcode::Uload32 => {
                    // Rule at src/isa/riscv64/lower.isle line 701.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = false;
                    let expr2_0: u8 = 32i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0);
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    );
                    let expr6_0 = constructor_output_reg(ctx, expr5_0);
                    return Some(expr6_0);
                }
                &Opcode::Sload32 => {
                    // Rule at src/isa/riscv64/lower.isle line 706.
                    let expr0_0 = C::put_in_reg(ctx, pattern2_1);
                    let expr1_0: bool = true;
                    let expr2_0: u8 = 32i128 as u8;
                    let expr3_0 = constructor_int_load_op(ctx, expr1_0, expr2_0);
                    let expr4_0: Type = I64;
                    let expr5_0 = constructor_gen_load(
                        ctx, expr0_0, pattern2_3, &expr3_0, pattern2_2, expr4_0,
                    );
                    let expr6_0 = constructor_output_reg(ctx, expr5_0);
                    return Some(expr6_0);
                }
                _ => {}
            }
        }
        &InstructionData::MultiAry {
            opcode: ref pattern2_0,
            args: pattern2_1,
        } => {
            if let &Opcode::Return = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                // Rule at src/isa/riscv64/lower.isle line 853.
                let expr0_0: usize = 0i128 as usize;
                let expr1_0 = C::value_slice_len(ctx, pattern4_0);
                let expr2_0 = C::range(ctx, expr0_0, expr1_0);
                let expr3_0 = constructor_lower_return(ctx, expr2_0, pattern4_0);
                return Some(expr3_0);
            }
        }
        &InstructionData::Call {
            opcode: ref pattern2_0,
            args: pattern2_1,
            func_ref: pattern2_2,
        } => {
            if let &Opcode::Call = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                let (pattern5_0, pattern5_1, pattern5_2) = C::func_ref_data(ctx, pattern2_2);
                // Rule at src/isa/riscv64/lower.isle line 875.
                let expr0_0 = C::gen_call(ctx, pattern5_0, pattern5_1, pattern5_2, pattern4_0);
                return Some(expr0_0);
            }
        }
        &InstructionData::CallIndirect {
            opcode: ref pattern2_0,
            args: pattern2_1,
            sig_ref: pattern2_2,
        } => {
            if let &Opcode::CallIndirect = pattern2_0 {
                let pattern4_0 = C::value_list_slice(ctx, pattern2_1);
                if let Some((pattern5_0, pattern5_1)) = C::value_slice_unwrap(ctx, pattern4_0) {
                    // Rule at src/isa/riscv64/lower.isle line 878.
                    let expr0_0 = C::gen_call_indirect(ctx, pattern2_2, pattern5_0, pattern5_1);
                    return Some(expr0_0);
                }
            }
        }
        &InstructionData::FuncAddr {
            opcode: ref pattern2_0,
            func_ref: pattern2_1,
        } => {
            if let &Opcode::FuncAddr = pattern2_0 {
                let (pattern4_0, pattern4_1, pattern4_2) = C::func_ref_data(ctx, pattern2_1);
                // Rule at src/isa/riscv64/lower.isle line 770.
                let expr0_0: i64 = 0i128 as i64;
                let expr1_0 = C::load_ext_name(ctx, pattern4_1, expr0_0);
                let expr2_0 = constructor_output_reg(ctx, expr1_0);
                return Some(expr2_0);
            }
        }
        &InstructionData::UnaryGlobalValue {
            opcode: ref pattern2_0,
            global_value: pattern2_1,
        } => {
            if let &Opcode::SymbolValue = pattern2_0 {
                if let Some((pattern4_0, pattern4_1, pattern4_2)) =
                    C::symbol_value_data(ctx, pattern2_1)
                {
                    // Rule at src/isa/riscv64/lower.isle line 805.
                    let expr0_0 = C::load_ext_name(ctx, pattern4_0, pattern4_2);
                    let expr1_0 = constructor_output_reg(ctx, expr0_0);
                    return Some(expr1_0);
                }
            }
        }
        &InstructionData::UnaryIeee32 {
            opcode: ref pattern2_0,
            imm: pattern2_1,
        } => {
            if let &Opcode::F32const = pattern2_0 {
                let pattern4_0 = C::u64_from_ieee32(ctx, pattern2_1);
                // Rule at src/isa/riscv64/lower.isle line 14.
                let expr0_0: Type = F32;
                let expr1_0 = C::imm(ctx, expr0_0, pattern4_0);
                let expr2_0 = constructor_output_reg(ctx, expr1_0);
                return Some(expr2_0);
            }
        }
        &InstructionData::UnaryIeee64 {
            opcode: ref pattern2_0,
            imm: pattern2_1,
        } => {
            if let &Opcode::F64const = pattern2_0 {
                let pattern4_0 = C::u64_from_ieee64(ctx, pattern2_1);
                // Rule at src/isa/riscv64/lower.isle line 19.
                let expr0_0: Type = F64;
                let expr1_0 = C::imm(ctx, expr0_0, pattern4_0);
                let expr2_0 = constructor_output_reg(ctx, expr1_0);
                return Some(expr2_0);
            }
        }
        &InstructionData::StackLoad {
            opcode: ref pattern2_0,
            stack_slot: pattern2_1,
            offset: pattern2_2,
        } => {
            if let &Opcode::StackAddr = pattern2_0 {
                // Rule at src/isa/riscv64/lower.isle line 596.
                let expr0_0 = C::gen_stack_addr(ctx, pattern2_1, pattern2_2);
                let expr1_0 = constructor_output_reg(ctx, expr0_0);
                return Some(expr1_0);
            }
        }
        &InstructionData::Trap {
            opcode: ref pattern2_0,
            code: ref pattern2_1,
        } => {
            match pattern2_0 {
                &Opcode::Trap => {
                    // Rule at src/isa/riscv64/lower.isle line 673.
                    let expr0_0 = constructor_udf(ctx, pattern2_1);
                    return Some(expr0_0);
                }
                &Opcode::ResumableTrap => {
                    // Rule at src/isa/riscv64/lower.isle line 678.
                    let expr0_0 = constructor_udf(ctx, pattern2_1);
                    return Some(expr0_0);
                }
                _ => {}
            }
        }
        &InstructionData::StoreNoOffset {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
        } => {
            if let &Opcode::AtomicStore = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                if let Some(pattern6_0) = C::valid_atomic_transaction(ctx, pattern5_0) {
                    // Rule at src/isa/riscv64/lower.isle line 522.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr2_0 = constructor_gen_atomic_store(ctx, expr0_0, pattern6_0, expr1_0);
                    return Some(expr2_0);
                }
            }
        }
        &InstructionData::Store {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            flags: pattern2_2,
            offset: pattern2_3,
        } => {
            match pattern2_0 {
                &Opcode::Store => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    let pattern5_0 = C::value_type(ctx, pattern4_0);
                    // Rule at src/isa/riscv64/lower.isle line 734.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = C::store_op(ctx, pattern5_0);
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    );
                    return Some(expr3_0);
                }
                &Opcode::Istore8 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/riscv64/lower.isle line 720.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = StoreOP::Sb;
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    );
                    return Some(expr3_0);
                }
                &Opcode::Istore16 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/riscv64/lower.isle line 724.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = StoreOP::Sh;
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    );
                    return Some(expr3_0);
                }
                &Opcode::Istore32 => {
                    let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                    // Rule at src/isa/riscv64/lower.isle line 729.
                    let expr0_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr1_0 = StoreOP::Sw;
                    let expr2_0 = C::put_in_reg(ctx, pattern4_0);
                    let expr3_0 = constructor_gen_store(
                        ctx, expr0_0, pattern2_3, &expr1_0, pattern2_2, expr2_0,
                    );
                    return Some(expr3_0);
                }
                _ => {}
            }
        }
        &InstructionData::FloatCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Fcmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                // Rule at src/isa/riscv64/lower.isle line 765.
                let expr0_0 =
                    constructor_gen_fcmp(ctx, pattern2_2, pattern4_0, pattern4_1, pattern5_0);
                let expr1_0 = constructor_output_reg(ctx, expr0_0);
                return Some(expr1_0);
            }
        }
        &InstructionData::IntCompare {
            opcode: ref pattern2_0,
            args: ref pattern2_1,
            cond: ref pattern2_2,
        } => {
            if let &Opcode::Icmp = pattern2_0 {
                let (pattern4_0, pattern4_1) = C::unpack_value_array_2(ctx, pattern2_1);
                let pattern5_0 = C::value_type(ctx, pattern4_0);
                // Rule at src/isa/riscv64/lower.isle line 752.
                let expr0_0 = C::put_in_regs(ctx, pattern4_0);
                let expr1_0 = C::put_in_regs(ctx, pattern4_1);
                let expr2_0 = constructor_lower_icmp(ctx, pattern2_2, expr0_0, expr1_0, pattern5_0);
                let expr3_0 = constructor_output_reg(ctx, expr2_0);
                return Some(expr3_0);
            }
        }
        _ => {}
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_16(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Urem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 154.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                        let expr4_0 = constructor_gen_div_by_zero(ctx, expr3_0);
                        let expr5_0 = AluOPRRR::Remuw;
                        let expr6_0: bool = false;
                        let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr8_0 =
                            constructor_ext_int_if_need(ctx, expr6_0, expr7_0, pattern3_0);
                        let expr9_0 = constructor_convert_valueregs_reg(ctx, expr8_0);
                        let expr10_0 = constructor_alu_rrr(ctx, &expr5_0, expr9_0, expr3_0);
                        let expr11_0 = constructor_output_reg(ctx, expr10_0);
                        return Some(expr11_0);
                    }
                    &Opcode::Srem => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 160.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                        let expr4_0 = constructor_gen_div_by_zero(ctx, expr3_0);
                        let expr5_0 = AluOPRRR::Remw;
                        let expr6_0: bool = true;
                        let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr8_0 =
                            constructor_ext_int_if_need(ctx, expr6_0, expr7_0, pattern3_0);
                        let expr9_0 = constructor_convert_valueregs_reg(ctx, expr8_0);
                        let expr10_0 = constructor_alu_rrr(ctx, &expr5_0, expr9_0, expr3_0);
                        let expr11_0 = constructor_output_reg(ctx, expr10_0);
                        return Some(expr11_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_32(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 29.
                        let expr0_0 = AluOPRRR::Addw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Isub => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 70.
                        let expr0_0 = AluOPRRR::Subw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 86.
                        let expr0_0 = AluOPRRR::Mulw;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Udiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 127.
                        let expr0_0: bool = false;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                        let expr4_0 = constructor_gen_div_by_zero(ctx, expr3_0);
                        let expr5_0 = AluOPRRR::Divuw;
                        let expr6_0: bool = false;
                        let expr7_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr8_0 =
                            constructor_ext_int_if_need(ctx, expr6_0, expr7_0, pattern3_0);
                        let expr9_0 = constructor_convert_valueregs_reg(ctx, expr8_0);
                        let expr10_0 = constructor_alu_rrr(ctx, &expr5_0, expr9_0, expr3_0);
                        let expr11_0 = constructor_output_reg(ctx, expr10_0);
                        return Some(expr11_0);
                    }
                    &Opcode::Sdiv => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 133.
                        let expr0_0: bool = true;
                        let expr1_0 = C::put_in_regs(ctx, pattern7_0);
                        let expr2_0 =
                            constructor_ext_int_if_need(ctx, expr0_0, expr1_0, pattern3_0);
                        let expr3_0 = constructor_convert_valueregs_reg(ctx, expr2_0);
                        let expr4_0: bool = true;
                        let expr5_0 = C::put_in_regs(ctx, pattern7_1);
                        let expr6_0 =
                            constructor_ext_int_if_need(ctx, expr4_0, expr5_0, pattern3_0);
                        let expr7_0 = constructor_convert_valueregs_reg(ctx, expr6_0);
                        let expr8_0 =
                            constructor_gen_div_overflow(ctx, expr3_0, expr7_0, pattern3_0);
                        let expr9_0 = constructor_gen_div_by_zero(ctx, expr7_0);
                        let expr10_0 = AluOPRRR::Divw;
                        let expr11_0 = constructor_alu_rrr(ctx, &expr10_0, expr3_0, expr7_0);
                        let expr12_0 = constructor_output_reg(ctx, expr11_0);
                        return Some(expr12_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Band => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 189.
                        let expr0_0 = AluOPRRR::And;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Bor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 209.
                        let expr0_0 = AluOPRRR::Or;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Bxor => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 227.
                        let expr0_0 = AluOPRRR::Xor;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
        }
        if let Some(pattern3_0) = C::valid_atomic_transaction(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::AtomicRmw {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
                flags: pattern5_2,
                op: ref pattern5_3,
            } = &pattern4_0
            {
                if let &Opcode::AtomicRmw = pattern5_0 {
                    let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                    // Rule at src/isa/riscv64/lower.isle line 460.
                    let expr0_0 = constructor_get_atomic_rmw_op(ctx, pattern3_0, pattern5_3);
                    let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                    let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                    let expr3_0 = C::atomic_amo(ctx);
                    let expr4_0 = constructor_gen_atomic(ctx, &expr0_0, expr1_0, expr2_0, expr3_0);
                    let expr5_0 = constructor_output_reg(ctx, expr4_0);
                    return Some(expr5_0);
                }
            }
        }
        let pattern3_0 = C::inst_data(ctx, pattern0_0);
        match &pattern3_0 {
            &InstructionData::Unary {
                opcode: ref pattern4_0,
                arg: pattern4_1,
            } => {
                if let &Opcode::Bnot = pattern4_0 {
                    // Rule at src/isa/riscv64/lower.isle line 245.
                    let expr0_0 = AluOPRRI::Xori;
                    let expr1_0 = C::put_in_reg(ctx, pattern4_1);
                    let expr2_0: i64 = -1i128 as i64;
                    let expr3_0 = C::imm_from_neg_bits(ctx, expr2_0);
                    let expr4_0 = constructor_alu_rr_imm12(ctx, &expr0_0, expr1_0, expr3_0);
                    let expr5_0 = constructor_output_reg(ctx, expr4_0);
                    return Some(expr5_0);
                }
            }
            &InstructionData::Ternary {
                opcode: ref pattern4_0,
                args: ref pattern4_1,
            } => {
                if let &Opcode::SelectSpectreGuard = pattern4_0 {
                    let (pattern6_0, pattern6_1, pattern6_2) =
                        C::unpack_value_array_3(ctx, pattern4_1);
                    let pattern7_0 = C::value_type(ctx, pattern6_0);
                    // Rule at src/isa/riscv64/lower.isle line 843.
                    let expr0_0 = C::put_in_regs(ctx, pattern6_0);
                    let expr1_0 = constructor_normalize_cmp_value(ctx, pattern7_0, expr0_0);
                    let expr2_0 = constructor_truthy_to_reg(ctx, pattern7_0, expr1_0);
                    let expr3_0 = C::put_in_regs(ctx, pattern6_1);
                    let expr4_0 = C::put_in_regs(ctx, pattern6_2);
                    let expr5_0 =
                        constructor_gen_select(ctx, pattern2_0, expr2_0, expr3_0, expr4_0);
                    let expr6_0 = C::output(ctx, expr5_0);
                    return Some(expr6_0);
                }
            }
            _ => {}
        }
    }
    let pattern0_0 = arg0;
    if let Some(pattern1_0) = C::first_result(ctx, pattern0_0) {
        let pattern2_0 = C::value_type(ctx, pattern1_0);
        if let Some(pattern3_0) = C::fits_in_64(ctx, pattern2_0) {
            let pattern4_0 = C::inst_data(ctx, pattern0_0);
            if let &InstructionData::Binary {
                opcode: ref pattern5_0,
                args: ref pattern5_1,
            } = &pattern4_0
            {
                match pattern5_0 {
                    &Opcode::Iadd => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 33.
                        let expr0_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr1_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr2_0 = constructor_alu_add(ctx, expr0_0, expr1_0);
                        let expr3_0 = constructor_output_reg(ctx, expr2_0);
                        return Some(expr3_0);
                    }
                    &Opcode::Isub => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 67.
                        let expr0_0 = AluOPRRR::Sub;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    &Opcode::Imul => {
                        let (pattern7_0, pattern7_1) = C::unpack_value_array_2(ctx, pattern5_1);
                        // Rule at src/isa/riscv64/lower.isle line 84.
                        let expr0_0 = AluOPRRR::Mul;
                        let expr1_0 = C::put_in_reg(ctx, pattern7_0);
                        let expr2_0 = C::put_in_reg(ctx, pattern7_1);
                        let expr3_0 = constructor_alu_rrr(ctx, &expr0_0, expr1_0, expr2_0);
                        let expr4_0 = constructor_output_reg(ctx, expr3_0);
                        return Some(expr4_0);
                    }
                    _ => {}
                }
            }
        }
    }
    return None;
}

// Generated as internal constructor for term gen_atomic_rmw_loop.
pub fn constructor_gen_atomic_rmw_loop<C: Context>(
    ctx: &mut C,
    arg0: &AtomicRmwOp,
    arg1: Type,
    arg2: Reg,
    arg3: Reg,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/lower.isle line 498.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0: Type = I64;
    let expr3_0 = C::temp_writable_reg(ctx, expr2_0);
    let expr4_0 = constructor_gen_atomic_offset(ctx, pattern2_0, pattern1_0);
    let expr5_0 = constructor_gen_atomic_p(ctx, pattern2_0, pattern1_0);
    let expr6_0 = MInst::AtomicRmwLoop {
        offset: expr4_0,
        op: pattern0_0.clone(),
        dst: expr1_0,
        ty: pattern1_0,
        p: expr5_0,
        x: pattern3_0,
        t0: expr3_0,
    };
    let expr7_0 = C::emit(ctx, &expr6_0);
    let expr8_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr8_0;
}

// Generated as internal constructor for term gen_atomic_offset.
pub fn constructor_gen_atomic_offset<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_16(ctx, pattern1_0) {
        // Rule at src/isa/riscv64/lower.isle line 526.
        let expr0_0: i32 = 3i128 as i32;
        let expr1_0 = constructor_alu_andi(ctx, pattern0_0, expr0_0);
        let expr2_0: i32 = 3i128 as i32;
        let expr3_0 = constructor_alu_slli(ctx, expr1_0, expr2_0);
        return expr3_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/lower.isle line 529.
    let expr0_0 = C::zero_reg(ctx);
    return expr0_0;
}

// Generated as internal constructor for term gen_atomic_p.
pub fn constructor_gen_atomic_p<C: Context>(ctx: &mut C, arg0: Reg, arg1: Type) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    if let Some(pattern2_0) = C::fits_in_16(ctx, pattern1_0) {
        // Rule at src/isa/riscv64/lower.isle line 533.
        let expr0_0: i32 = -4i128 as i32;
        let expr1_0 = constructor_alu_andi(ctx, pattern0_0, expr0_0);
        return expr1_0;
    }
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    // Rule at src/isa/riscv64/lower.isle line 536.
    return pattern0_0;
}

// Generated as internal constructor for term gen_icmp.
pub fn constructor_gen_icmp<C: Context>(
    ctx: &mut C,
    arg0: &IntCC,
    arg1: ValueRegs,
    arg2: ValueRegs,
    arg3: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/lower.isle line 744.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = MInst::Icmp {
        cc: pattern0_0.clone(),
        rd: expr1_0,
        a: pattern1_0,
        b: pattern2_0,
        ty: pattern3_0,
    };
    let expr3_0 = C::emit(ctx, &expr2_0);
    let expr4_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr4_0;
}

// Generated as internal constructor for term gen_fcmp.
pub fn constructor_gen_fcmp<C: Context>(
    ctx: &mut C,
    arg0: &FloatCC,
    arg1: Value,
    arg2: Value,
    arg3: Type,
) -> Reg {
    let pattern0_0 = arg0;
    let pattern1_0 = arg1;
    let pattern2_0 = arg2;
    let pattern3_0 = arg3;
    // Rule at src/isa/riscv64/lower.isle line 757.
    let expr0_0: Type = I64;
    let expr1_0 = C::temp_writable_reg(ctx, expr0_0);
    let expr2_0 = C::put_in_reg(ctx, pattern1_0);
    let expr3_0 = C::put_in_reg(ctx, pattern2_0);
    let expr4_0 = MInst::Fcmp {
        cc: pattern0_0.clone(),
        rd: expr1_0,
        rs1: expr2_0,
        rs2: expr3_0,
        ty: pattern3_0,
    };
    let expr5_0 = C::emit(ctx, &expr4_0);
    let expr6_0 = C::writable_reg_to_reg(ctx, expr1_0);
    return expr6_0;
}
