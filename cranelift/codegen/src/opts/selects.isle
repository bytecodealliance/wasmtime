;; `select`/`bitselect`-related rewrites

;; remove select when both choices are the same
(rule (simplify (select    ty _ x x)) x)
(rule (simplify (bitselect ty _ x x)) x)

;; Push zeroes to the right -- this makes the select `truthy`, as used elsewhere
;; if icmp { 0 } else { nonzero } => if !icmp { nonzero } else { 0 }
(rule (simplify (select sty (icmp cty cc x y)
                        zero@(iconst_u _ 0)
                        nonzero@(iconst_u _ (u64_nonzero _))))
    (select sty (icmp cty (intcc_complement cc) x y) nonzero zero))

;; if icmp(x, y) { 1 } else { 0 } => uextend(icmp(x, y))
(rule (simplify (select ty cmp@(icmp _ cc x y)
                        (iconst_u _ 1)
                        (iconst_u _ 0)))
    (uextend_maybe ty cmp))
;; if icmp(x, y) { -1 } else { 0 } => uextend(icmp(x, y))
(rule (simplify (select ty cmp@(icmp _ cc x y)
                        (iconst_s _ -1)
                        (iconst_s _ 0)))
    (bmask ty cmp))

;; Transform select-of-icmp into {u,s}{min,max} instructions where possible.
(rule (simplify (select ty (sgt _ x y) x y)) (smax ty x y))
(rule (simplify (select ty (sge _ x y) x y)) (smax ty x y))
(rule (simplify (select ty (ugt _ x y) x y)) (umax ty x y))
(rule (simplify (select ty (uge _ x y) x y)) (umax ty x y))
(rule (simplify (select ty (slt _ x y) x y)) (smin ty x y))
(rule (simplify (select ty (sle _ x y) x y)) (smin ty x y))
(rule (simplify (select ty (ult _ x y) x y)) (umin ty x y))
(rule (simplify (select ty (ule _ x y) x y)) (umin ty x y))

;; These are the same rules as above, but when the operands for select are swapped
(rule (simplify (select ty (slt _ x y) y x)) (smax ty x y))
(rule (simplify (select ty (sle _ x y) y x)) (smax ty x y))
(rule (simplify (select ty (ult _ x y) y x)) (umax ty x y))
(rule (simplify (select ty (ule _ x y) y x)) (umax ty x y))
(rule (simplify (select ty (sgt _ x y) y x)) (smin ty x y))
(rule (simplify (select ty (sge _ x y) y x)) (smin ty x y))
(rule (simplify (select ty (ugt _ x y) y x)) (umin ty x y))
(rule (simplify (select ty (uge _ x y) y x)) (umin ty x y))

;; Transform bitselect-of-icmp into {u,s}{min,max} instructions where possible.
(rule (simplify (bitselect ty @ (multi_lane _ _) (sgt _ x y) x y)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sge _ x y) x y)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ugt _ x y) x y)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (uge _ x y) x y)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (slt _ x y) x y)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sle _ x y) x y)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ult _ x y) x y)) (umin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ule _ x y) x y)) (umin ty x y))

;; These are the same rules as above, but when the operands for select are swapped
(rule (simplify (bitselect ty @ (multi_lane _ _) (slt _ x y) y x)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sle _ x y) y x)) (smax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ult _ x y) y x)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ule _ x y) y x)) (umax ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sgt _ x y) y x)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (sge _ x y) y x)) (smin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (ugt _ x y) y x)) (umin ty x y))
(rule (simplify (bitselect ty @ (multi_lane _ _) (uge _ x y) y x)) (umin ty x y))

;; (c & x) | (~c & y) -> (bitselect c x y)
;; These are all the same rule, just with different permutations of the operands
;;
;; We currently only match vectors since scalar floats and i128's are not supported
;; in some backends.
(rule (simplify (bor (ty_vec128 ty) (band ty c x) (band ty (bnot ty c) y))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty c x) (band ty y (bnot ty c) ))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty x c) (band ty (bnot ty c) y))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty x c) (band ty y (bnot ty c) ))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty (bnot ty c) y) (band ty c x))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty (bnot ty c) y) (band ty x c))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty y (bnot ty c)) (band ty c x))) (bitselect ty c x y))
(rule (simplify (bor (ty_vec128 ty) (band ty y (bnot ty c)) (band ty x c))) (bitselect ty c x y))

;; transpose select on operation to operation on select when it increases sharing
;; select(cond, unop(x), unop(y)) => unop(select(cond, x, y))
(rule (simplify (select ty cond (unop _ op x) (unop _ op y)))
      (unop ty op (select ty cond x y)))

;; select(cond, binop(x, z), binop(y, z)) => binop(select(cond, x, y), z)
(rule (simplify (select ty cond (binop _ op x z) (binop _ op y z)))
      (binop ty op (select ty cond x y) z))

;; select(cond, binop(x, y), binop(x, z)) => binop(x, select(cond, y, z))
(rule (simplify (select ty cond (binop _ op x y) (binop _ op x z)))
      (binop ty op x (select ty cond y z)))

;; select(cond, ternop(w, y, z), ternop(x, y, z)) => ternop(select(cond, w, x), y, z)
(rule (simplify (select ty cond (ternop ty op w y z) (ternop ty op x y z)))
      (ternop ty op (select ty cond w x) y z))

;; select(cond, ternop(w, x, z), ternop(w, y, z)) => ternop(w, select(cond, x, y), z)
(rule (simplify (select ty cond (ternop _ op w x z) (ternop _ op w y z)))
      (ternop ty op w (select ty cond x y) z))

;; select(cond, ternop(w, x, y), ternop(w, x, z)) => ternop(w, x, select(cond, y, z))
(rule (simplify (select ty cond (ternop _ op w x y) (ternop _ op w x z)))
      (ternop ty op w x (select ty cond y z)))

;; select(cond, icmp(cc, x, z), icmp(cc, y, z)) => icmp(cc, select(cond, x, y), z)
(rule (simplify (select cmp_ty cond (icmp cmp_ty cc x @ (value_type sel_ty) z) (icmp cmp_ty cc y z)))
      (icmp cmp_ty cc (select sel_ty cond x y) z))

;; select(cond, icmp(cc, x, y), icmp(cc, x, z)) => icmp(cc, x, select(cond, y, z))
(rule (simplify (select cmp_ty cond (icmp cmp_ty cc x @ (value_type sel_ty) y) (icmp cmp_ty cc x z)))
      (icmp cmp_ty cc x (select sel_ty cond y z)))

;; select(cond, fcmp(cc, x, z), fcmp(cc, y, z)) => fcmp(cc, select(cond, x, y), z)
(rule (simplify (select cmp_ty cond (fcmp cmp_ty cc x @ (value_type sel_ty) z) (fcmp cmp_ty cc y z)))
      (fcmp cmp_ty cc (select sel_ty cond x y) z))

;; select(cond, fcmp(cc, x, y), fcmp(cc, x, z)) => fcmp(cc, x, select(cond, y, z))
(rule (simplify (select cmp_ty cond (fcmp cmp_ty cc x @ (value_type sel_ty) y) (fcmp cmp_ty cc x z)))
      (fcmp cmp_ty cc x (select sel_ty cond y z)))
