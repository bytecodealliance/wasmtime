/**
 * \file wasmtime/error.h
 *
 * \brief Definition and accessors of #wasmtime_error_t
 */

#ifndef WASMTIME_ERROR_H
#define WASMTIME_ERROR_H

#include <wasm.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * \typedef wasmtime_error_t
 * \brief Convenience alias for #wasmtime_error
 *
 * \struct wasmtime_error
 * \brief Errors generated by Wasmtime.
 * \headerfile wasmtime/error.h
 *
 * This opaque type represents an error that happened as part of one of the
 * functions below. Errors primarily have an error message associated with them
 * at this time, which you can acquire by calling #wasmtime_error_message.
 *
 * Errors are safe to share across threads and must be deleted with
 * #wasmtime_error_delete.
 */
typedef struct wasmtime_error wasmtime_error_t;

/**
 * \brief Creates a new error with the provided message.
 */
WASM_API_EXTERN wasmtime_error_t *wasmtime_error_new(const char *);

/**
 * \brief Deletes an error.
 */
WASM_API_EXTERN void wasmtime_error_delete(wasmtime_error_t *error);

/**
 * \brief Returns the string description of this error.
 *
 * This will "render" the error to a string and then return the string
 * representation of the error to the caller. The `message` argument should be
 * uninitialized before this function is called and the caller is responsible
 * for deallocating it with #wasm_byte_vec_delete afterwards.
 */
WASM_API_EXTERN void wasmtime_error_message(const wasmtime_error_t *error,
                                            wasm_name_t *message);

/**
 * \brief Attempts to extract a WASI-specific exit status from this error.
 *
 * Returns `true` if the error is a WASI "exit" trap and has a return status.
 * If `true` is returned then the exit status is returned through the `status`
 * pointer. If `false` is returned then this is not a wasi exit trap.
 */
WASM_API_EXTERN bool wasmtime_error_exit_status(const wasmtime_error_t *,
                                                int *status);

/**
 * \brief Attempts to extract a WebAssembly trace from this error.
 *
 * This is similar to #wasm_trap_trace except that it takes a #wasmtime_error_t
 * as input. The `out` argument will be filled in with the wasm trace, if
 * present.
 */
WASM_API_EXTERN void wasmtime_error_wasm_trace(const wasmtime_error_t *,
                                               wasm_frame_vec_t *out);

#ifdef __cplusplus
} // extern "C"
#endif

#ifdef __cplusplus

#include <memory>
#include <optional>
#include <string>
#include <variant>

namespace wasmtime {

class Trace;

/**
 * \brief Errors coming from Wasmtime
 *
 * This class represents an error that came from Wasmtime and contains a textual
 * description of the error that occurred.
 */
class Error {
  struct deleter {
    void operator()(wasmtime_error_t *p) const { wasmtime_error_delete(p); }
  };

  std::unique_ptr<wasmtime_error_t, deleter> ptr;

public:
  /// \brief Creates an error from the raw C API representation
  ///
  /// Takes ownership of the provided `error`.
  Error(wasmtime_error_t *error) : ptr(error) {}

  /// \brief Creates an error with the provided message.
  Error(const std::string &s) : ptr(wasmtime_error_new(s.c_str())) {}

  /// \brief Returns the error message associated with this error.
  std::string message() const {
    wasm_byte_vec_t msg_bytes;
    wasmtime_error_message(ptr.get(), &msg_bytes);
    auto ret = std::string(msg_bytes.data, msg_bytes.size);
    wasm_byte_vec_delete(&msg_bytes);
    return ret;
  }

  /// If this trap represents a call to `exit` for WASI, this will return the
  /// optional error code associated with the exit trap.
  std::optional<int32_t> i32_exit() const {
    int32_t status = 0;
    if (wasmtime_error_exit_status(ptr.get(), &status)) {
      return status;
    }
    return std::nullopt;
  }

  /// Returns the trace of WebAssembly frames associated with this error.
  ///
  /// Note that the `trace` cannot outlive this error object.
  Trace trace() const;
};

/// \brief Used to print an error.
inline std::ostream &operator<<(std::ostream &os, const Error &e) {
  os << e.message();
  return os;
}

/**
 * \brief Fallible result type used for Wasmtime.
 *
 * This type is used as the return value of many methods in the Wasmtime API.
 * This behaves similarly to Rust's `Result<T, E>` and will be replaced with a
 * C++ standard when it exists.
 */
template <typename T, typename E = Error> class [[nodiscard]] Result {
  std::variant<T, E> data;

public:
  /// \brief Creates a `Result` from its successful value.
  Result(T t) : data(std::move(t)) {}
  /// \brief Creates a `Result` from an error value.
  Result(E e) : data(std::move(e)) {}

  /// \brief Returns `true` if this result is a success, `false` if it's an
  /// error
  explicit operator bool() const { return data.index() == 0; }

  /// \brief Returns the error, if present, aborts if this is not an error.
  E &&err() { return std::get<E>(std::move(data)); }
  /// \brief Returns the error, if present, aborts if this is not an error.
  const E &&err() const { return std::get<E>(std::move(data)); }

  /// \brief Returns the success, if present, aborts if this is an error.
  T &&ok() { return std::get<T>(std::move(data)); }
  /// \brief Returns the success, if present, aborts if this is an error.
  const T &&ok() const { return std::get<T>(std::move(data)); }

  /// \brief Returns the success, if present, aborts if this is an error.
  T unwrap() {
    if (*this) {
      return this->ok();
    }
    unwrap_failed();
  }

private:
  [[noreturn]] void unwrap_failed() {
    fprintf(stderr, "error: %s\n", this->err().message().c_str()); // NOLINT
    std::abort();
  }
};

} // namespace wasmtime

#endif // __cplusplus

#endif // WASMTIME_ERROR_H
